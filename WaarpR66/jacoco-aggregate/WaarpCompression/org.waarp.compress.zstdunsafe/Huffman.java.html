<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Huffman.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp OpenR66</a> &gt; <a href="../index.html" class="el_bundle">WaarpCompression</a> &gt; <a href="index.source.html" class="el_package">org.waarp.compress.zstdunsafe</a> &gt; <span class="el_source">Huffman.java</span></div><h1>Huffman.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.waarp.compress.zstdunsafe;

import java.util.Arrays;

import static org.waarp.compress.zstdunsafe.BitInputStream.*;
import static org.waarp.compress.zstdunsafe.Constants.*;

<span class="fc" id="L41">class Huffman {</span>
  public static final int MAX_SYMBOL = 255;
  public static final int MAX_SYMBOL_COUNT = MAX_SYMBOL + 1;

  public static final int MAX_TABLE_LOG = 12;
  public static final int MIN_TABLE_LOG = 5;
  public static final int MAX_FSE_TABLE_LOG = 6;
  public static final String NOT_ENOUGH_INPUT_BYTES = &quot;Not enough input bytes&quot;;
  public static final String INPUT_IS_CORRUPTED = &quot;Input is corrupted&quot;;

  // stats
<span class="fc" id="L52">  private final byte[] weights = new byte[MAX_SYMBOL + 1];</span>
<span class="fc" id="L53">  private final int[] ranks = new int[MAX_TABLE_LOG + 1];</span>

  // table
<span class="fc" id="L56">  private int tableLog = -1;</span>
<span class="fc" id="L57">  private final byte[] symbols = new byte[1 &lt;&lt; MAX_TABLE_LOG];</span>
<span class="fc" id="L58">  private final byte[] numbersOfBits = new byte[1 &lt;&lt; MAX_TABLE_LOG];</span>

<span class="fc" id="L60">  private final FseTableReader reader = new FseTableReader();</span>
<span class="fc" id="L61">  private final FiniteStateEntropy.Table fseTable =</span>
      new FiniteStateEntropy.Table(MAX_FSE_TABLE_LOG);

  public boolean isLoaded() {
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">    return tableLog != -1;</span>
  }

  public int readTable(final Object inputBase, final long inputAddress,
                       final int size) {
<span class="fc" id="L70">    Arrays.fill(ranks, 0);</span>
<span class="fc" id="L71">    long input = inputAddress;</span>

    // read table header
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">    Util.verify(size &gt; 0, input, NOT_ENOUGH_INPUT_BYTES);</span>
<span class="fc" id="L75">    int inputSize = UnsafeUtil.UNSAFE.getByte(inputBase, input++) &amp; 0xFF;</span>

    final int outputSize;
<span class="fc bfc" id="L78" title="All 2 branches covered.">    if (inputSize &gt;= 128) {</span>
<span class="fc" id="L79">      outputSize = inputSize - 127;</span>
<span class="fc" id="L80">      inputSize = ((outputSize + 1) / 2);</span>

<span class="pc bpc" id="L82" title="1 of 2 branches missed.">      Util.verify(inputSize + 1 &lt;= size, input, NOT_ENOUGH_INPUT_BYTES);</span>
<span class="fc" id="L83">      Util.verify(true, input, INPUT_IS_CORRUPTED);</span>

<span class="fc bfc" id="L85" title="All 2 branches covered.">      for (int i = 0; i &lt; outputSize; i += 2) {</span>
<span class="fc" id="L86">        final int value =</span>
<span class="fc" id="L87">            UnsafeUtil.UNSAFE.getByte(inputBase, input + i / 2) &amp; 0xFF;</span>
<span class="fc" id="L88">        weights[i] = (byte) (value &gt;&gt;&gt; 4);</span>
<span class="fc" id="L89">        weights[i + 1] = (byte) (value &amp; 0xf);</span>
      }
    } else {
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">      Util.verify(inputSize + 1 &lt;= size, input, NOT_ENOUGH_INPUT_BYTES);</span>

<span class="fc" id="L94">      final long inputLimit = input + inputSize;</span>
<span class="fc" id="L95">      input += reader.readFseTable(fseTable, inputBase, input, inputLimit,</span>
                                   FiniteStateEntropy.MAX_SYMBOL,
                                   MAX_FSE_TABLE_LOG);
<span class="fc" id="L98">      outputSize =</span>
<span class="fc" id="L99">          FiniteStateEntropy.decompress(fseTable, inputBase, input, inputLimit,</span>
                                        weights);
    }

<span class="fc" id="L103">    int totalWeight = 0;</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">    for (int i = 0; i &lt; outputSize; i++) {</span>
<span class="fc" id="L105">      ranks[weights[i]]++;</span>
<span class="fc" id="L106">      totalWeight +=</span>
          (1 &lt;&lt; weights[i]) &gt;&gt; 1;   // TODO same as 1 &lt;&lt; (weights[n] - 1)?
    }
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">    Util.verify(totalWeight != 0, input, INPUT_IS_CORRUPTED);</span>

<span class="fc" id="L111">    tableLog = Util.highestBit(totalWeight) + 1;</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">    Util.verify(tableLog &lt;= MAX_TABLE_LOG, input, INPUT_IS_CORRUPTED);</span>

<span class="fc" id="L114">    final int total = 1 &lt;&lt; tableLog;</span>
<span class="fc" id="L115">    final int rest = total - totalWeight;</span>
<span class="fc" id="L116">    Util.verify(Util.isPowerOf2(rest), input, INPUT_IS_CORRUPTED);</span>

<span class="fc" id="L118">    final int lastWeight = Util.highestBit(rest) + 1;</span>

<span class="fc" id="L120">    weights[outputSize] = (byte) lastWeight;</span>
<span class="fc" id="L121">    ranks[lastWeight]++;</span>

<span class="fc" id="L123">    final int numberOfSymbols = outputSize + 1;</span>

    // populate table
<span class="fc" id="L126">    int nextRankStart = 0;</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">    for (int i = 1; i &lt; tableLog + 1; ++i) {</span>
<span class="fc" id="L128">      final int current = nextRankStart;</span>
<span class="fc" id="L129">      nextRankStart += ranks[i] &lt;&lt; (i - 1);</span>
<span class="fc" id="L130">      ranks[i] = current;</span>
    }

<span class="fc bfc" id="L133" title="All 2 branches covered.">    for (int n = 0; n &lt; numberOfSymbols; n++) {</span>
<span class="fc" id="L134">      final int weight = weights[n];</span>
<span class="fc" id="L135">      final int length = (1 &lt;&lt; weight) &gt;&gt; 1;  // TODO: 1 &lt;&lt; (weight - 1) ??</span>

<span class="fc" id="L137">      final byte symbol = (byte) n;</span>
<span class="fc" id="L138">      final byte numberOfBits = (byte) (tableLog + 1 - weight);</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">      for (int i = ranks[weight]; i &lt; ranks[weight] + length; i++) {</span>
<span class="fc" id="L140">        symbols[i] = symbol;</span>
<span class="fc" id="L141">        numbersOfBits[i] = numberOfBits;</span>
      }
<span class="fc" id="L143">      ranks[weight] += length;</span>
    }

<span class="pc bpc" id="L146" title="2 of 4 branches missed.">    Util.verify(ranks[1] &gt;= 2 &amp;&amp; (ranks[1] &amp; 1) == 0, input,</span>
                INPUT_IS_CORRUPTED);

<span class="fc" id="L149">    return inputSize + 1;</span>
  }

  public void decodeSingleStream(final Object inputBase,
                                 final long inputAddress, final long inputLimit,
                                 final Object outputBase,
                                 final long outputAddress,
                                 final long outputLimit) {
<span class="nc" id="L157">    final BitInputStream.Initializer initializer =</span>
        new BitInputStream.Initializer(inputBase, inputAddress, inputLimit);
<span class="nc" id="L159">    initializer.initialize();</span>

<span class="nc" id="L161">    long bits = initializer.getBits();</span>
<span class="nc" id="L162">    int bitsConsumed = initializer.getBitsConsumed();</span>
<span class="nc" id="L163">    long currentAddress = initializer.getCurrentAddress();</span>

<span class="nc" id="L165">    final int tableLog1 = this.tableLog;</span>
<span class="nc" id="L166">    final byte[] numbersOfBits1 = this.numbersOfBits;</span>
<span class="nc" id="L167">    final byte[] symbols1 = this.symbols;</span>

    // 4 symbols at a time
<span class="nc" id="L170">    long output = outputAddress;</span>
<span class="nc" id="L171">    final long fastOutputLimit = outputLimit - 4;</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">    while (output &lt; fastOutputLimit) {</span>
<span class="nc" id="L173">      final BitInputStream.Loader loader =</span>
          new BitInputStream.Loader(inputBase, inputAddress, currentAddress,
                                    bits, bitsConsumed);
<span class="nc" id="L176">      final boolean done = loader.load();</span>
<span class="nc" id="L177">      bits = loader.getBits();</span>
<span class="nc" id="L178">      bitsConsumed = loader.getBitsConsumed();</span>
<span class="nc" id="L179">      currentAddress = loader.getCurrentAddress();</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">      if (done) {</span>
<span class="nc" id="L181">        break;</span>
      }

<span class="nc" id="L184">      bitsConsumed =</span>
<span class="nc" id="L185">          decodeSymbol(outputBase, output, bits, bitsConsumed, tableLog1,</span>
                       numbersOfBits1, symbols1);
<span class="nc" id="L187">      bitsConsumed =</span>
<span class="nc" id="L188">          decodeSymbol(outputBase, output + 1, bits, bitsConsumed, tableLog1,</span>
                       numbersOfBits1, symbols1);
<span class="nc" id="L190">      bitsConsumed =</span>
<span class="nc" id="L191">          decodeSymbol(outputBase, output + 2, bits, bitsConsumed, tableLog1,</span>
                       numbersOfBits1, symbols1);
<span class="nc" id="L193">      bitsConsumed =</span>
<span class="nc" id="L194">          decodeSymbol(outputBase, output + 3, bits, bitsConsumed, tableLog1,</span>
                       numbersOfBits1, symbols1);
<span class="nc" id="L196">      output += SIZE_OF_INT;</span>
<span class="nc" id="L197">    }</span>

<span class="nc" id="L199">    decodeTail(inputBase, inputAddress, currentAddress, bitsConsumed, bits,</span>
               outputBase, output, outputLimit);
<span class="nc" id="L201">  }</span>

  public void decode4Streams(final Object inputBase, final long inputAddress,
                             final long inputLimit, final Object outputBase,
                             final long outputAddress, final long outputLimit) {
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">    Util.verify(inputLimit - inputAddress &gt;= 10, inputAddress,</span>
                INPUT_IS_CORRUPTED); // jump table + 1 byte per stream

<span class="fc" id="L209">    final long start1 =</span>
        inputAddress + 3 * SIZE_OF_SHORT; // for the shorts we read below
<span class="fc" id="L211">    final long start2 =</span>
<span class="fc" id="L212">        start1 + (UnsafeUtil.UNSAFE.getShort(inputBase, inputAddress) &amp; 0xFFFF);</span>
<span class="fc" id="L213">    final long start3 = start2 + (UnsafeUtil.UNSAFE.getShort(inputBase,</span>
                                                             inputAddress + 2) &amp;
                                  0xFFFF);
<span class="fc" id="L216">    final long start4 = start3 + (UnsafeUtil.UNSAFE.getShort(inputBase,</span>
                                                             inputAddress + 4) &amp;
                                  0xFFFF);

<span class="fc" id="L220">    BitInputStream.Initializer initializer =</span>
        new BitInputStream.Initializer(inputBase, start1, start2);
<span class="fc" id="L222">    initializer.initialize();</span>
<span class="fc" id="L223">    int stream1bitsConsumed = initializer.getBitsConsumed();</span>
<span class="fc" id="L224">    long stream1currentAddress = initializer.getCurrentAddress();</span>
<span class="fc" id="L225">    long stream1bits = initializer.getBits();</span>

<span class="fc" id="L227">    initializer = new BitInputStream.Initializer(inputBase, start2, start3);</span>
<span class="fc" id="L228">    initializer.initialize();</span>
<span class="fc" id="L229">    int stream2bitsConsumed = initializer.getBitsConsumed();</span>
<span class="fc" id="L230">    long stream2currentAddress = initializer.getCurrentAddress();</span>
<span class="fc" id="L231">    long stream2bits = initializer.getBits();</span>

<span class="fc" id="L233">    initializer = new BitInputStream.Initializer(inputBase, start3, start4);</span>
<span class="fc" id="L234">    initializer.initialize();</span>
<span class="fc" id="L235">    int stream3bitsConsumed = initializer.getBitsConsumed();</span>
<span class="fc" id="L236">    long stream3currentAddress = initializer.getCurrentAddress();</span>
<span class="fc" id="L237">    long stream3bits = initializer.getBits();</span>

<span class="fc" id="L239">    initializer = new BitInputStream.Initializer(inputBase, start4, inputLimit);</span>
<span class="fc" id="L240">    initializer.initialize();</span>
<span class="fc" id="L241">    int stream4bitsConsumed = initializer.getBitsConsumed();</span>
<span class="fc" id="L242">    long stream4currentAddress = initializer.getCurrentAddress();</span>
<span class="fc" id="L243">    long stream4bits = initializer.getBits();</span>

<span class="fc" id="L245">    final int segmentSize = (int) ((outputLimit - outputAddress + 3) / 4);</span>

<span class="fc" id="L247">    final long outputStart2 = outputAddress + segmentSize;</span>
<span class="fc" id="L248">    final long outputStart3 = outputStart2 + segmentSize;</span>
<span class="fc" id="L249">    final long outputStart4 = outputStart3 + segmentSize;</span>

<span class="fc" id="L251">    long output1 = outputAddress;</span>
<span class="fc" id="L252">    long output2 = outputStart2;</span>
<span class="fc" id="L253">    long output3 = outputStart3;</span>
<span class="fc" id="L254">    long output4 = outputStart4;</span>

<span class="fc" id="L256">    final long fastOutputLimit = outputLimit - 7;</span>
<span class="fc" id="L257">    final int tableLog1 = this.tableLog;</span>
<span class="fc" id="L258">    final byte[] numbersOfBits1 = this.numbersOfBits;</span>
<span class="fc" id="L259">    final byte[] symbols1 = this.symbols;</span>

<span class="fc bfc" id="L261" title="All 2 branches covered.">    while (output4 &lt; fastOutputLimit) {</span>
<span class="fc" id="L262">      stream1bitsConsumed =</span>
<span class="fc" id="L263">          decodeSymbol(outputBase, output1, stream1bits, stream1bitsConsumed,</span>
                       tableLog1, numbersOfBits1, symbols1);
<span class="fc" id="L265">      stream2bitsConsumed =</span>
<span class="fc" id="L266">          decodeSymbol(outputBase, output2, stream2bits, stream2bitsConsumed,</span>
                       tableLog1, numbersOfBits1, symbols1);
<span class="fc" id="L268">      stream3bitsConsumed =</span>
<span class="fc" id="L269">          decodeSymbol(outputBase, output3, stream3bits, stream3bitsConsumed,</span>
                       tableLog1, numbersOfBits1, symbols1);
<span class="fc" id="L271">      stream4bitsConsumed =</span>
<span class="fc" id="L272">          decodeSymbol(outputBase, output4, stream4bits, stream4bitsConsumed,</span>
                       tableLog1, numbersOfBits1, symbols1);

<span class="fc" id="L275">      stream1bitsConsumed = decodeSymbol(outputBase, output1 + 1, stream1bits,</span>
                                         stream1bitsConsumed, tableLog1,
                                         numbersOfBits1, symbols1);
<span class="fc" id="L278">      stream2bitsConsumed = decodeSymbol(outputBase, output2 + 1, stream2bits,</span>
                                         stream2bitsConsumed, tableLog1,
                                         numbersOfBits1, symbols1);
<span class="fc" id="L281">      stream3bitsConsumed = decodeSymbol(outputBase, output3 + 1, stream3bits,</span>
                                         stream3bitsConsumed, tableLog1,
                                         numbersOfBits1, symbols1);
<span class="fc" id="L284">      stream4bitsConsumed = decodeSymbol(outputBase, output4 + 1, stream4bits,</span>
                                         stream4bitsConsumed, tableLog1,
                                         numbersOfBits1, symbols1);

<span class="fc" id="L288">      stream1bitsConsumed = decodeSymbol(outputBase, output1 + 2, stream1bits,</span>
                                         stream1bitsConsumed, tableLog1,
                                         numbersOfBits1, symbols1);
<span class="fc" id="L291">      stream2bitsConsumed = decodeSymbol(outputBase, output2 + 2, stream2bits,</span>
                                         stream2bitsConsumed, tableLog1,
                                         numbersOfBits1, symbols1);
<span class="fc" id="L294">      stream3bitsConsumed = decodeSymbol(outputBase, output3 + 2, stream3bits,</span>
                                         stream3bitsConsumed, tableLog1,
                                         numbersOfBits1, symbols1);
<span class="fc" id="L297">      stream4bitsConsumed = decodeSymbol(outputBase, output4 + 2, stream4bits,</span>
                                         stream4bitsConsumed, tableLog1,
                                         numbersOfBits1, symbols1);

<span class="fc" id="L301">      stream1bitsConsumed = decodeSymbol(outputBase, output1 + 3, stream1bits,</span>
                                         stream1bitsConsumed, tableLog1,
                                         numbersOfBits1, symbols1);
<span class="fc" id="L304">      stream2bitsConsumed = decodeSymbol(outputBase, output2 + 3, stream2bits,</span>
                                         stream2bitsConsumed, tableLog1,
                                         numbersOfBits1, symbols1);
<span class="fc" id="L307">      stream3bitsConsumed = decodeSymbol(outputBase, output3 + 3, stream3bits,</span>
                                         stream3bitsConsumed, tableLog1,
                                         numbersOfBits1, symbols1);
<span class="fc" id="L310">      stream4bitsConsumed = decodeSymbol(outputBase, output4 + 3, stream4bits,</span>
                                         stream4bitsConsumed, tableLog1,
                                         numbersOfBits1, symbols1);

<span class="fc" id="L314">      output1 += SIZE_OF_INT;</span>
<span class="fc" id="L315">      output2 += SIZE_OF_INT;</span>
<span class="fc" id="L316">      output3 += SIZE_OF_INT;</span>
<span class="fc" id="L317">      output4 += SIZE_OF_INT;</span>

<span class="fc" id="L319">      BitInputStream.Loader loader =</span>
          new BitInputStream.Loader(inputBase, start1, stream1currentAddress,
                                    stream1bits, stream1bitsConsumed);
<span class="fc" id="L322">      boolean done = loader.load();</span>
<span class="fc" id="L323">      stream1bitsConsumed = loader.getBitsConsumed();</span>
<span class="fc" id="L324">      stream1bits = loader.getBits();</span>
<span class="fc" id="L325">      stream1currentAddress = loader.getCurrentAddress();</span>

<span class="fc bfc" id="L327" title="All 2 branches covered.">      if (done) {</span>
<span class="fc" id="L328">        break;</span>
      }

<span class="fc" id="L331">      loader =</span>
          new BitInputStream.Loader(inputBase, start2, stream2currentAddress,
                                    stream2bits, stream2bitsConsumed);
<span class="fc" id="L334">      done = loader.load();</span>
<span class="fc" id="L335">      stream2bitsConsumed = loader.getBitsConsumed();</span>
<span class="fc" id="L336">      stream2bits = loader.getBits();</span>
<span class="fc" id="L337">      stream2currentAddress = loader.getCurrentAddress();</span>

<span class="fc bfc" id="L339" title="All 2 branches covered.">      if (done) {</span>
<span class="fc" id="L340">        break;</span>
      }

<span class="fc" id="L343">      loader =</span>
          new BitInputStream.Loader(inputBase, start3, stream3currentAddress,
                                    stream3bits, stream3bitsConsumed);
<span class="fc" id="L346">      done = loader.load();</span>
<span class="fc" id="L347">      stream3bitsConsumed = loader.getBitsConsumed();</span>
<span class="fc" id="L348">      stream3bits = loader.getBits();</span>
<span class="fc" id="L349">      stream3currentAddress = loader.getCurrentAddress();</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">      if (done) {</span>
<span class="fc" id="L351">        break;</span>
      }

<span class="fc" id="L354">      loader =</span>
          new BitInputStream.Loader(inputBase, start4, stream4currentAddress,
                                    stream4bits, stream4bitsConsumed);
<span class="fc" id="L357">      done = loader.load();</span>
<span class="fc" id="L358">      stream4bitsConsumed = loader.getBitsConsumed();</span>
<span class="fc" id="L359">      stream4bits = loader.getBits();</span>
<span class="fc" id="L360">      stream4currentAddress = loader.getCurrentAddress();</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">      if (done) {</span>
<span class="fc" id="L362">        break;</span>
      }
<span class="fc" id="L364">    }</span>

<span class="pc bpc" id="L366" title="3 of 6 branches missed.">    Util.verify(output1 &lt;= outputStart2 &amp;&amp; output2 &lt;= outputStart3 &amp;&amp;</span>
                output3 &lt;= outputStart4, inputAddress, INPUT_IS_CORRUPTED);

    /// finish streams one by one
<span class="fc" id="L370">    decodeTail(inputBase, start1, stream1currentAddress, stream1bitsConsumed,</span>
               stream1bits, outputBase, output1, outputStart2);
<span class="fc" id="L372">    decodeTail(inputBase, start2, stream2currentAddress, stream2bitsConsumed,</span>
               stream2bits, outputBase, output2, outputStart3);
<span class="fc" id="L374">    decodeTail(inputBase, start3, stream3currentAddress, stream3bitsConsumed,</span>
               stream3bits, outputBase, output3, outputStart4);
<span class="fc" id="L376">    decodeTail(inputBase, start4, stream4currentAddress, stream4bitsConsumed,</span>
               stream4bits, outputBase, output4, outputLimit);
<span class="fc" id="L378">  }</span>

  private void decodeTail(final Object inputBase, final long startAddress,
                          long currentAddress, int bitsConsumed, long bits,
                          final Object outputBase, long outputAddress,
                          final long outputLimit) {
<span class="fc" id="L384">    final int tableLog1 = this.tableLog;</span>
<span class="fc" id="L385">    final byte[] numbersOfBits1 = this.numbersOfBits;</span>
<span class="fc" id="L386">    final byte[] symbols1 = this.symbols;</span>

    // closer to the end
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">    while (outputAddress &lt; outputLimit) {</span>
<span class="fc" id="L390">      final BitInputStream.Loader loader =</span>
          new BitInputStream.Loader(inputBase, startAddress, currentAddress,
                                    bits, bitsConsumed);
<span class="fc" id="L393">      final boolean done = loader.load();</span>
<span class="fc" id="L394">      bitsConsumed = loader.getBitsConsumed();</span>
<span class="fc" id="L395">      bits = loader.getBits();</span>
<span class="fc" id="L396">      currentAddress = loader.getCurrentAddress();</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">      if (done) {</span>
<span class="fc" id="L398">        break;</span>
      }

<span class="fc" id="L401">      bitsConsumed =</span>
<span class="fc" id="L402">          decodeSymbol(outputBase, outputAddress++, bits, bitsConsumed,</span>
                       tableLog1, numbersOfBits1, symbols1);
<span class="fc" id="L404">    }</span>

    // not more data in bit stream, so no need to reload
<span class="fc bfc" id="L407" title="All 2 branches covered.">    while (outputAddress &lt; outputLimit) {</span>
<span class="fc" id="L408">      bitsConsumed =</span>
<span class="fc" id="L409">          decodeSymbol(outputBase, outputAddress++, bits, bitsConsumed,</span>
                       tableLog1, numbersOfBits1, symbols1);
    }

<span class="fc" id="L413">    Util.verify(isEndOfStream(startAddress, currentAddress, bitsConsumed),</span>
                startAddress, &quot;Bit stream is not fully consumed&quot;);
<span class="fc" id="L415">  }</span>

  private static int decodeSymbol(final Object outputBase,
                                  final long outputAddress,
                                  final long bitContainer,
                                  final int bitsConsumed, final int tableLog,
                                  final byte[] numbersOfBits,
                                  final byte[] symbols) {
<span class="fc" id="L423">    final int value = (int) peekBitsFast(bitsConsumed, bitContainer, tableLog);</span>
<span class="fc" id="L424">    UnsafeUtil.UNSAFE.putByte(outputBase, outputAddress, symbols[value]);</span>
<span class="fc" id="L425">    return bitsConsumed + numbersOfBits[value];</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>