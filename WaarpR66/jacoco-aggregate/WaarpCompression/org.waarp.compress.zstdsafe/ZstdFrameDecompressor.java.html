<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ZstdFrameDecompressor.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp OpenR66</a> &gt; <a href="../index.html" class="el_bundle">WaarpCompression</a> &gt; <a href="index.source.html" class="el_package">org.waarp.compress.zstdsafe</a> &gt; <span class="el_source">ZstdFrameDecompressor.java</span></div><h1>ZstdFrameDecompressor.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.waarp.compress.zstdsafe;

import org.waarp.compress.MalformedInputException;

import java.util.Arrays;

import static org.waarp.compress.zstdsafe.BitInputStream.*;
import static org.waarp.compress.zstdsafe.Constants.*;
import static org.waarp.compress.zstdsafe.UnsafeUtil.*;
import static org.waarp.compress.zstdsafe.Util.*;

<span class="nc" id="L45">class ZstdFrameDecompressor {</span>
<span class="nc" id="L46">  private static final int[] DEC_32_TABLE = { 4, 1, 2, 1, 4, 4, 4, 4 };</span>
<span class="nc" id="L47">  private static final int[] DEC_64_TABLE = { 0, 0, 0, -1, 0, 1, 2, 3 };</span>

  private static final int V07_MAGIC_NUMBER = 0xFD2FB527;

  private static final int MAX_WINDOW_SIZE = 1 &lt;&lt; 23;

<span class="nc" id="L53">  private static final int[] LITERALS_LENGTH_BASE = {</span>
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 20, 22, 24,
      28, 32, 40, 48, 64, 0x80, 0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000,
      0x4000, 0x8000, 0x10000
  };

<span class="nc" id="L59">  private static final int[] MATCH_LENGTH_BASE = {</span>
      3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
      23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 37, 39, 41, 43, 47,
      51, 59, 67, 83, 99, 0x83, 0x103, 0x203, 0x403, 0x803, 0x1003, 0x2003,
      0x4003, 0x8003, 0x10003
  };

<span class="nc" id="L66">  private static final int[] OFFSET_CODES_BASE = {</span>
      0, 1, 1, 5, 0xD, 0x1D, 0x3D, 0x7D, 0xFD, 0x1FD, 0x3FD, 0x7FD, 0xFFD,
      0x1FFD, 0x3FFD, 0x7FFD, 0xFFFD, 0x1FFFD, 0x3FFFD, 0x7FFFD, 0xFFFFD,
      0x1FFFFD, 0x3FFFFD, 0x7FFFFD, 0xFFFFFD, 0x1FFFFFD, 0x3FFFFFD, 0x7FFFFFD,
      0xFFFFFFD
  };

<span class="nc" id="L73">  private static final FiniteStateEntropy.Table DEFAULT_LITERALS_LENGTH_TABLE =</span>
      new FiniteStateEntropy.Table(6, new int[] {
          0, 16, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0,
          32, 0, 0, 32, 0, 32, 0, 32, 0, 0, 32, 0, 32, 0, 32, 0, 0, 16, 32, 0,
          0, 48, 16, 32, 32, 32, 32, 32, 32, 32, 32, 0, 32, 32, 32, 32, 32, 32,
          0, 0, 0, 0
      }, new byte[] {
          0, 0, 1, 3, 4, 6, 7, 9, 10, 12, 14, 16, 18, 19, 21, 22, 24, 25, 26,
          27, 29, 31, 0, 1, 2, 4, 5, 7, 8, 10, 11, 13, 16, 17, 19, 20, 22, 23,
          25, 25, 26, 28, 30, 0, 1, 2, 3, 5, 6, 8, 9, 11, 12, 15, 17, 18, 20,
          21, 23, 24, 35, 34, 33, 32
      }, new byte[] {
          4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 4,
          4, 5, 5, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 5, 4, 4, 5, 6, 6, 4, 4, 5,
          5, 5, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6
      });

<span class="nc" id="L90">  private static final FiniteStateEntropy.Table DEFAULT_OFFSET_CODES_TABLE =</span>
      new FiniteStateEntropy.Table(5, new int[] {
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 16, 0, 0,
          0, 16, 0, 0, 0, 0, 0, 0, 0
      }, new byte[] {
          0, 6, 9, 15, 21, 3, 7, 12, 18, 23, 5, 8, 14, 20, 2, 7, 11, 17, 22, 4,
          8, 13, 19, 1, 6, 10, 16, 28, 27, 26, 25, 24
      }, new byte[] {
          5, 4, 5, 5, 5, 5, 4, 5, 5, 5, 5, 4, 5, 5, 5, 4, 5, 5, 5, 5, 4, 5, 5,
          5, 4, 5, 5, 5, 5, 5, 5, 5
      });

<span class="nc" id="L102">  private static final FiniteStateEntropy.Table DEFAULT_MATCH_LENGTH_TABLE =</span>
      new FiniteStateEntropy.Table(6, new int[] {
          0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16,
          0, 32, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 48,
          16, 32, 32, 32, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
      }, new byte[] {
          0, 1, 2, 3, 5, 6, 8, 10, 13, 16, 19, 22, 25, 28, 31, 33, 35, 37, 39,
          41, 43, 45, 1, 2, 3, 4, 6, 7, 9, 12, 15, 18, 21, 24, 27, 30, 32, 34,
          36, 38, 40, 42, 44, 1, 1, 2, 4, 5, 7, 8, 11, 14, 17, 20, 23, 26, 29,
          52, 51, 50, 49, 48, 47, 46
      }, new byte[] {
          6, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4,
          4, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 4, 4,
          5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6
      });
  public static final String NOT_ENOUGH_INPUT_BYTES = &quot;Not enough input bytes&quot;;
  public static final String OUTPUT_BUFFER_TOO_SMALL =
      &quot;Output buffer too small&quot;;
  public static final String EXPECTED_MATCH_LENGTH_TABLE_TO_BE_PRESENT =
      &quot;Expected match length table to be present&quot;;
  public static final String INPUT_IS_CORRUPTED = &quot;Input is corrupted&quot;;
  public static final String VALUE_EXCEEDS_EXPECTED_MAXIMUM_VALUE =
      &quot;Value exceeds expected maximum value&quot;;

<span class="nc" id="L126">  private final byte[] literals = new byte[MAX_BLOCK_SIZE + SIZE_OF_LONG];</span>
  // extra space to allow for long-at-a-time copy

  // current buffer containing literals
  private byte[] literalsBase;
  private int literalsAddress;
  private int literalsLimit;

<span class="nc" id="L134">  private final int[] previousOffsets = new int[3];</span>

<span class="nc" id="L136">  private final FiniteStateEntropy.Table literalsLengthTable =</span>
      new FiniteStateEntropy.Table(LITERAL_LENGTH_TABLE_LOG);
<span class="nc" id="L138">  private final FiniteStateEntropy.Table offsetCodesTable =</span>
      new FiniteStateEntropy.Table(OFFSET_TABLE_LOG);
<span class="nc" id="L140">  private final FiniteStateEntropy.Table matchLengthTable =</span>
      new FiniteStateEntropy.Table(MATCH_LENGTH_TABLE_LOG);

  private FiniteStateEntropy.Table currentLiteralsLengthTable;
  private FiniteStateEntropy.Table currentOffsetCodesTable;
  private FiniteStateEntropy.Table currentMatchLengthTable;

<span class="nc" id="L147">  private final Huffman huffman = new Huffman();</span>
<span class="nc" id="L148">  private final FseTableReader fse = new FseTableReader();</span>

  public int decompress(final byte[] inputBase, final int inputAddress,
                        final int inputLimit, final byte[] outputBase,
                        final int outputAddress, final int outputLimit) {
<span class="nc bnc" id="L153" title="All 2 branches missed.">    if (outputAddress == outputLimit) {</span>
<span class="nc" id="L154">      return 0;</span>
    }

<span class="nc" id="L157">    int input = inputAddress;</span>
<span class="nc" id="L158">    int output = outputAddress;</span>

<span class="nc bnc" id="L160" title="All 2 branches missed.">    while (input &lt; inputLimit) {</span>
<span class="nc" id="L161">      reset();</span>
<span class="nc" id="L162">      final int outputStart = output;</span>
<span class="nc" id="L163">      input += verifyMagic(inputBase, inputAddress, inputLimit);</span>

<span class="nc" id="L165">      final FrameHeader frameHeader =</span>
<span class="nc" id="L166">          readFrameHeader(inputBase, input, inputLimit);</span>
<span class="nc" id="L167">      input += frameHeader.headerSize;</span>

      boolean lastBlock;
      do {
<span class="nc bnc" id="L171" title="All 2 branches missed.">        verify(input + SIZE_OF_BLOCK_HEADER &lt;= inputLimit, input,</span>
               NOT_ENOUGH_INPUT_BYTES);

        // read block header
<span class="nc" id="L175">        final int header = getInt(inputBase, input) &amp; 0xFFFFFF;</span>
<span class="nc" id="L176">        input += SIZE_OF_BLOCK_HEADER;</span>

<span class="nc bnc" id="L178" title="All 2 branches missed.">        lastBlock = (header &amp; 1) != 0;</span>
<span class="nc" id="L179">        final int blockType = (header &gt;&gt;&gt; 1) &amp; 0x3;</span>
<span class="nc" id="L180">        final int blockSize = (header &gt;&gt;&gt; 3) &amp; 0x1FFFFF; // 21 bits</span>

        final int decodedSize;
<span class="nc bnc" id="L183" title="All 4 branches missed.">        switch (blockType) {</span>
          case RAW_BLOCK:
<span class="nc bnc" id="L185" title="All 2 branches missed.">            verify(inputAddress + blockSize &lt;= inputLimit, input,</span>
                   NOT_ENOUGH_INPUT_BYTES);
<span class="nc" id="L187">            decodedSize =</span>
<span class="nc" id="L188">                decodeRawBlock(inputBase, input, blockSize, outputBase, output,</span>
                               outputLimit);
<span class="nc" id="L190">            input += blockSize;</span>
<span class="nc" id="L191">            break;</span>
          case RLE_BLOCK:
<span class="nc bnc" id="L193" title="All 2 branches missed.">            verify(inputAddress + 1 &lt;= inputLimit, input,</span>
                   NOT_ENOUGH_INPUT_BYTES);
<span class="nc" id="L195">            decodedSize =</span>
<span class="nc" id="L196">                decodeRleBlock(blockSize, inputBase, input, outputBase, output,</span>
                               outputLimit);
<span class="nc" id="L198">            input += 1;</span>
<span class="nc" id="L199">            break;</span>
          case COMPRESSED_BLOCK:
<span class="nc bnc" id="L201" title="All 2 branches missed.">            verify(inputAddress + blockSize &lt;= inputLimit, input,</span>
                   NOT_ENOUGH_INPUT_BYTES);
<span class="nc" id="L203">            decodedSize =</span>
<span class="nc" id="L204">                decodeCompressedBlock(inputBase, input, blockSize, outputBase,</span>
                                      output, outputLimit,
                                      frameHeader.windowSize, outputAddress);
<span class="nc" id="L207">            input += blockSize;</span>
<span class="nc" id="L208">            break;</span>
          default:
<span class="nc" id="L210">            throw fail(input, &quot;Invalid block type&quot;);</span>
        }

<span class="nc" id="L213">        output += decodedSize;</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">      } while (!lastBlock);</span>

<span class="nc bnc" id="L216" title="All 2 branches missed.">      if (frameHeader.hasChecksum) {</span>
<span class="nc" id="L217">        final int decodedFrameSize = output - outputStart;</span>

<span class="nc" id="L219">        final long hash =</span>
<span class="nc" id="L220">            XxHash64.hash(0, outputBase, outputStart, decodedFrameSize);</span>

<span class="nc" id="L222">        final int checksum = getInt(inputBase, input);</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (checksum != (int) hash) {</span>
<span class="nc" id="L224">          throw new MalformedInputException(input, String.format(</span>
              &quot;Bad checksum. Expected: %s, actual: %s&quot;,
<span class="nc" id="L226">              Integer.toHexString(checksum), Integer.toHexString((int) hash)));</span>
        }

<span class="nc" id="L229">        input += SIZE_OF_INT;</span>
      }
<span class="nc" id="L231">    }</span>

<span class="nc" id="L233">    return output - outputAddress;</span>
  }

  private void reset() {
<span class="nc" id="L237">    previousOffsets[0] = 1;</span>
<span class="nc" id="L238">    previousOffsets[1] = 4;</span>
<span class="nc" id="L239">    previousOffsets[2] = 8;</span>

<span class="nc" id="L241">    currentLiteralsLengthTable = null;</span>
<span class="nc" id="L242">    currentOffsetCodesTable = null;</span>
<span class="nc" id="L243">    currentMatchLengthTable = null;</span>
<span class="nc" id="L244">  }</span>

  private static int decodeRawBlock(final byte[] inputBase,
                                    final int inputAddress, final int blockSize,
                                    final byte[] outputBase,
                                    final int outputAddress,
                                    final int outputLimit) {
<span class="nc bnc" id="L251" title="All 2 branches missed.">    verify(outputAddress + blockSize &lt;= outputLimit, inputAddress,</span>
           OUTPUT_BUFFER_TOO_SMALL);

<span class="nc" id="L254">    copyMemory(inputBase, inputAddress, outputBase, outputAddress, blockSize);</span>
<span class="nc" id="L255">    return blockSize;</span>
  }

  private static int decodeRleBlock(final int size, final byte[] inputBase,
                                    final int inputAddress,
                                    final byte[] outputBase,
                                    final int outputAddress,
                                    final int outputLimit) {
<span class="nc bnc" id="L263" title="All 2 branches missed.">    verify(outputAddress + size &lt;= outputLimit, inputAddress,</span>
           OUTPUT_BUFFER_TOO_SMALL);

<span class="nc" id="L266">    int output = outputAddress;</span>
<span class="nc" id="L267">    final long value = inputBase[inputAddress] &amp; 0xFFL;</span>

<span class="nc" id="L269">    int remaining = size;</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">    if (remaining &gt;= SIZE_OF_LONG) {</span>
<span class="nc" id="L271">      final long packed =</span>
          value | (value &lt;&lt; 8) | (value &lt;&lt; 16) | (value &lt;&lt; 24) | (value &lt;&lt; 32) |
          (value &lt;&lt; 40) | (value &lt;&lt; 48) | (value &lt;&lt; 56);

      do {
<span class="nc" id="L276">        putLong(outputBase, output, packed);</span>
<span class="nc" id="L277">        output += SIZE_OF_LONG;</span>
<span class="nc" id="L278">        remaining -= SIZE_OF_LONG;</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">      } while (remaining &gt;= SIZE_OF_LONG);</span>
    }

<span class="nc bnc" id="L282" title="All 2 branches missed.">    for (int i = 0; i &lt; remaining; i++) {</span>
<span class="nc" id="L283">      outputBase[output] = (byte) value;</span>
<span class="nc" id="L284">      output++;</span>
    }

<span class="nc" id="L287">    return size;</span>
  }

  private int decodeCompressedBlock(final byte[] inputBase,
                                    final int inputAddress, final int blockSize,
                                    final byte[] outputBase,
                                    final int outputAddress,
                                    final int outputLimit, final int windowSize,
                                    final int outputAbsoluteBaseAddress) {
<span class="nc" id="L296">    final int inputLimit = inputAddress + blockSize;</span>
<span class="nc" id="L297">    int input = inputAddress;</span>

<span class="nc bnc" id="L299" title="All 2 branches missed.">    verify(blockSize &lt;= MAX_BLOCK_SIZE, input,</span>
           EXPECTED_MATCH_LENGTH_TABLE_TO_BE_PRESENT);
<span class="nc bnc" id="L301" title="All 2 branches missed.">    verify(blockSize &gt;= MIN_BLOCK_SIZE, input,</span>
           &quot;Compressed block size too small&quot;);

    // decode literals
<span class="nc" id="L305">    final int literalsBlockType = inputBase[input] &amp; 0x3;</span>

<span class="nc bnc" id="L307" title="All 5 branches missed.">    switch (literalsBlockType) {</span>
      case RAW_LITERALS_BLOCK: {
<span class="nc" id="L309">        input += decodeRawLiterals(inputBase, input, inputLimit);</span>
<span class="nc" id="L310">        break;</span>
      }
      case RLE_LITERALS_BLOCK: {
<span class="nc" id="L313">        input += decodeRleLiterals(inputBase, input, blockSize);</span>
<span class="nc" id="L314">        break;</span>
      }
      case TREELESS_LITERALS_BLOCK:
<span class="nc" id="L317">        verify(huffman.isLoaded(), input, &quot;Dictionary is corrupted&quot;);</span>
      case COMPRESSED_LITERALS_BLOCK: {
<span class="nc" id="L319">        input += decodeCompressedLiterals(inputBase, input, blockSize,</span>
                                          literalsBlockType);
<span class="nc" id="L321">        break;</span>
      }
      default:
<span class="nc" id="L324">        throw fail(input, &quot;Invalid literals block encoding type&quot;);</span>
    }

<span class="nc bnc" id="L327" title="All 2 branches missed.">    verify(windowSize &lt;= MAX_WINDOW_SIZE, input,</span>
           &quot;Window size too large (not yet supported)&quot;);

<span class="nc" id="L330">    return decompressSequences(inputBase, input, inputAddress + blockSize,</span>
                               outputBase, outputAddress, outputLimit,
                               literalsBase, literalsAddress, literalsLimit,
                               outputAbsoluteBaseAddress);
  }

  private int decompressSequences(final byte[] inputBase,
                                  final int inputAddress, final int inputLimit,
                                  final byte[] outputBase,
                                  final int outputAddress,
                                  final int outputLimit,
                                  final byte[] literalsBase,
                                  final int literalsAddress,
                                  final int literalsLimit,
                                  final int outputAbsoluteBaseAddress) {
<span class="nc" id="L345">    final int fastOutputLimit = outputLimit - SIZE_OF_LONG;</span>
<span class="nc" id="L346">    final int fastMatchOutputLimit = fastOutputLimit - SIZE_OF_LONG;</span>

<span class="nc" id="L348">    int input = inputAddress;</span>
<span class="nc" id="L349">    int output = outputAddress;</span>

<span class="nc" id="L351">    int literalsInput = literalsAddress;</span>

<span class="nc" id="L353">    final int size = inputLimit - inputAddress;</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">    verify(size &gt;= MIN_SEQUENCES_SIZE, input, NOT_ENOUGH_INPUT_BYTES);</span>

    // decode header
<span class="nc" id="L357">    int sequenceCount = inputBase[input++] &amp; 0xFF;</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">    if (sequenceCount != 0) {</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">      if (sequenceCount == 255) {</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">        verify(input + SIZE_OF_SHORT &lt;= inputLimit, input,</span>
               NOT_ENOUGH_INPUT_BYTES);
<span class="nc" id="L362">        sequenceCount =</span>
<span class="nc" id="L363">            (getShort(inputBase, input) &amp; 0xFFFF) + LONG_NUMBER_OF_SEQUENCES;</span>
<span class="nc" id="L364">        input += SIZE_OF_SHORT;</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">      } else if (sequenceCount &gt; 127) {</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">        verify(input &lt; inputLimit, input, NOT_ENOUGH_INPUT_BYTES);</span>
<span class="nc" id="L367">        sequenceCount =</span>
            ((sequenceCount - 128) &lt;&lt; 8) + (inputBase[input++] &amp; 0xFF);
      }

<span class="nc bnc" id="L371" title="All 2 branches missed.">      verify(input + SIZE_OF_INT &lt;= inputLimit, input, NOT_ENOUGH_INPUT_BYTES);</span>

<span class="nc" id="L373">      final byte type = inputBase[input++];</span>

<span class="nc" id="L375">      final int literalsLengthType = (type &amp; 0xFF) &gt;&gt;&gt; 6;</span>
<span class="nc" id="L376">      final int offsetCodesType = (type &gt;&gt;&gt; 4) &amp; 0x3;</span>
<span class="nc" id="L377">      final int matchLengthType = (type &gt;&gt;&gt; 2) &amp; 0x3;</span>

<span class="nc" id="L379">      input = computeLiteralsTable(literalsLengthType, inputBase, input,</span>
                                   inputLimit);
<span class="nc" id="L381">      input =</span>
<span class="nc" id="L382">          computeOffsetsTable(offsetCodesType, inputBase, input, inputLimit);</span>
<span class="nc" id="L383">      input = computeMatchLengthTable(matchLengthType, inputBase, input,</span>
                                      inputLimit);

      // decompress sequences
<span class="nc" id="L387">      final BitInputStream.Initializer initializer =</span>
          new BitInputStream.Initializer(inputBase, input, inputLimit);
<span class="nc" id="L389">      initializer.initialize();</span>
<span class="nc" id="L390">      int bitsConsumed = initializer.getBitsConsumed();</span>
<span class="nc" id="L391">      long bits = initializer.getBits();</span>
<span class="nc" id="L392">      int currentAddress = initializer.getCurrentAddress();</span>

<span class="nc" id="L394">      final FiniteStateEntropy.Table currentLiteralsLengthTable1 =</span>
          this.currentLiteralsLengthTable;
<span class="nc" id="L396">      final FiniteStateEntropy.Table currentOffsetCodesTable1 =</span>
          this.currentOffsetCodesTable;
<span class="nc" id="L398">      final FiniteStateEntropy.Table currentMatchLengthTable1 =</span>
          this.currentMatchLengthTable;

<span class="nc" id="L401">      int literalsLengthState = (int) peekBits(bitsConsumed, bits,</span>
                                               currentLiteralsLengthTable1.log2Size);
<span class="nc" id="L403">      bitsConsumed += currentLiteralsLengthTable1.log2Size;</span>

<span class="nc" id="L405">      int offsetCodesState =</span>
<span class="nc" id="L406">          (int) peekBits(bitsConsumed, bits, currentOffsetCodesTable1.log2Size);</span>
<span class="nc" id="L407">      bitsConsumed += currentOffsetCodesTable1.log2Size;</span>

<span class="nc" id="L409">      int matchLengthState =</span>
<span class="nc" id="L410">          (int) peekBits(bitsConsumed, bits, currentMatchLengthTable1.log2Size);</span>
<span class="nc" id="L411">      bitsConsumed += currentMatchLengthTable1.log2Size;</span>

<span class="nc" id="L413">      final int[] previousOffsets1 = this.previousOffsets;</span>

<span class="nc" id="L415">      final byte[] literalsLengthNumbersOfBits =</span>
          currentLiteralsLengthTable1.numberOfBits;
<span class="nc" id="L417">      final int[] literalsLengthNewStates =</span>
          currentLiteralsLengthTable1.newState;
<span class="nc" id="L419">      final byte[] literalsLengthSymbols = currentLiteralsLengthTable1.symbol;</span>

<span class="nc" id="L421">      final byte[] matchLengthNumbersOfBits =</span>
          currentMatchLengthTable1.numberOfBits;
<span class="nc" id="L423">      final int[] matchLengthNewStates = currentMatchLengthTable1.newState;</span>
<span class="nc" id="L424">      final byte[] matchLengthSymbols = currentMatchLengthTable1.symbol;</span>

<span class="nc" id="L426">      final byte[] offsetCodesNumbersOfBits =</span>
          currentOffsetCodesTable1.numberOfBits;
<span class="nc" id="L428">      final int[] offsetCodesNewStates = currentOffsetCodesTable1.newState;</span>
<span class="nc" id="L429">      final byte[] offsetCodesSymbols = currentOffsetCodesTable1.symbol;</span>

<span class="nc bnc" id="L431" title="All 2 branches missed.">      while (sequenceCount &gt; 0) {</span>
<span class="nc" id="L432">        sequenceCount--;</span>

<span class="nc" id="L434">        final BitInputStream.Loader loader =</span>
            new BitInputStream.Loader(inputBase, input, currentAddress, bits,
                                      bitsConsumed);
<span class="nc" id="L437">        loader.load();</span>
<span class="nc" id="L438">        bitsConsumed = loader.getBitsConsumed();</span>
<span class="nc" id="L439">        bits = loader.getBits();</span>
<span class="nc" id="L440">        currentAddress = loader.getCurrentAddress();</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">        if (loader.isOverflow()) {</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">          verify(sequenceCount == 0, input, &quot;Not all sequences were consumed&quot;);</span>
<span class="nc" id="L443">          break;</span>
        }

        // decode sequence
<span class="nc" id="L447">        final int literalsLengthCode =</span>
            literalsLengthSymbols[literalsLengthState];
<span class="nc" id="L449">        final int matchLengthCode = matchLengthSymbols[matchLengthState];</span>
<span class="nc" id="L450">        final int offsetCode = offsetCodesSymbols[offsetCodesState];</span>

<span class="nc" id="L452">        final int literalsLengthBits = LITERALS_LENGTH_BITS[literalsLengthCode];</span>
<span class="nc" id="L453">        final int matchLengthBits = MATCH_LENGTH_BITS[matchLengthCode];</span>

<span class="nc" id="L455">        int offset = OFFSET_CODES_BASE[offsetCode];</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">        if (offsetCode &gt; 0) {</span>
<span class="nc" id="L457">          offset += peekBits(bitsConsumed, bits, offsetCode);</span>
<span class="nc" id="L458">          bitsConsumed += offsetCode;</span>
        }

<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (offsetCode &lt;= 1) {</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">          if (literalsLengthCode == 0) {</span>
<span class="nc" id="L463">            offset++;</span>
          }

<span class="nc bnc" id="L466" title="All 2 branches missed.">          if (offset != 0) {</span>
            int temp;
<span class="nc bnc" id="L468" title="All 2 branches missed.">            if (offset == 3) {</span>
<span class="nc" id="L469">              temp = previousOffsets1[0] - 1;</span>
            } else {
<span class="nc" id="L471">              temp = previousOffsets1[offset];</span>
            }

<span class="nc bnc" id="L474" title="All 2 branches missed.">            if (temp == 0) {</span>
<span class="nc" id="L475">              temp = 1;</span>
            }

<span class="nc bnc" id="L478" title="All 2 branches missed.">            if (offset != 1) {</span>
<span class="nc" id="L479">              previousOffsets1[2] = previousOffsets1[1];</span>
            }
<span class="nc" id="L481">            previousOffsets1[1] = previousOffsets1[0];</span>
<span class="nc" id="L482">            previousOffsets1[0] = temp;</span>

<span class="nc" id="L484">            offset = temp;</span>
<span class="nc" id="L485">          } else {</span>
<span class="nc" id="L486">            offset = previousOffsets1[0];</span>
          }
        } else {
<span class="nc" id="L489">          previousOffsets1[2] = previousOffsets1[1];</span>
<span class="nc" id="L490">          previousOffsets1[1] = previousOffsets1[0];</span>
<span class="nc" id="L491">          previousOffsets1[0] = offset;</span>
        }

<span class="nc" id="L494">        int matchLength = MATCH_LENGTH_BASE[matchLengthCode];</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">        if (matchLengthCode &gt; 31) {</span>
<span class="nc" id="L496">          matchLength += peekBits(bitsConsumed, bits, matchLengthBits);</span>
<span class="nc" id="L497">          bitsConsumed += matchLengthBits;</span>
        }

<span class="nc" id="L500">        int literalsLength = LITERALS_LENGTH_BASE[literalsLengthCode];</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">        if (literalsLengthCode &gt; 15) {</span>
<span class="nc" id="L502">          literalsLength += peekBits(bitsConsumed, bits, literalsLengthBits);</span>
<span class="nc" id="L503">          bitsConsumed += literalsLengthBits;</span>
        }

<span class="nc" id="L506">        final int totalBits = literalsLengthBits + matchLengthBits + offsetCode;</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">        if (totalBits &gt; 64 - 7 -</span>
                        (LITERAL_LENGTH_TABLE_LOG + MATCH_LENGTH_TABLE_LOG +
                         OFFSET_TABLE_LOG)) {
<span class="nc" id="L510">          final BitInputStream.Loader loader1 =</span>
              new BitInputStream.Loader(inputBase, input, currentAddress, bits,
                                        bitsConsumed);
<span class="nc" id="L513">          loader1.load();</span>

<span class="nc" id="L515">          bitsConsumed = loader1.getBitsConsumed();</span>
<span class="nc" id="L516">          bits = loader1.getBits();</span>
<span class="nc" id="L517">          currentAddress = loader1.getCurrentAddress();</span>
        }

        int numberOfBits;

<span class="nc" id="L522">        numberOfBits = literalsLengthNumbersOfBits[literalsLengthState];</span>
<span class="nc" id="L523">        literalsLengthState =</span>
            (int) (literalsLengthNewStates[literalsLengthState] +
<span class="nc" id="L525">                   peekBits(bitsConsumed, bits, numberOfBits)); // &lt;= 9 bits</span>
<span class="nc" id="L526">        bitsConsumed += numberOfBits;</span>

<span class="nc" id="L528">        numberOfBits = matchLengthNumbersOfBits[matchLengthState];</span>
<span class="nc" id="L529">        matchLengthState = (int) (matchLengthNewStates[matchLengthState] +</span>
<span class="nc" id="L530">                                  peekBits(bitsConsumed, bits,</span>
                                           numberOfBits)); // &lt;= 9 bits
<span class="nc" id="L532">        bitsConsumed += numberOfBits;</span>

<span class="nc" id="L534">        numberOfBits = offsetCodesNumbersOfBits[offsetCodesState];</span>
<span class="nc" id="L535">        offsetCodesState = (int) (offsetCodesNewStates[offsetCodesState] +</span>
<span class="nc" id="L536">                                  peekBits(bitsConsumed, bits,</span>
                                           numberOfBits)); // &lt;= 8 bits
<span class="nc" id="L538">        bitsConsumed += numberOfBits;</span>

<span class="nc" id="L540">        final int literalOutputLimit = output + literalsLength;</span>
<span class="nc" id="L541">        final int matchOutputLimit = literalOutputLimit + matchLength;</span>

<span class="nc bnc" id="L543" title="All 2 branches missed.">        verify(matchOutputLimit &lt;= outputLimit, input, OUTPUT_BUFFER_TOO_SMALL);</span>
<span class="nc" id="L544">        final int literalEnd = literalsInput + literalsLength;</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">        verify(literalEnd &lt;= literalsLimit, input, INPUT_IS_CORRUPTED);</span>

<span class="nc" id="L547">        final int matchAddress = literalOutputLimit - offset;</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">        verify(matchAddress &gt;= outputAbsoluteBaseAddress, input,</span>
               INPUT_IS_CORRUPTED);

<span class="nc bnc" id="L551" title="All 2 branches missed.">        if (literalOutputLimit &gt; fastOutputLimit) {</span>
<span class="nc" id="L552">          executeLastSequence(outputBase, output, literalOutputLimit,</span>
                              matchOutputLimit, fastOutputLimit, literalsInput,
                              matchAddress);
        } else {
          // copy literals. literalOutputLimit &lt;= fastOutputLimit, so we can copy
          // long at a time with over-copy
<span class="nc" id="L558">          output = copyLiterals(outputBase, literalsBase, output, literalsInput,</span>
                                literalOutputLimit);
<span class="nc" id="L560">          copyMatch(outputBase, fastOutputLimit, output, offset,</span>
                    matchOutputLimit, matchAddress, matchLength,
                    fastMatchOutputLimit);
        }
<span class="nc" id="L564">        output = matchOutputLimit;</span>
<span class="nc" id="L565">        literalsInput = literalEnd;</span>
<span class="nc" id="L566">      }</span>
    }

    // last literal segment
<span class="nc" id="L570">    output = copyLastLiteral(outputBase, literalsBase, literalsLimit, output,</span>
                             literalsInput);

<span class="nc" id="L573">    return output - outputAddress;</span>
  }

  private int copyLastLiteral(final byte[] outputBase,
                              final byte[] literalsBase,
                              final int literalsLimit, int output,
                              final int literalsInput) {
<span class="nc" id="L580">    final int lastLiteralsSize = literalsLimit - literalsInput;</span>
<span class="nc" id="L581">    copyMemory(literalsBase, literalsInput, outputBase, output,</span>
               lastLiteralsSize);
<span class="nc" id="L583">    output += lastLiteralsSize;</span>
<span class="nc" id="L584">    return output;</span>
  }

  private void copyMatch(final byte[] outputBase, final int fastOutputLimit,
                         int output, final int offset,
                         final int matchOutputLimit, int matchAddress,
                         int matchLength, final int fastMatchOutputLimit) {
<span class="nc" id="L591">    matchAddress = copyMatchHead(outputBase, output, offset, matchAddress);</span>
<span class="nc" id="L592">    output += SIZE_OF_LONG;</span>
<span class="nc" id="L593">    matchLength -= SIZE_OF_LONG; // first 8 bytes copied above</span>

<span class="nc" id="L595">    copyMatchTail(outputBase, fastOutputLimit, output, matchOutputLimit,</span>
                  matchAddress, matchLength, fastMatchOutputLimit);
<span class="nc" id="L597">  }</span>

  private void copyMatchTail(final byte[] outputBase, final int fastOutputLimit,
                             int output, final int matchOutputLimit,
                             int matchAddress, final int matchLength,
                             final int fastMatchOutputLimit) {
    // fastMatchOutputLimit is just fastOutputLimit - SIZE_OF_LONG. It needs to be passed in so that it can be computed once for the
    // whole invocation to decompressSequences. Otherwise, we'd just compute it here.
    // If matchOutputLimit is &lt; fastMatchOutputLimit, we know that even after the head (8 bytes) has been copied, the output pointer
    // will be within fastOutputLimit, so it's safe to copy blindly before checking the limit condition
<span class="nc bnc" id="L607" title="All 2 branches missed.">    if (matchOutputLimit &lt; fastMatchOutputLimit) {</span>
<span class="nc" id="L608">      int copied = 0;</span>
      do {
<span class="nc" id="L610">        putLong(outputBase, output, getLong(outputBase, matchAddress));</span>
<span class="nc" id="L611">        output += SIZE_OF_LONG;</span>
<span class="nc" id="L612">        matchAddress += SIZE_OF_LONG;</span>
<span class="nc" id="L613">        copied += SIZE_OF_LONG;</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">      } while (copied &lt; matchLength);</span>
<span class="nc" id="L615">    } else {</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">      while (output &lt; fastOutputLimit) {</span>
<span class="nc" id="L617">        putLong(outputBase, output, getLong(outputBase, matchAddress));</span>
<span class="nc" id="L618">        matchAddress += SIZE_OF_LONG;</span>
<span class="nc" id="L619">        output += SIZE_OF_LONG;</span>
      }

<span class="nc bnc" id="L622" title="All 2 branches missed.">      while (output &lt; matchOutputLimit) {</span>
<span class="nc" id="L623">        outputBase[output++] = outputBase[matchAddress++];</span>
      }
    }
<span class="nc" id="L626">  }</span>

  private int copyMatchHead(final byte[] outputBase, final int output,
                            final int offset, int matchAddress) {
    // copy match
<span class="nc bnc" id="L631" title="All 2 branches missed.">    if (offset &lt; 8) {</span>
      // 8 bytes apart so that we can copy long-at-a-time below
<span class="nc" id="L633">      final int increment32 = DEC_32_TABLE[offset];</span>
<span class="nc" id="L634">      final int decrement64 = DEC_64_TABLE[offset];</span>

<span class="nc" id="L636">      outputBase[output] = outputBase[matchAddress];</span>
<span class="nc" id="L637">      outputBase[output + 1] = outputBase[matchAddress + 1];</span>
<span class="nc" id="L638">      outputBase[output + 2] = outputBase[matchAddress + 2];</span>
<span class="nc" id="L639">      outputBase[output + 3] = outputBase[matchAddress + 3];</span>
<span class="nc" id="L640">      matchAddress += increment32;</span>

<span class="nc" id="L642">      putInt(outputBase, output + 4, getInt(outputBase, matchAddress));</span>
<span class="nc" id="L643">      matchAddress -= decrement64;</span>
<span class="nc" id="L644">    } else {</span>
<span class="nc" id="L645">      putLong(outputBase, output, getLong(outputBase, matchAddress));</span>
<span class="nc" id="L646">      matchAddress += SIZE_OF_LONG;</span>
    }
<span class="nc" id="L648">    return matchAddress;</span>
  }

  private int copyLiterals(final byte[] outputBase, final byte[] literalsBase,
                           int output, final int literalsInput,
                           final int literalOutputLimit) {
<span class="nc" id="L654">    int literalInput = literalsInput;</span>
    do {
<span class="nc" id="L656">      putLong(outputBase, output, getLong(literalsBase, literalInput));</span>
<span class="nc" id="L657">      output += SIZE_OF_LONG;</span>
<span class="nc" id="L658">      literalInput += SIZE_OF_LONG;</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">    } while (output &lt; literalOutputLimit);</span>
<span class="nc" id="L660">    output = literalOutputLimit; // correction in case we over-copied</span>
<span class="nc" id="L661">    return output;</span>
  }

  private int computeMatchLengthTable(final int matchLengthType,
                                      final byte[] inputBase, int input,
                                      final int inputLimit) {
<span class="nc bnc" id="L667" title="All 5 branches missed.">    switch (matchLengthType) {</span>
      case SEQUENCE_ENCODING_RLE:
<span class="nc bnc" id="L669" title="All 2 branches missed.">        verify(input &lt; inputLimit, input, NOT_ENOUGH_INPUT_BYTES);</span>

<span class="nc" id="L671">        final byte value = inputBase[input++];</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">        verify(value &lt;= MAX_MATCH_LENGTH_SYMBOL, input,</span>
               VALUE_EXCEEDS_EXPECTED_MAXIMUM_VALUE);

<span class="nc" id="L675">        FseTableReader.initializeRleTable(matchLengthTable, value);</span>
<span class="nc" id="L676">        currentMatchLengthTable = matchLengthTable;</span>
<span class="nc" id="L677">        break;</span>
      case SEQUENCE_ENCODING_BASIC:
<span class="nc" id="L679">        currentMatchLengthTable = DEFAULT_MATCH_LENGTH_TABLE;</span>
<span class="nc" id="L680">        break;</span>
      case SEQUENCE_ENCODING_REPEAT:
<span class="nc bnc" id="L682" title="All 2 branches missed.">        verify(currentMatchLengthTable != null, input,</span>
               EXPECTED_MATCH_LENGTH_TABLE_TO_BE_PRESENT);
<span class="nc" id="L684">        break;</span>
      case SEQUENCE_ENCODING_COMPRESSED:
<span class="nc" id="L686">        input +=</span>
<span class="nc" id="L687">            fse.readFseTable(matchLengthTable, inputBase, input, inputLimit,</span>
                             MAX_MATCH_LENGTH_SYMBOL, MATCH_LENGTH_TABLE_LOG);
<span class="nc" id="L689">        currentMatchLengthTable = matchLengthTable;</span>
<span class="nc" id="L690">        break;</span>
      default:
<span class="nc" id="L692">        throw fail(input, &quot;Invalid match length encoding type&quot;);</span>
    }
<span class="nc" id="L694">    return input;</span>
  }

  private int computeOffsetsTable(final int offsetCodesType,
                                  final byte[] inputBase, int input,
                                  final int inputLimit) {
<span class="nc bnc" id="L700" title="All 5 branches missed.">    switch (offsetCodesType) {</span>
      case SEQUENCE_ENCODING_RLE:
<span class="nc bnc" id="L702" title="All 2 branches missed.">        verify(input &lt; inputLimit, input, NOT_ENOUGH_INPUT_BYTES);</span>

<span class="nc" id="L704">        final byte value = inputBase[input++];</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">        verify(value &lt;= DEFAULT_MAX_OFFSET_CODE_SYMBOL, input,</span>
               VALUE_EXCEEDS_EXPECTED_MAXIMUM_VALUE);

<span class="nc" id="L708">        FseTableReader.initializeRleTable(offsetCodesTable, value);</span>
<span class="nc" id="L709">        currentOffsetCodesTable = offsetCodesTable;</span>
<span class="nc" id="L710">        break;</span>
      case SEQUENCE_ENCODING_BASIC:
<span class="nc" id="L712">        currentOffsetCodesTable = DEFAULT_OFFSET_CODES_TABLE;</span>
<span class="nc" id="L713">        break;</span>
      case SEQUENCE_ENCODING_REPEAT:
<span class="nc bnc" id="L715" title="All 2 branches missed.">        verify(currentOffsetCodesTable != null, input,</span>
               EXPECTED_MATCH_LENGTH_TABLE_TO_BE_PRESENT);
<span class="nc" id="L717">        break;</span>
      case SEQUENCE_ENCODING_COMPRESSED:
<span class="nc" id="L719">        input +=</span>
<span class="nc" id="L720">            fse.readFseTable(offsetCodesTable, inputBase, input, inputLimit,</span>
                             DEFAULT_MAX_OFFSET_CODE_SYMBOL, OFFSET_TABLE_LOG);
<span class="nc" id="L722">        currentOffsetCodesTable = offsetCodesTable;</span>
<span class="nc" id="L723">        break;</span>
      default:
<span class="nc" id="L725">        throw fail(input, &quot;Invalid offset code encoding type&quot;);</span>
    }
<span class="nc" id="L727">    return input;</span>
  }

  private int computeLiteralsTable(final int literalsLengthType,
                                   final byte[] inputBase, int input,
                                   final int inputLimit) {
<span class="nc bnc" id="L733" title="All 5 branches missed.">    switch (literalsLengthType) {</span>
      case SEQUENCE_ENCODING_RLE:
<span class="nc bnc" id="L735" title="All 2 branches missed.">        verify(input &lt; inputLimit, input, NOT_ENOUGH_INPUT_BYTES);</span>

<span class="nc" id="L737">        final byte value = inputBase[input++];</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">        verify(value &lt;= MAX_LITERALS_LENGTH_SYMBOL, input,</span>
               VALUE_EXCEEDS_EXPECTED_MAXIMUM_VALUE);

<span class="nc" id="L741">        FseTableReader.initializeRleTable(literalsLengthTable, value);</span>
<span class="nc" id="L742">        currentLiteralsLengthTable = literalsLengthTable;</span>
<span class="nc" id="L743">        break;</span>
      case SEQUENCE_ENCODING_BASIC:
<span class="nc" id="L745">        currentLiteralsLengthTable = DEFAULT_LITERALS_LENGTH_TABLE;</span>
<span class="nc" id="L746">        break;</span>
      case SEQUENCE_ENCODING_REPEAT:
<span class="nc bnc" id="L748" title="All 2 branches missed.">        verify(currentLiteralsLengthTable != null, input,</span>
               EXPECTED_MATCH_LENGTH_TABLE_TO_BE_PRESENT);
<span class="nc" id="L750">        break;</span>
      case SEQUENCE_ENCODING_COMPRESSED:
<span class="nc" id="L752">        input +=</span>
<span class="nc" id="L753">            fse.readFseTable(literalsLengthTable, inputBase, input, inputLimit,</span>
                             MAX_LITERALS_LENGTH_SYMBOL,
                             LITERAL_LENGTH_TABLE_LOG);
<span class="nc" id="L756">        currentLiteralsLengthTable = literalsLengthTable;</span>
<span class="nc" id="L757">        break;</span>
      default:
<span class="nc" id="L759">        throw fail(input, &quot;Invalid literals length encoding type&quot;);</span>
    }
<span class="nc" id="L761">    return input;</span>
  }

  private void executeLastSequence(final byte[] outputBase, int output,
                                   final int literalOutputLimit,
                                   final int matchOutputLimit,
                                   final int fastOutputLimit, int literalInput,
                                   int matchAddress) {
    // copy literals
<span class="nc bnc" id="L770" title="All 2 branches missed.">    if (output &lt; fastOutputLimit) {</span>
      // wild copy
      do {
<span class="nc" id="L773">        putLong(outputBase, output, getLong(literalsBase, literalInput));</span>
<span class="nc" id="L774">        output += SIZE_OF_LONG;</span>
<span class="nc" id="L775">        literalInput += SIZE_OF_LONG;</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">      } while (output &lt; fastOutputLimit);</span>

<span class="nc" id="L778">      literalInput -= output - fastOutputLimit;</span>
<span class="nc" id="L779">      output = fastOutputLimit;</span>
    }

<span class="nc bnc" id="L782" title="All 2 branches missed.">    while (output &lt; literalOutputLimit) {</span>
<span class="nc" id="L783">      outputBase[output] = literalsBase[literalInput];</span>
<span class="nc" id="L784">      output++;</span>
<span class="nc" id="L785">      literalInput++;</span>
    }

    // copy match
<span class="nc bnc" id="L789" title="All 2 branches missed.">    while (output &lt; matchOutputLimit) {</span>
<span class="nc" id="L790">      outputBase[output] = outputBase[matchAddress];</span>
<span class="nc" id="L791">      output++;</span>
<span class="nc" id="L792">      matchAddress++;</span>
    }
<span class="nc" id="L794">  }</span>

  private int decodeCompressedLiterals(final byte[] inputBase,
                                       final int inputAddress,
                                       final int blockSize,
                                       final int literalsBlockType) {
<span class="nc" id="L800">    int input = inputAddress;</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">    verify(blockSize &gt;= 5, input, NOT_ENOUGH_INPUT_BYTES);</span>

    // compressed
    final int compressedSize;
    final int uncompressedSize;
<span class="nc" id="L806">    boolean singleStream = false;</span>
    final int headerSize;
<span class="nc" id="L808">    final int type = (inputBase[input] &gt;&gt; 2) &amp; 0x3;</span>
<span class="nc bnc" id="L809" title="All 5 branches missed.">    switch (type) {</span>
      case 0:
<span class="nc" id="L811">        singleStream = true;</span>
      case 1: {
<span class="nc" id="L813">        final int header = getInt(inputBase, input);</span>

<span class="nc" id="L815">        headerSize = 3;</span>
<span class="nc" id="L816">        uncompressedSize = (header &gt;&gt;&gt; 4) &amp; mask(10);</span>
<span class="nc" id="L817">        compressedSize = (header &gt;&gt;&gt; 14) &amp; mask(10);</span>
<span class="nc" id="L818">        break;</span>
      }
      case 2: {
<span class="nc" id="L821">        final int header = getInt(inputBase, input);</span>

<span class="nc" id="L823">        headerSize = 4;</span>
<span class="nc" id="L824">        uncompressedSize = (header &gt;&gt;&gt; 4) &amp; mask(14);</span>
<span class="nc" id="L825">        compressedSize = (header &gt;&gt;&gt; 18) &amp; mask(14);</span>
<span class="nc" id="L826">        break;</span>
      }
      case 3: {
        // read 5 little-endian bytes
<span class="nc" id="L830">        final long header = inputBase[input] &amp; 0xFF |</span>
<span class="nc" id="L831">                            (getInt(inputBase, input + 1) &amp; 0xFFFFFFFFL) &lt;&lt; 8;</span>

<span class="nc" id="L833">        headerSize = 5;</span>
<span class="nc" id="L834">        uncompressedSize = (int) ((header &gt;&gt;&gt; 4) &amp; mask(18));</span>
<span class="nc" id="L835">        compressedSize = (int) ((header &gt;&gt;&gt; 22) &amp; mask(18));</span>
<span class="nc" id="L836">        break;</span>
      }
      default:
<span class="nc" id="L839">        throw fail(input, &quot;Invalid literals header size type&quot;);</span>
    }

<span class="nc bnc" id="L842" title="All 2 branches missed.">    verify(uncompressedSize &lt;= MAX_BLOCK_SIZE, input,</span>
           &quot;Block exceeds maximum size&quot;);
<span class="nc bnc" id="L844" title="All 2 branches missed.">    verify(headerSize + compressedSize &lt;= blockSize, input, INPUT_IS_CORRUPTED);</span>

<span class="nc" id="L846">    input += headerSize;</span>

<span class="nc" id="L848">    final int inputLimit = input + compressedSize;</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">    if (literalsBlockType != TREELESS_LITERALS_BLOCK) {</span>
<span class="nc" id="L850">      input += huffman.readTable(inputBase, input, compressedSize);</span>
    }

<span class="nc" id="L853">    literalsBase = literals;</span>
<span class="nc" id="L854">    literalsAddress = 0;</span>
<span class="nc" id="L855">    literalsLimit = uncompressedSize;</span>

<span class="nc bnc" id="L857" title="All 2 branches missed.">    if (singleStream) {</span>
<span class="nc" id="L858">      huffman.decodeSingleStream(inputBase, input, inputLimit, literals,</span>
                                 literalsAddress, literalsLimit);
    } else {
<span class="nc" id="L861">      huffman.decode4Streams(inputBase, input, inputLimit, literals,</span>
                             literalsAddress, literalsLimit);
    }

<span class="nc" id="L865">    return headerSize + compressedSize;</span>
  }

  private int decodeRleLiterals(final byte[] inputBase, final int inputAddress,
                                final int blockSize) {
<span class="nc" id="L870">    int input = inputAddress;</span>
    final int outputSize;

<span class="nc" id="L873">    final int type = (inputBase[input] &gt;&gt; 2) &amp; 0x3;</span>
<span class="nc bnc" id="L874" title="All 4 branches missed.">    switch (type) {</span>
      case 0:
      case 2:
<span class="nc" id="L877">        outputSize = (inputBase[input] &amp; 0xFF) &gt;&gt;&gt; 3;</span>
<span class="nc" id="L878">        input++;</span>
<span class="nc" id="L879">        break;</span>
      case 1:
<span class="nc" id="L881">        outputSize = (getShort(inputBase, input) &amp; 0xFFFF) &gt;&gt;&gt; 4;</span>
<span class="nc" id="L882">        input += 2;</span>
<span class="nc" id="L883">        break;</span>
      case 3:
        // we need at least 4 bytes (3 for the header, 1 for the payload)
<span class="nc bnc" id="L886" title="All 2 branches missed.">        verify(blockSize &gt;= SIZE_OF_INT, input, NOT_ENOUGH_INPUT_BYTES);</span>
<span class="nc" id="L887">        outputSize = (getInt(inputBase, input) &amp; 0xFFFFFF) &gt;&gt;&gt; 4;</span>
<span class="nc" id="L888">        input += 3;</span>
<span class="nc" id="L889">        break;</span>
      default:
<span class="nc" id="L891">        throw fail(input, &quot;Invalid RLE literals header encoding type&quot;);</span>
    }

<span class="nc bnc" id="L894" title="All 2 branches missed.">    verify(outputSize &lt;= MAX_BLOCK_SIZE, input,</span>
           &quot;Output exceeds maximum block size&quot;);

<span class="nc" id="L897">    final byte value = inputBase[input++];</span>
<span class="nc" id="L898">    Arrays.fill(literals, 0, outputSize + SIZE_OF_LONG, value);</span>

<span class="nc" id="L900">    literalsBase = literals;</span>
<span class="nc" id="L901">    literalsAddress = 0;</span>
<span class="nc" id="L902">    literalsLimit = outputSize;</span>

<span class="nc" id="L904">    return input - inputAddress;</span>
  }

  private int decodeRawLiterals(final byte[] inputBase, final int inputAddress,
                                final int inputLimit) {
<span class="nc" id="L909">    int input = inputAddress;</span>
<span class="nc" id="L910">    final int type = (inputBase[input] &gt;&gt; 2) &amp; 0x3;</span>

    final int literalSize;
<span class="nc bnc" id="L913" title="All 4 branches missed.">    switch (type) {</span>
      case 0:
      case 2:
<span class="nc" id="L916">        literalSize = (inputBase[input] &amp; 0xFF) &gt;&gt;&gt; 3;</span>
<span class="nc" id="L917">        input++;</span>
<span class="nc" id="L918">        break;</span>
      case 1:
<span class="nc" id="L920">        literalSize = (getShort(inputBase, input) &amp; 0xFFFF) &gt;&gt;&gt; 4;</span>
<span class="nc" id="L921">        input += 2;</span>
<span class="nc" id="L922">        break;</span>
      case 3:
        // read 3 little-endian bytes
<span class="nc" id="L925">        final int header = ((inputBase[input] &amp; 0xFF) |</span>
<span class="nc" id="L926">                            ((getShort(inputBase, input + 1) &amp; 0xFFFF) &lt;&lt; 8));</span>

<span class="nc" id="L928">        literalSize = header &gt;&gt;&gt; 4;</span>
<span class="nc" id="L929">        input += 3;</span>
<span class="nc" id="L930">        break;</span>
      default:
<span class="nc" id="L932">        throw fail(input, &quot;Invalid raw literals header encoding type&quot;);</span>
    }

<span class="nc bnc" id="L935" title="All 2 branches missed.">    verify(input + literalSize &lt;= inputLimit, input, NOT_ENOUGH_INPUT_BYTES);</span>

    // Set literals pointer to [input, literalSize], but only if we can copy 8 bytes at a time during sequence decoding
    // Otherwise, copy literals into buffer that's big enough to guarantee that
<span class="nc bnc" id="L939" title="All 2 branches missed.">    if (literalSize &gt; (inputLimit - input) - SIZE_OF_LONG) {</span>
<span class="nc" id="L940">      literalsBase = literals;</span>
<span class="nc" id="L941">      literalsAddress = 0;</span>
<span class="nc" id="L942">      literalsLimit = literalSize;</span>

<span class="nc" id="L944">      copyMemory(inputBase, input, literals, literalsAddress, literalSize);</span>
<span class="nc" id="L945">      Arrays.fill(literals, literalSize, literalSize + SIZE_OF_LONG, (byte) 0);</span>
    } else {
<span class="nc" id="L947">      literalsBase = inputBase;</span>
<span class="nc" id="L948">      literalsAddress = input;</span>
<span class="nc" id="L949">      literalsLimit = literalsAddress + literalSize;</span>
    }
<span class="nc" id="L951">    input += literalSize;</span>

<span class="nc" id="L953">    return input - inputAddress;</span>
  }

  static FrameHeader readFrameHeader(final byte[] inputBase,
                                     final int inputAddress,
                                     final int inputLimit) {
<span class="nc" id="L959">    int input = inputAddress;</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">    verify(input &lt; inputLimit, input, NOT_ENOUGH_INPUT_BYTES);</span>

<span class="nc" id="L962">    final int frameHeaderDescriptor = inputBase[input++] &amp; 0xFF;</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">    final boolean singleSegment = (frameHeaderDescriptor &amp; 0x20) != 0;</span>
<span class="nc" id="L964">    final int dictionaryDescriptor = frameHeaderDescriptor &amp; 0x3;</span>
<span class="nc" id="L965">    final int contentSizeDescriptor = frameHeaderDescriptor &gt;&gt;&gt; 6;</span>

<span class="nc bnc" id="L967" title="All 8 branches missed.">    final int headerSize = 1 + (singleSegment? 0 : 1) +</span>
                           (dictionaryDescriptor == 0? 0 :
                               (1 &lt;&lt; (dictionaryDescriptor - 1))) +
                           (contentSizeDescriptor == 0? (singleSegment? 1 : 0) :
                               (1 &lt;&lt; contentSizeDescriptor));

<span class="nc bnc" id="L973" title="All 2 branches missed.">    verify(headerSize &lt;= inputLimit - inputAddress, input,</span>
           NOT_ENOUGH_INPUT_BYTES);

    // decode window size
<span class="nc" id="L977">    int windowSize = -1;</span>
<span class="nc bnc" id="L978" title="All 2 branches missed.">    if (!singleSegment) {</span>
<span class="nc" id="L979">      final int windowDescriptor = inputBase[input++] &amp; 0xFF;</span>
<span class="nc" id="L980">      final int exponent = windowDescriptor &gt;&gt;&gt; 3;</span>
<span class="nc" id="L981">      final int mantissa = windowDescriptor &amp; 0x7;</span>

<span class="nc" id="L983">      final int base = 1 &lt;&lt; (MIN_WINDOW_LOG + exponent);</span>
<span class="nc" id="L984">      windowSize = base + (base / 8) * mantissa;</span>
    }

    // decode dictionary id
<span class="nc" id="L988">    int dictionaryId = -1;</span>
<span class="nc bnc" id="L989" title="All 4 branches missed.">    switch (dictionaryDescriptor) {</span>
      case 1:
<span class="nc" id="L991">        dictionaryId = inputBase[input] &amp; 0xFF;</span>
<span class="nc" id="L992">        input += SIZE_OF_BYTE;</span>
<span class="nc" id="L993">        break;</span>
      case 2:
<span class="nc" id="L995">        dictionaryId = getShort(inputBase, input) &amp; 0xFFFF;</span>
<span class="nc" id="L996">        input += SIZE_OF_SHORT;</span>
<span class="nc" id="L997">        break;</span>
      case 3:
<span class="nc" id="L999">        dictionaryId = getInt(inputBase, input);</span>
<span class="nc" id="L1000">        input += SIZE_OF_INT;</span>
        break;
    }
<span class="nc bnc" id="L1003" title="All 2 branches missed.">    verify(dictionaryId == -1, input, &quot;Custom dictionaries not supported&quot;);</span>

    // decode content size
<span class="nc" id="L1006">    int contentSize = -1;</span>
<span class="nc bnc" id="L1007" title="All 5 branches missed.">    switch (contentSizeDescriptor) {</span>
      case 0:
<span class="nc bnc" id="L1009" title="All 2 branches missed.">        if (singleSegment) {</span>
<span class="nc" id="L1010">          contentSize = inputBase[input] &amp; 0xFF;</span>
<span class="nc" id="L1011">          input += SIZE_OF_BYTE;</span>
        }
        break;
      case 1:
<span class="nc" id="L1015">        contentSize = getShort(inputBase, input) &amp; 0xFFFF;</span>
<span class="nc" id="L1016">        contentSize += 256;</span>
<span class="nc" id="L1017">        input += SIZE_OF_SHORT;</span>
<span class="nc" id="L1018">        break;</span>
      case 2:
<span class="nc" id="L1020">        contentSize = getInt(inputBase, input);</span>
<span class="nc" id="L1021">        input += SIZE_OF_INT;</span>
<span class="nc" id="L1022">        break;</span>
      case 3:
<span class="nc" id="L1024">        contentSize = (int) getLong(inputBase, input);</span>
<span class="nc" id="L1025">        input += SIZE_OF_LONG;</span>
        break;
    }

<span class="nc bnc" id="L1029" title="All 2 branches missed.">    final boolean hasChecksum = (frameHeaderDescriptor &amp; 0x4) != 0;</span>

<span class="nc" id="L1031">    return new FrameHeader(input - inputAddress, windowSize, contentSize,</span>
                           dictionaryId, hasChecksum);
  }

  public static int getDecompressedSize(final byte[] inputBase,
                                        final int inputAddress,
                                        final int inputLimit) {
<span class="nc" id="L1038">    int input = inputAddress;</span>
<span class="nc" id="L1039">    input += verifyMagic(inputBase, input, inputLimit);</span>
<span class="nc" id="L1040">    return readFrameHeader(inputBase, input, inputLimit).contentSize;</span>
  }

  static int verifyMagic(final byte[] inputBase, final int inputAddress,
                         final int inputLimit) {
<span class="nc bnc" id="L1045" title="All 2 branches missed.">    verify(inputLimit - inputAddress &gt;= 4, inputAddress,</span>
           NOT_ENOUGH_INPUT_BYTES);

<span class="nc" id="L1048">    final int magic = getInt(inputBase, inputAddress);</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">    if (magic != MAGIC_NUMBER) {</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">      if (magic == V07_MAGIC_NUMBER) {</span>
<span class="nc" id="L1051">        throw new MalformedInputException(inputAddress,</span>
                                          &quot;Data encoded in unsupported ZSTD v0.7 format&quot;);
      }
<span class="nc" id="L1054">      throw new MalformedInputException(inputAddress, &quot;Invalid magic prefix: &quot; +</span>
<span class="nc" id="L1055">                                                      Integer.toHexString(</span>
                                                          magic));
    }

<span class="nc" id="L1059">    return SIZE_OF_INT;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>