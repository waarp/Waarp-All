<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ServerActions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Waarp OpenR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.protocol.localhandler</a> &gt; <span class="el_source">ServerActions.java</span></div><h1>ServerActions.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.openr66.protocol.localhandler;

import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.waarp.common.command.exception.CommandAbstractException;
import org.waarp.common.database.DbPreparedStatement;
import org.waarp.common.database.DbSession;
import org.waarp.common.database.data.AbstractDbData;
import org.waarp.common.database.exception.WaarpDatabaseException;
import org.waarp.common.database.exception.WaarpDatabaseNoConnectionException;
import org.waarp.common.database.exception.WaarpDatabaseNoDataException;
import org.waarp.common.database.exception.WaarpDatabaseSqlException;
import org.waarp.common.exception.FileTransferException;
import org.waarp.common.file.DirInterface;
import org.waarp.common.file.FileUtils;
import org.waarp.common.json.JsonHandler;
import org.waarp.common.logging.SysErrLogger;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.role.RoleDefault.ROLE;
import org.waarp.common.utility.ParametersChecker;
import org.waarp.common.utility.WaarpShutdownHook;
import org.waarp.common.utility.WaarpStringUtils;
import org.waarp.openr66.client.AbstractTransfer;
import org.waarp.openr66.configuration.AuthenticationFileBasedConfiguration;
import org.waarp.openr66.configuration.RuleFileBasedConfiguration;
import org.waarp.openr66.context.ErrorCode;
import org.waarp.openr66.context.R66Result;
import org.waarp.openr66.context.filesystem.R66File;
import org.waarp.openr66.context.task.ExecJavaTask;
import org.waarp.openr66.context.task.exception.OpenR66RunnerErrorException;
import org.waarp.openr66.database.data.DbHostAuth;
import org.waarp.openr66.database.data.DbHostConfiguration;
import org.waarp.openr66.database.data.DbRule;
import org.waarp.openr66.database.data.DbTaskRunner;
import org.waarp.openr66.pojo.Transfer;
import org.waarp.openr66.pojo.UpdatedInfo;
import org.waarp.openr66.protocol.configuration.Configuration;
import org.waarp.openr66.protocol.configuration.Messages;
import org.waarp.openr66.protocol.configuration.PartnerConfiguration;
import org.waarp.openr66.protocol.exception.OpenR66DatabaseGlobalException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolBusinessException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolBusinessRemoteFileNotFoundException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNoCorrectAuthenticationException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNoDataException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNoSslException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNotAuthenticatedException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolPacketException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolShutdownException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolSystemException;
import org.waarp.openr66.protocol.localhandler.packet.BlockRequestPacket;
import org.waarp.openr66.protocol.localhandler.packet.BusinessRequestPacket;
import org.waarp.openr66.protocol.localhandler.packet.ErrorPacket;
import org.waarp.openr66.protocol.localhandler.packet.InformationPacket;
import org.waarp.openr66.protocol.localhandler.packet.JsonCommandPacket;
import org.waarp.openr66.protocol.localhandler.packet.LocalPacketFactory;
import org.waarp.openr66.protocol.localhandler.packet.RequestPacket;
import org.waarp.openr66.protocol.localhandler.packet.ShutdownPacket;
import org.waarp.openr66.protocol.localhandler.packet.TestPacket;
import org.waarp.openr66.protocol.localhandler.packet.ValidPacket;
import org.waarp.openr66.protocol.localhandler.packet.json.BandwidthJsonPacket;
import org.waarp.openr66.protocol.localhandler.packet.json.BusinessRequestJsonPacket;
import org.waarp.openr66.protocol.localhandler.packet.json.ConfigExportJsonPacket;
import org.waarp.openr66.protocol.localhandler.packet.json.ConfigExportResponseJsonPacket;
import org.waarp.openr66.protocol.localhandler.packet.json.ConfigImportJsonPacket;
import org.waarp.openr66.protocol.localhandler.packet.json.ConfigImportResponseJsonPacket;
import org.waarp.openr66.protocol.localhandler.packet.json.InformationJsonPacket;
import org.waarp.openr66.protocol.localhandler.packet.json.JsonPacket;
import org.waarp.openr66.protocol.localhandler.packet.json.LogJsonPacket;
import org.waarp.openr66.protocol.localhandler.packet.json.LogResponseJsonPacket;
import org.waarp.openr66.protocol.localhandler.packet.json.RestartTransferJsonPacket;
import org.waarp.openr66.protocol.localhandler.packet.json.ShutdownOrBlockJsonPacket;
import org.waarp.openr66.protocol.localhandler.packet.json.ShutdownRequestJsonPacket;
import org.waarp.openr66.protocol.localhandler.packet.json.StopOrCancelJsonPacket;
import org.waarp.openr66.protocol.localhandler.packet.json.TransferRequestJsonPacket;
import org.waarp.openr66.protocol.networkhandler.NetworkChannelReference;
import org.waarp.openr66.protocol.networkhandler.NetworkTransaction;
import org.waarp.openr66.protocol.utils.ChannelCloseTimer;
import org.waarp.openr66.protocol.utils.ChannelUtils;
import org.waarp.openr66.protocol.utils.NbAndSpecialId;
import org.waarp.openr66.protocol.utils.R66Future;
import org.waarp.openr66.protocol.utils.TransferUtils;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.sql.Timestamp;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;

import static org.waarp.common.database.DbConstant.*;
import static org.waarp.openr66.client.RequestInformation.*;
import static org.waarp.openr66.context.R66FiniteDualStates.*;

/**
 * Class to implement actions related to extra server actions: shutdown,
 * bandwidth control, configuration
 * import/export, log purge, request restart/stop/cancel, business request,
 * block new request control,
 * information request and transfer request.
 * &lt;p&gt;
 * Can be used in both standard mode (original packet), or in JSON mode.
 */
public class ServerActions extends ConnectionActions {
  private static final String FILE_IS_NOT_FOUND = &quot;File is not found: &quot;;
  private static final String RUNNER_TASK_IS_NOT_FOUND =
      &quot;RunnerTask is not found: &quot;;
  private static final String
      NOT_CORRECTLY_AUTHENTICATED_SINCE_SSL_IS_NOT_SUPPORTED =
      &quot;Not correctly authenticated since SSL is not supported&quot;;
  private static final String NOT_CORRECTLY_AUTHENTICATED =
      &quot;Not correctly authenticated&quot;;
  /**
   * Internal Logger
   */
<span class="fc" id="L137">  private static final WaarpLogger logger =</span>
<span class="fc" id="L138">      WaarpLoggerFactory.getLogger(ServerActions.class);</span>

<span class="fc" id="L140">  public ServerActions() {</span>
    // nothing
<span class="fc" id="L142">  }</span>

  /**
   * Test reception
   *
   * @param packet
   *
   * @throws OpenR66ProtocolNotAuthenticatedException
   * @throws OpenR66ProtocolPacketException
   */
  public final void test(final TestPacket packet)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolPacketException {
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">    if (!session.isAuthenticated()) {</span>
<span class="nc" id="L156">      throw new OpenR66ProtocolNotAuthenticatedException(</span>
          &quot;Not authenticated while Test received&quot;);
    }
    // simply write back after+1
<span class="fc" id="L160">    packet.update();</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">    if (packet.getType() == LocalPacketFactory.VALIDPACKET) {</span>
<span class="fc" id="L162">      final ValidPacket validPacket = new ValidPacket(packet.toString(), null,</span>
                                                      LocalPacketFactory.TESTPACKET);
<span class="fc" id="L164">      final R66Result result =</span>
          new R66Result(session, true, ErrorCode.CompleteOk, null);
<span class="fc" id="L166">      result.setOther(validPacket);</span>
<span class="fc" id="L167">      session.newState(VALIDOTHER);</span>
<span class="fc" id="L168">      localChannelReference.validateRequest(result);</span>
<span class="fc" id="L169">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, validPacket,</span>
                                            false);
<span class="fc" id="L171">      logger.warn(</span>
<span class="fc" id="L172">          &quot;Valid TEST MESSAGE from &quot; + session.getAuth().getUser() + &quot; [&quot; +</span>
<span class="fc" id="L173">          localChannelReference.getNetworkChannel().remoteAddress() + &quot;] Msg=&quot; +</span>
          packet);
<span class="fc" id="L175">      ChannelCloseTimer.closeFutureTransaction(</span>
<span class="fc" id="L176">          localChannelReference.getServerHandler());</span>
<span class="fc" id="L177">      packet.clear();</span>
<span class="fc" id="L178">    } else {</span>
<span class="fc" id="L179">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, packet,</span>
                                            false);
    }
<span class="fc" id="L182">  }</span>

  /**
   * Receive a request of information
   *
   * @param packet
   *
   * @throws CommandAbstractException
   * @throws OpenR66ProtocolNotAuthenticatedException
   * @throws OpenR66ProtocolNoDataException
   * @throws OpenR66ProtocolPacketException
   */
  public final void information(final InformationPacket packet)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolNoDataException, OpenR66ProtocolPacketException {
<span class="fc" id="L197">    final byte request = packet.getRequest();</span>
<span class="fc" id="L198">    final String rulename = packet.getRulename();</span>
<span class="fc" id="L199">    final String filename = packet.getFilename();</span>
<span class="fc" id="L200">    packet.clear();</span>
<span class="fc" id="L201">    long id = ILLEGALVALUE;</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">    if (request == REQUEST_CHECK) {</span>
      try {
<span class="fc" id="L204">        id = Long.parseLong(rulename);</span>
<span class="nc" id="L205">      } catch (final NumberFormatException e) {</span>
<span class="nc" id="L206">        logger.error(&quot;Incorrect Transfer ID: {}&quot;, e.getMessage());</span>
<span class="nc" id="L207">        throw new OpenR66ProtocolNoDataException(&quot;Incorrect Transfer ID&quot;, e);</span>
<span class="fc" id="L208">      }</span>
    }
<span class="fc" id="L210">    final boolean isTo = &quot;1&quot;.equals(filename);</span>
    final ValidPacket validPacket;
<span class="fc bfc" id="L212" title="All 2 branches covered.">    if (request == REQUEST_CHECK) {</span>
<span class="fc" id="L213">      validPacket = informationRequest(id, isTo, rulename, false);</span>
    } else {
<span class="fc" id="L215">      validPacket = informationFile(request, rulename, filename, false);</span>
    }
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">    if (validPacket != null) {</span>
<span class="fc" id="L218">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, validPacket,</span>
                                            false);
<span class="fc" id="L220">      localChannelReference.close();</span>
    } else {
<span class="nc" id="L222">      session.newState(ERROR);</span>
<span class="nc" id="L223">      final ErrorPacket error =</span>
          new ErrorPacket(&quot;Error while Request &quot; + request,
<span class="nc" id="L225">                          ErrorCode.Internal.getCode(),</span>
                          ErrorPacket.FORWARDCLOSECODE);
<span class="nc" id="L227">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, error,</span>
                                            false);
<span class="nc" id="L229">      ChannelCloseTimer.closeFutureTransaction(</span>
<span class="nc" id="L230">          localChannelReference.getServerHandler());</span>
    }
<span class="fc" id="L232">  }</span>

  /**
   * Receive a validation or a special request
   *
   * @param packet
   *
   * @throws OpenR66ProtocolNotAuthenticatedException
   * @throws OpenR66RunnerErrorException
   * @throws OpenR66ProtocolSystemException
   * @throws OpenR66ProtocolBusinessException
   */
  public final void valid(final ValidPacket packet)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66RunnerErrorException, OpenR66ProtocolSystemException,
             OpenR66ProtocolBusinessException {
    // SHUTDOWNPACKET does not need authentication
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">    if (packet.getTypeValid() != LocalPacketFactory.SHUTDOWNPACKET &amp;&amp;</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        !session.isAuthenticated()) {</span>
<span class="nc" id="L251">      logger.warn(&quot;Valid packet received while not authenticated: {} {}&quot;,</span>
                  packet, session);
<span class="nc" id="L253">      session.newState(ERROR);</span>
<span class="nc" id="L254">      packet.clear();</span>
<span class="nc" id="L255">      throw new OpenR66ProtocolNotAuthenticatedException(</span>
          &quot;Not authenticated while Valid received&quot;);
    }
<span class="pc bpc" id="L258" title="2 of 11 branches missed.">    switch (packet.getTypeValid()) {</span>
      case LocalPacketFactory.SHUTDOWNPACKET: {
<span class="nc" id="L260">        shutdownPacket(packet);</span>
<span class="nc" id="L261">        break;</span>
      }
      case LocalPacketFactory.STOPPACKET:
      case LocalPacketFactory.CANCELPACKET: {
<span class="fc" id="L265">        stopOrCancelPacket(packet);</span>
<span class="fc" id="L266">        break;</span>
      }
      case LocalPacketFactory.VALIDPACKET: {
<span class="fc" id="L269">        validPacket(packet);</span>
<span class="fc" id="L270">        break;</span>
      }
      case LocalPacketFactory.REQUESTUSERPACKET: {
<span class="fc" id="L273">        requestUserPacket(packet);</span>
<span class="fc" id="L274">        break;</span>
      }
      case LocalPacketFactory.LOGPACKET:
      case LocalPacketFactory.LOGPURGEPACKET: {
<span class="fc" id="L278">        logPacket(packet);</span>
<span class="fc" id="L279">        break;</span>
      }
      case LocalPacketFactory.CONFEXPORTPACKET: {
<span class="fc" id="L282">        configExportPacket(packet);</span>
<span class="fc" id="L283">        break;</span>
      }
      case LocalPacketFactory.CONFIMPORTPACKET: {
<span class="fc" id="L286">        configImportPacket(packet);</span>
<span class="fc" id="L287">        break;</span>
      }
      case LocalPacketFactory.INFORMATIONPACKET: {
<span class="fc" id="L290">        session.newState(VALIDOTHER);</span>
        // Validate user request
<span class="fc" id="L292">        final R66Result resulttest =</span>
            new R66Result(session, true, ErrorCode.CompleteOk, null);
<span class="fc" id="L294">        resulttest.setOther(packet);</span>
<span class="fc" id="L295">        localChannelReference.validateRequest(resulttest);</span>
<span class="fc" id="L296">        localChannelReference.close();</span>
<span class="fc" id="L297">        break;</span>
      }
      case LocalPacketFactory.BANDWIDTHPACKET: {
<span class="fc" id="L300">        bandwidthPacket(packet);</span>
<span class="fc" id="L301">        break;</span>
      }
      case LocalPacketFactory.TESTPACKET: {
<span class="fc" id="L304">        session.newState(VALIDOTHER);</span>
<span class="fc" id="L305">        logger.info(&quot;Valid TEST MESSAGE: {}&quot;, packet);</span>
<span class="fc" id="L306">        final R66Result resulttest =</span>
            new R66Result(session, true, ErrorCode.CompleteOk, null);
<span class="fc" id="L308">        resulttest.setOther(packet);</span>
<span class="fc" id="L309">        localChannelReference.validateRequest(resulttest);</span>
<span class="fc" id="L310">        localChannelReference.close();</span>
<span class="fc" id="L311">        break;</span>
      }
      default:
<span class="nc" id="L314">        logger.info(&quot;Validation is ignored: {}&quot;, packet.getTypeValid());</span>
<span class="nc" id="L315">        packet.clear();</span>
    }
<span class="fc" id="L317">  }</span>

  private void bandwidthPacket(final ValidPacket packet)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolNoCorrectAuthenticationException {
<span class="fc" id="L322">    final String[] splitglobal = packet.getSheader().split(&quot; &quot;);</span>
<span class="fc" id="L323">    final String[] splitsession = packet.getSmiddle().split(&quot; &quot;);</span>
<span class="fc" id="L324">    packet.clear();</span>
<span class="fc" id="L325">    final R66Result result =</span>
        new R66Result(session, true, ErrorCode.CompleteOk, null);
    final ValidPacket valid;
<span class="pc bpc" id="L328" title="3 of 4 branches missed.">    if (splitglobal.length &lt; 2 || splitsession.length &lt; 2) {</span>
      // request of current values
<span class="fc" id="L330">      session.newState(VALIDOTHER);</span>
<span class="fc" id="L331">      final long[] lresult = bandwidth(false, 0, 0, 0, 0);</span>
      // Now answer
<span class="fc" id="L333">      valid = new ValidPacket(</span>
          lresult[0] + &quot; &quot; + lresult[1] + ' ' + lresult[2] + ' ' + lresult[3],
<span class="fc" id="L335">          result.getCode().getCode(), LocalPacketFactory.REQUESTUSERPACKET);</span>
<span class="fc" id="L336">    } else {</span>
<span class="nc" id="L337">      session.newState(VALIDOTHER);</span>
<span class="nc" id="L338">      bandwidth(true, Long.parseLong(splitglobal[0]),</span>
<span class="nc" id="L339">                Long.parseLong(splitglobal[1]), Long.parseLong(splitsession[0]),</span>
<span class="nc" id="L340">                Long.parseLong(splitsession[1]));</span>
      // Now answer
<span class="nc" id="L342">      valid = new ValidPacket(&quot;Bandwidth changed&quot;, result.getCode().getCode(),</span>
                              LocalPacketFactory.REQUESTUSERPACKET);
    }
<span class="fc" id="L345">    localChannelReference.validateRequest(result);</span>
    try {
<span class="fc" id="L347">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid,</span>
                                            false);
<span class="nc" id="L349">    } catch (final OpenR66ProtocolPacketException ignored) {</span>
      // nothing
<span class="fc" id="L351">    }</span>
<span class="fc" id="L352">    localChannelReference.close();</span>
<span class="fc" id="L353">  }</span>

  private void configImportPacket(final ValidPacket packet)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolNoCorrectAuthenticationException,
             OpenR66ProtocolSystemException {
<span class="fc" id="L359">    session.newState(VALIDOTHER);</span>
    // Authentication must be the local server or CONFIGADMIN authorization
    try {
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">      if (!session.getAuth().getUser().equals(</span>
<span class="fc" id="L363">          Configuration.configuration.getHostId(session.getAuth().isSsl())) &amp;&amp;</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">          !session.getAuth().isValidRole(ROLE.CONFIGADMIN)) {</span>
<span class="nc" id="L365">        throw new OpenR66ProtocolNoCorrectAuthenticationException(</span>
            NOT_CORRECTLY_AUTHENTICATED);
      }
<span class="nc" id="L368">    } catch (final OpenR66ProtocolNoSslException e1) {</span>
<span class="nc" id="L369">      throw new OpenR66ProtocolNotAuthenticatedException(</span>
          NOT_CORRECTLY_AUTHENTICATED_SINCE_SSL_IS_NOT_SUPPORTED, e1);
<span class="fc" id="L371">    }</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">    if (Configuration.configuration.getR66Mib() != null) {</span>
<span class="nc" id="L373">      Configuration.configuration.getR66Mib().notifyWarning(</span>
<span class="nc" id="L374">          &quot;Import Configuration Order received&quot;, session.getAuth().getUser());</span>
    }
<span class="fc" id="L376">    String shost = packet.getSheader();</span>
<span class="fc" id="L377">    String srule = packet.getSmiddle();</span>
<span class="fc" id="L378">    final boolean bhostPurge = shost.startsWith(&quot;1 &quot;);</span>
<span class="fc" id="L379">    shost = shost.substring(2);</span>
<span class="fc" id="L380">    final boolean brulePurge = srule.startsWith(&quot;1 &quot;);</span>
<span class="fc" id="L381">    srule = srule.substring(2);</span>
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">    boolean bhost = !shost.isEmpty();</span>
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">    boolean brule = !srule.isEmpty();</span>
<span class="fc" id="L384">    packet.clear();</span>
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">    if (bhost) {</span>
<span class="fc" id="L386">      DbHostAuth[] oldHosts = null;</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">      if (bhostPurge) {</span>
        // Need to first delete all entries
        try {
<span class="nc" id="L390">          oldHosts = DbHostAuth.deleteAll();</span>
<span class="nc" id="L391">        } catch (final WaarpDatabaseException e) {</span>
          // ignore
<span class="nc" id="L393">        }</span>
      }
<span class="fc" id="L395">      final String filename = shost;</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">      if (AuthenticationFileBasedConfiguration.loadAuthentication(</span>
          Configuration.configuration, filename)) {
<span class="fc" id="L398">        shost = &quot;Host:OK&quot;;</span>
      } else {
<span class="nc" id="L400">        logger.error(&quot;Error in Load Hosts&quot;);</span>
<span class="nc" id="L401">        shost = &quot;Host:KO&quot;;</span>
<span class="nc" id="L402">        bhost = false;</span>
      }
<span class="pc bpc" id="L404" title="3 of 4 branches missed.">      if (!bhost &amp;&amp; oldHosts != null) {</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">        for (final DbHostAuth dbHost : oldHosts) {</span>
          try {
<span class="nc bnc" id="L407" title="All 2 branches missed.">            if (!dbHost.exist()) {</span>
<span class="nc" id="L408">              dbHost.insert();</span>
            }
<span class="nc" id="L410">          } catch (final WaarpDatabaseException e1) {</span>
            // ignore
<span class="nc" id="L412">          }</span>
        }
      }
    }
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">    if (brule) {</span>
<span class="fc" id="L417">      DbRule[] oldRules = null;</span>
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">      if (brulePurge) {</span>
        // Need to first delete all entries
        try {
<span class="nc" id="L421">          oldRules = DbRule.deleteAll();</span>
<span class="nc" id="L422">        } catch (final WaarpDatabaseException e) {</span>
          // ignore
<span class="nc" id="L424">        }</span>
      }
<span class="fc" id="L426">      final File file = new File(srule);</span>
      try {
<span class="fc" id="L428">        RuleFileBasedConfiguration.getMultipleFromFile(file);</span>
<span class="fc" id="L429">        srule = &quot;Rule:OK&quot;;</span>
<span class="fc" id="L430">        brule = true;</span>
<span class="nc" id="L431">      } catch (final WaarpDatabaseNoConnectionException e) {</span>
<span class="nc" id="L432">        logger.error(&quot;Error: {}&quot;, e.getMessage());</span>
<span class="nc" id="L433">        srule = &quot;Rule:KO&quot;;</span>
<span class="nc" id="L434">        brule = false;</span>
<span class="nc" id="L435">      } catch (final WaarpDatabaseSqlException e) {</span>
<span class="nc" id="L436">        logger.error(&quot;Error&quot;, e);</span>
<span class="nc" id="L437">        srule = &quot;Rule:KO&quot;;</span>
<span class="nc" id="L438">        brule = false;</span>
<span class="nc" id="L439">      } catch (final WaarpDatabaseNoDataException e) {</span>
<span class="nc" id="L440">        logger.error(&quot;Error&quot;, e);</span>
<span class="nc" id="L441">        srule = &quot;Rule:KO&quot;;</span>
<span class="nc" id="L442">        brule = false;</span>
<span class="nc" id="L443">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L444">        logger.error(&quot;Error&quot;, e);</span>
<span class="nc" id="L445">        srule = &quot;Rule:KO&quot;;</span>
<span class="nc" id="L446">        brule = false;</span>
<span class="pc" id="L447">      }</span>
<span class="pc bpc" id="L448" title="3 of 4 branches missed.">      if (!brule &amp;&amp; oldRules != null) {</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">        for (final DbRule dbRule : oldRules) {</span>
          try {
<span class="nc bnc" id="L451" title="All 2 branches missed.">            if (!dbRule.exist()) {</span>
<span class="nc" id="L452">              dbRule.insert();</span>
            }
<span class="nc" id="L454">          } catch (final WaarpDatabaseException e1) {</span>
            // ignore
<span class="nc" id="L456">          }</span>
        }
      }
    }
    final R66Result result;
<span class="pc bpc" id="L461" title="3 of 4 branches missed.">    if (brule || bhost) {</span>
<span class="fc" id="L462">      result = new R66Result(session, true, ErrorCode.CompleteOk, null);</span>
    } else {
<span class="nc" id="L464">      result = new R66Result(session, true, ErrorCode.TransferError, null);</span>
    }
    // Now answer
<span class="fc" id="L467">    final ValidPacket valid =</span>
<span class="fc" id="L468">        new ValidPacket(shost + ' ' + srule, result.getCode().getCode(),</span>
                        LocalPacketFactory.REQUESTUSERPACKET);
<span class="fc" id="L470">    localChannelReference.validateRequest(result);</span>
    try {
<span class="fc" id="L472">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid,</span>
                                            false);
<span class="nc" id="L474">    } catch (final OpenR66ProtocolPacketException ignored) {</span>
      // nothing
<span class="fc" id="L476">    }</span>
<span class="fc" id="L477">    localChannelReference.close();</span>
<span class="fc" id="L478">  }</span>

  private void configExportPacket(final ValidPacket packet)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolNoCorrectAuthenticationException {
<span class="fc" id="L483">    final String shost = packet.getSheader();</span>
<span class="fc" id="L484">    final String srule = packet.getSmiddle();</span>
<span class="fc" id="L485">    final boolean bhost = Boolean.parseBoolean(shost);</span>
<span class="fc" id="L486">    final boolean brule = Boolean.parseBoolean(srule);</span>
<span class="fc" id="L487">    packet.clear();</span>
<span class="fc" id="L488">    session.newState(VALIDOTHER);</span>
<span class="fc" id="L489">    final String[] sresult = configExport(bhost, brule, false, false, false);</span>
    final R66Result result;
<span class="pc bpc" id="L491" title="3 of 4 branches missed.">    if (sresult[0] != null || sresult[1] != null) {</span>
<span class="fc" id="L492">      result = new R66Result(session, true, ErrorCode.CompleteOk, null);</span>
    } else {
<span class="nc" id="L494">      result = new R66Result(session, true, ErrorCode.TransferError, null);</span>
    }
    // Now answer
<span class="fc" id="L497">    final ValidPacket valid =</span>
<span class="fc" id="L498">        new ValidPacket(shost + ' ' + srule, result.getCode().getCode(),</span>
                        LocalPacketFactory.REQUESTUSERPACKET);
<span class="fc" id="L500">    localChannelReference.validateRequest(result);</span>
    try {
<span class="fc" id="L502">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid,</span>
                                            false);
<span class="nc" id="L504">    } catch (final OpenR66ProtocolPacketException ignored) {</span>
      // ignore
<span class="fc" id="L506">    }</span>
<span class="fc" id="L507">    localChannelReference.close();</span>
<span class="fc" id="L508">  }</span>

  private void logPacket(final ValidPacket packet)
      throws OpenR66ProtocolBusinessException {
<span class="fc" id="L512">    session.newState(VALIDOTHER);</span>
    // should be from the local server or from an authorized hosts: LOGCONTROL
    try {
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">      if (!session.getAuth().getUser().equals(</span>
<span class="fc" id="L516">          Configuration.configuration.getHostId(session.getAuth().isSsl())) &amp;&amp;</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">          !session.getAuth().isValidRole(ROLE.LOGCONTROL)) {</span>
<span class="nc" id="L518">        throw new OpenR66ProtocolNoCorrectAuthenticationException(</span>
            NOT_CORRECTLY_AUTHENTICATED);
      }
<span class="nc" id="L521">    } catch (final OpenR66ProtocolNoSslException e1) {</span>
<span class="nc" id="L522">      throw new OpenR66ProtocolNotAuthenticatedException(</span>
          NOT_CORRECTLY_AUTHENTICATED_SINCE_SSL_IS_NOT_SUPPORTED, e1);
<span class="fc" id="L524">    }</span>
<span class="fc" id="L525">    final String sstart = packet.getSheader();</span>
<span class="fc" id="L526">    final String sstop = packet.getSmiddle();</span>
<span class="fc" id="L527">    final boolean isPurge =</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">        packet.getTypeValid() == LocalPacketFactory.LOGPURGEPACKET;</span>
<span class="fc" id="L529">    final Timestamp start =</span>
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">        ParametersChecker.isEmpty(sstart)? null : Timestamp.valueOf(sstart);</span>
<span class="fc" id="L531">    final Timestamp stop =</span>
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">        ParametersChecker.isEmpty(sstop)? null : Timestamp.valueOf(sstop);</span>
<span class="fc" id="L533">    packet.clear();</span>
    // create export of log and optionally purge them from database
<span class="fc" id="L535">    final String filename = Configuration.configuration.getBaseDirectory() +</span>
<span class="fc" id="L536">                            Configuration.configuration.getArchivePath() +</span>
                            DirInterface.SEPARATOR +
<span class="fc" id="L538">                            Configuration.configuration.getHostId() + '_' +</span>
<span class="fc" id="L539">                            System.currentTimeMillis() + &quot;_runners.xml&quot;;</span>
<span class="fc" id="L540">    DbPreparedStatement statement = null;</span>
    try {
<span class="fc" id="L542">      statement = DbTaskRunner.getLogPrepareStatement(</span>
<span class="fc" id="L543">          localChannelReference.getDbSession(), start, stop);</span>
<span class="fc" id="L544">      DbTaskRunner.writeXMLWriter(statement, filename);</span>
<span class="nc" id="L545">    } catch (final WaarpDatabaseNoConnectionException e) {</span>
<span class="nc" id="L546">      throw new OpenR66ProtocolBusinessException(e);</span>
<span class="nc" id="L547">    } catch (final WaarpDatabaseSqlException e) {</span>
<span class="nc" id="L548">      throw new OpenR66ProtocolBusinessException(e);</span>
    } finally {
<span class="pc bpc" id="L550" title="1 of 2 branches missed.">      if (statement != null) {</span>
<span class="fc" id="L551">        statement.realClose();</span>
      }
    }
    // in case of purge
<span class="fc" id="L555">    int nb = 0;</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">    if (isPurge) {</span>
      // purge in same interval all runners with globallaststep
      // as ALLDONETASK or ERRORTASK
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">      if (Configuration.configuration.getR66Mib() != null) {</span>
<span class="nc" id="L560">        Configuration.configuration.getR66Mib()</span>
<span class="nc" id="L561">                                   .notifyWarning(&quot;Purge Log Order received&quot;,</span>
<span class="nc" id="L562">                                                  session.getAuth().getUser());</span>
      }
      try {
<span class="fc" id="L565">        nb = DbTaskRunner.purgeLogPrepareStatement(</span>
<span class="fc" id="L566">            localChannelReference.getDbSession(), start, stop);</span>
<span class="nc" id="L567">      } catch (final WaarpDatabaseNoConnectionException e) {</span>
<span class="nc" id="L568">        throw new OpenR66ProtocolBusinessException(e);</span>
<span class="nc" id="L569">      } catch (final WaarpDatabaseSqlException e) {</span>
<span class="nc" id="L570">        throw new OpenR66ProtocolBusinessException(e);</span>
<span class="fc" id="L571">      }</span>
    }
<span class="fc" id="L573">    final R66Result result =</span>
        new R66Result(session, true, ErrorCode.CompleteOk, null);
    // Now answer
<span class="fc" id="L576">    final ValidPacket valid =</span>
<span class="fc" id="L577">        new ValidPacket(filename + ' ' + nb, result.getCode().getCode(),</span>
                        LocalPacketFactory.REQUESTUSERPACKET);
<span class="fc" id="L579">    localChannelReference.validateRequest(result);</span>
    try {
<span class="fc" id="L581">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid,</span>
                                            false);
<span class="nc" id="L583">    } catch (final OpenR66ProtocolPacketException ignored) {</span>
      // ignore
<span class="fc" id="L585">    }</span>
<span class="fc" id="L586">    localChannelReference.close();</span>
<span class="fc" id="L587">  }</span>

  private void requestUserPacket(final ValidPacket packet) {
<span class="fc" id="L590">    session.newState(VALIDOTHER);</span>
    // Validate user request
<span class="fc" id="L592">    final R66Result resulttest =</span>
<span class="fc" id="L593">        new R66Result(session, true, ErrorCode.getFromCode(packet.getSmiddle()),</span>
                      null);
<span class="fc" id="L595">    resulttest.setOther(packet);</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">    switch (resulttest.getCode()) {</span>
      case CompleteOk:
      case InitOk:
      case PostProcessingOk:
      case PreProcessingOk:
      case QueryAlreadyFinished:
      case QueryStillRunning:
      case Running:
      case TransferOk:
<span class="fc" id="L605">        break;</span>
      default:
<span class="fc" id="L607">        localChannelReference.invalidateRequest(resulttest);</span>
<span class="fc" id="L608">        session.setStatus(102);</span>
<span class="fc" id="L609">        localChannelReference.close();</span>
<span class="fc" id="L610">        return;</span>
    }
<span class="fc" id="L612">    localChannelReference.validateRequest(resulttest);</span>
<span class="fc" id="L613">    session.setStatus(28);</span>
<span class="fc" id="L614">    localChannelReference.close();</span>
<span class="fc" id="L615">  }</span>

  private void validPacket(final ValidPacket packet)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolNoCorrectAuthenticationException {
    // header = ?; middle = requested+blank+requester+blank+specialId
    // note: might contains one more argument = time to reschedule in yyyyMMddHHmmss format
<span class="fc" id="L622">    final String[] keys = packet.getSmiddle().split(&quot; &quot;);</span>
    final ValidPacket valid;
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">    if (keys.length &lt; 3) {</span>
      // not enough args
<span class="nc" id="L626">      valid = new ValidPacket(packet.getSmiddle(),</span>
<span class="nc" id="L627">                              ErrorCode.IncorrectCommand.getCode(),</span>
                              LocalPacketFactory.REQUESTUSERPACKET);
<span class="nc" id="L629">      final R66Result resulttest = new R66Result(</span>
          new OpenR66ProtocolBusinessRemoteFileNotFoundException(
              &quot;Not enough arguments&quot;), session, true,
          ErrorCode.IncorrectCommand, null);
<span class="nc" id="L633">      resulttest.setOther(packet);</span>
<span class="nc" id="L634">      localChannelReference.invalidateRequest(resulttest);</span>
<span class="nc" id="L635">    } else {</span>
<span class="fc" id="L636">      final long id = Long.parseLong(keys[2]);</span>
<span class="fc" id="L637">      Date date = null;</span>
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">      if (keys.length &gt; 3) {</span>
        // time to reschedule in yyyyMMddHHmmss format
<span class="nc" id="L640">        logger.debug(&quot;Debug: restart with {}&quot;, keys[3]);</span>
<span class="nc" id="L641">        final SimpleDateFormat dateFormat =</span>
            new SimpleDateFormat(AbstractTransfer.TIMESTAMP_FORMAT);
        try {
<span class="nc" id="L644">          date = dateFormat.parse(keys[3]);</span>
<span class="nc" id="L645">        } catch (final ParseException ignored) {</span>
          // ignore
<span class="nc" id="L647">        }</span>
      }
<span class="fc" id="L649">      session.newState(VALIDOTHER);</span>
<span class="fc" id="L650">      final R66Result result = requestRestart(keys[0], keys[1], id, date);</span>
<span class="fc" id="L651">      valid = new ValidPacket(packet.getSmiddle(), result.getCode().getCode(),</span>
                              LocalPacketFactory.REQUESTUSERPACKET);
<span class="fc" id="L653">      result.setOther(packet);</span>
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">      if (isCodeValid(result.getCode())) {</span>
<span class="nc" id="L655">        localChannelReference.validateRequest(result);</span>
      } else {
<span class="fc" id="L657">        localChannelReference.invalidateRequest(result);</span>
      }
    }
    // inform back the requester
    try {
<span class="fc" id="L662">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid,</span>
                                            false);
<span class="nc" id="L664">    } catch (final OpenR66ProtocolPacketException ignored) {</span>
      // ignore
<span class="fc" id="L666">    }</span>
<span class="fc" id="L667">    localChannelReference.close();</span>
<span class="fc" id="L668">  }</span>

  private void stopOrCancelPacket(final ValidPacket packet)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolNoCorrectAuthenticationException {
<span class="fc" id="L673">    final String[] keys = packet.getSmiddle().split(&quot; &quot;);</span>
<span class="fc" id="L674">    final long id = Long.parseLong(keys[2]);</span>
<span class="fc" id="L675">    session.newState(VALIDOTHER);</span>
<span class="fc" id="L676">    final R66Result resulttest =</span>
<span class="fc" id="L677">        stopOrCancel(packet.getTypeValid(), keys[0], keys[1], id);</span>
    // inform back the requester
<span class="fc" id="L679">    final ValidPacket valid =</span>
<span class="fc" id="L680">        new ValidPacket(packet.getSmiddle(), resulttest.getCode().getCode(),</span>
                        LocalPacketFactory.REQUESTUSERPACKET);
<span class="fc" id="L682">    resulttest.setOther(packet);</span>
<span class="fc" id="L683">    localChannelReference.validateRequest(resulttest);</span>
    try {
<span class="fc" id="L685">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid,</span>
                                            false);
<span class="nc" id="L687">    } catch (final OpenR66ProtocolPacketException ignored) {</span>
      // ignore
<span class="fc" id="L689">    }</span>
<span class="fc" id="L690">    session.setStatus(27);</span>
<span class="fc" id="L691">    localChannelReference.close();</span>
<span class="fc" id="L692">  }</span>

  private void shutdownPacket(final ValidPacket packet)
      throws OpenR66RunnerErrorException, OpenR66ProtocolSystemException {
<span class="nc" id="L696">    int rank = -1;</span>
<span class="nc bnc" id="L697" title="All 4 branches missed.">    if (session.getRunner() != null &amp;&amp; session.getRunner().isInTransfer()) {</span>
<span class="nc" id="L698">      final String srank = packet.getSmiddle();</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">      if (ParametersChecker.isNotEmpty(srank)) {</span>
        // Save last rank from remote point of view
        try {
<span class="nc" id="L702">          rank = Integer.parseInt(srank);</span>
<span class="nc" id="L703">        } catch (final NumberFormatException e) {</span>
          // ignore
<span class="nc" id="L705">        }</span>
      }
    }
<span class="nc" id="L708">    final R66Result result =</span>
        new R66Result(new OpenR66ProtocolShutdownException(), session, true,
<span class="nc" id="L710">                      ErrorCode.Shutdown, session.getRunner());</span>
<span class="nc" id="L711">    result.setOther(packet);</span>
<span class="nc" id="L712">    rank = shutdownRequest(result, rank);</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">    if (rank &gt;= 0) {</span>
<span class="nc" id="L714">      packet.setSmiddle(Integer.toString(rank));</span>
      try {
<span class="nc" id="L716">        ChannelUtils.writeAbstractLocalPacket(localChannelReference, packet,</span>
                                              false);
<span class="nc" id="L718">      } catch (final OpenR66ProtocolPacketException ignored) {</span>
        // ignore
<span class="nc" id="L720">      }</span>
    }
<span class="nc" id="L722">    shutdownLocalChannel();</span>
<span class="nc" id="L723">  }</span>

  /**
   * Receive a json request
   *
   * @param packet
   * @param json
   *
   * @throws OpenR66ProtocolNotAuthenticatedException
   * @throws OpenR66RunnerErrorException
   * @throws OpenR66ProtocolSystemException
   * @throws OpenR66ProtocolBusinessException
   * @throws OpenR66ProtocolShutdownException
   * @throws OpenR66ProtocolPacketException
   * @throws OpenR66ProtocolNoDataException
   */
  public final void jsonCommand(final JsonCommandPacket packet,
                                final JsonPacket json)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66RunnerErrorException, OpenR66ProtocolSystemException,
             OpenR66ProtocolBusinessException, OpenR66ProtocolShutdownException,
             OpenR66ProtocolPacketException, OpenR66ProtocolNoDataException {
    // SHUTDOWNPACKET does not need authentication
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">    if (packet.getTypeValid() != LocalPacketFactory.SHUTDOWNPACKET &amp;&amp;</span>
<span class="pc bpc" id="L747" title="1 of 2 branches missed.">        !session.isAuthenticated()) {</span>
<span class="nc" id="L748">      logger.warn(&quot;JsonCommand packet received while not authenticated: {} {}&quot;,</span>
                  packet, session);
<span class="nc" id="L750">      session.newState(ERROR);</span>
<span class="nc" id="L751">      throw new OpenR66ProtocolNotAuthenticatedException(</span>
          &quot;Not authenticated while Valid received&quot;);
    }
<span class="pc bpc" id="L754" title="1 of 2 branches missed.">    if (json == null) {</span>
<span class="nc" id="L755">      jsonCommandEmptyJson(packet);</span>
<span class="nc" id="L756">      return;</span>
    }
<span class="pc bpc" id="L758" title="4 of 14 branches missed.">    switch (json.getRequestUserPacket()) {</span>
      case LocalPacketFactory.SHUTDOWNPACKET: {
<span class="nc" id="L760">        jsonCommandShutdown(packet, (ShutdownRequestJsonPacket) json);</span>
<span class="nc" id="L761">        break;</span>
      }
      case LocalPacketFactory.BLOCKREQUESTPACKET: {
<span class="fc" id="L764">        jsonCommandBlockRequest(json);</span>
<span class="fc" id="L765">        break;</span>
      }
      case LocalPacketFactory.BUSINESSREQUESTPACKET: {
<span class="fc" id="L768">        jsonCommandBusinessCommand((BusinessRequestJsonPacket) json);</span>
<span class="fc" id="L769">        break;</span>
      }
      case LocalPacketFactory.INFORMATIONPACKET: {
<span class="fc" id="L772">        jsonCommandInformation((InformationJsonPacket) json);</span>
<span class="fc" id="L773">        break;</span>
      }
      case LocalPacketFactory.REQUESTPACKET: {
<span class="nc" id="L776">        jsonCommandRequest(packet, json);</span>
<span class="nc" id="L777">        break;</span>
      }
      case LocalPacketFactory.STOPPACKET:
      case LocalPacketFactory.CANCELPACKET: {
<span class="fc" id="L781">        jsonCommandStopOrCancel(packet, json);</span>
<span class="fc" id="L782">        break;</span>
      }
      case LocalPacketFactory.VALIDPACKET: {
<span class="nc" id="L785">        jsonCommandValid(packet, (RestartTransferJsonPacket) json);</span>
<span class="nc" id="L786">        break;</span>
      }
      case LocalPacketFactory.REQUESTUSERPACKET: {
<span class="fc" id="L789">        jsonCommandRequestUser(packet);</span>
<span class="fc" id="L790">        break;</span>
      }
      case LocalPacketFactory.LOGPACKET:
      case LocalPacketFactory.LOGPURGEPACKET: {
<span class="fc" id="L794">        jsonCommandLog(packet, (LogJsonPacket) json);</span>
<span class="fc" id="L795">        break;</span>
      }
      case LocalPacketFactory.CONFEXPORTPACKET: {
<span class="fc" id="L798">        jsonCommandConfigExport((ConfigExportJsonPacket) json);</span>
<span class="fc" id="L799">        break;</span>
      }
      case LocalPacketFactory.CONFIMPORTPACKET: {
<span class="fc" id="L802">        jsonCommandConfigImport((ConfigImportJsonPacket) json);</span>
<span class="fc" id="L803">        break;</span>
      }
      case LocalPacketFactory.BANDWIDTHPACKET: {
<span class="fc" id="L806">        jsonCommandBandwidth((BandwidthJsonPacket) json);</span>
<span class="fc" id="L807">        break;</span>
      }
      case LocalPacketFactory.TESTPACKET: {
<span class="fc" id="L810">        jsonCommandTest(packet, json);</span>
<span class="fc" id="L811">        break;</span>
      }
      default:
<span class="nc" id="L814">        logger.warn(&quot;Validation is ignored: &quot; + packet.getTypeValid());</span>
    }
<span class="fc" id="L816">  }</span>

  private void jsonCommandTest(final JsonCommandPacket packet,
                               final JsonPacket json) {
<span class="fc" id="L820">    session.newState(VALIDOTHER);</span>
<span class="fc" id="L821">    logger.info(&quot;Valid TEST MESSAGE: {}&quot;, packet);</span>
<span class="fc" id="L822">    final R66Result resulttest =</span>
        new R66Result(session, true, ErrorCode.CompleteOk, null);
<span class="fc" id="L824">    resulttest.setOther(packet);</span>
<span class="fc" id="L825">    final JsonCommandPacket valid =</span>
<span class="fc" id="L826">        new JsonCommandPacket(json, resulttest.getCode().getCode(),</span>
                              LocalPacketFactory.REQUESTUSERPACKET);
<span class="fc" id="L828">    localChannelReference.validateRequest(resulttest);</span>
    try {
<span class="fc" id="L830">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid,</span>
                                            false);
<span class="nc" id="L832">    } catch (final OpenR66ProtocolPacketException ignored) {</span>
      // ignore
<span class="fc" id="L834">    }</span>
<span class="fc" id="L835">    localChannelReference.close();</span>
<span class="fc" id="L836">  }</span>

  private void jsonCommandBandwidth(final BandwidthJsonPacket json)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolNoCorrectAuthenticationException {
    // setter, writeglobal, readglobal, writesession, readsession
<span class="fc" id="L842">    final boolean setter = json.isSetter();</span>
    // request of current values or set new values
<span class="fc" id="L844">    session.newState(VALIDOTHER);</span>
<span class="fc" id="L845">    final long[] lresult =</span>
<span class="fc" id="L846">        bandwidth(setter, json.getWriteglobal(), json.getReadglobal(),</span>
<span class="fc" id="L847">                  json.getWritesession(), json.getReadsession());</span>
    // Now answer
<span class="fc" id="L849">    json.setWriteglobal(lresult[0]);</span>
<span class="fc" id="L850">    json.setReadglobal(lresult[1]);</span>
<span class="fc" id="L851">    json.setWritesession(lresult[2]);</span>
<span class="fc" id="L852">    json.setReadsession(lresult[3]);</span>
<span class="fc" id="L853">    final R66Result result =</span>
        new R66Result(session, true, ErrorCode.CompleteOk, null);
<span class="fc" id="L855">    final JsonCommandPacket valid =</span>
<span class="fc" id="L856">        new JsonCommandPacket(json, result.getCode().getCode(),</span>
                              LocalPacketFactory.REQUESTUSERPACKET);
<span class="fc" id="L858">    localChannelReference.validateRequest(result);</span>
    try {
<span class="fc" id="L860">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid,</span>
                                            false);
<span class="nc" id="L862">    } catch (final OpenR66ProtocolPacketException ignored) {</span>
      // ignore
<span class="fc" id="L864">    }</span>
<span class="fc" id="L865">    localChannelReference.close();</span>
<span class="fc" id="L866">  }</span>

  private void jsonCommandConfigImport(final ConfigImportJsonPacket json)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolSystemException,
             OpenR66ProtocolNoCorrectAuthenticationException {
<span class="fc" id="L872">    final ConfigImportResponseJsonPacket resp = configImport(json);</span>
    final R66Result result;
<span class="pc bpc" id="L874" title="3 of 4 branches missed.">    if (resp.isImportedhost() || resp.isImportedrule() ||</span>
<span class="nc bnc" id="L875" title="All 4 branches missed.">        resp.isImportedbusiness() || resp.isImportedalias() ||</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">        resp.isImportedroles()) {</span>
<span class="fc" id="L877">      result = new R66Result(session, true, ErrorCode.CompleteOk, null);</span>
    } else {
<span class="nc" id="L879">      result = new R66Result(session, true, ErrorCode.TransferError, null);</span>
    }
<span class="fc" id="L881">    final JsonCommandPacket valid =</span>
<span class="fc" id="L882">        new JsonCommandPacket(resp, result.getCode().getCode(),</span>
                              LocalPacketFactory.REQUESTUSERPACKET);
<span class="fc" id="L884">    logger.debug(valid.getRequest());</span>
<span class="fc" id="L885">    localChannelReference.validateRequest(result);</span>
    try {
<span class="fc" id="L887">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid,</span>
                                            false);
<span class="nc" id="L889">    } catch (final OpenR66ProtocolPacketException ignored) {</span>
      // ignore
<span class="fc" id="L891">    }</span>
<span class="fc" id="L892">    localChannelReference.close();</span>
<span class="fc" id="L893">  }</span>

  private void jsonCommandConfigExport(final ConfigExportJsonPacket json)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolNoCorrectAuthenticationException {
    // host, rule, business, alias, roles
<span class="fc" id="L899">    final boolean bhost = json.isHost();</span>
<span class="fc" id="L900">    final boolean brule = json.isRule();</span>
<span class="fc" id="L901">    final boolean bbusiness = json.isBusiness();</span>
<span class="fc" id="L902">    final boolean balias = json.isAlias();</span>
<span class="fc" id="L903">    final boolean broles = json.isRoles();</span>
<span class="fc" id="L904">    session.newState(VALIDOTHER);</span>
<span class="fc" id="L905">    final String[] sresult =</span>
<span class="fc" id="L906">        configExport(bhost, brule, bbusiness, balias, broles);</span>
    // Now answer
<span class="fc" id="L908">    final ConfigExportResponseJsonPacket resp =</span>
        new ConfigExportResponseJsonPacket();
<span class="fc" id="L910">    resp.fromJson(json);</span>
<span class="fc" id="L911">    resp.setFilehost(sresult[0]);</span>
<span class="fc" id="L912">    resp.setFilerule(sresult[1]);</span>
<span class="fc" id="L913">    resp.setFilebusiness(sresult[2]);</span>
<span class="fc" id="L914">    resp.setFilealias(sresult[3]);</span>
<span class="fc" id="L915">    resp.setFileroles(sresult[4]);</span>
    final R66Result result;
<span class="pc bpc" id="L917" title="3 of 4 branches missed.">    if (resp.getFilerule() != null || resp.getFilehost() != null ||</span>
<span class="nc bnc" id="L918" title="All 4 branches missed.">        resp.getFilebusiness() != null || resp.getFilealias() != null ||</span>
<span class="nc bnc" id="L919" title="All 2 branches missed.">        resp.getFileroles() != null) {</span>
<span class="fc" id="L920">      result = new R66Result(session, true, ErrorCode.CompleteOk, null);</span>
    } else {
<span class="nc" id="L922">      result = new R66Result(session, true, ErrorCode.TransferError, null);</span>
    }
<span class="fc" id="L924">    final JsonCommandPacket valid =</span>
<span class="fc" id="L925">        new JsonCommandPacket(resp, result.getCode().getCode(),</span>
                              LocalPacketFactory.REQUESTUSERPACKET);
<span class="fc" id="L927">    localChannelReference.validateRequest(result);</span>
    try {
<span class="fc" id="L929">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid,</span>
                                            false);
<span class="nc" id="L931">    } catch (final OpenR66ProtocolPacketException ignored) {</span>
      // ignore
<span class="fc" id="L933">    }</span>
<span class="fc" id="L934">    localChannelReference.close();</span>
<span class="fc" id="L935">  }</span>

  private void jsonCommandLog(final JsonCommandPacket packet,
                              final LogJsonPacket json)
      throws OpenR66ProtocolBusinessException {
<span class="fc" id="L940">    final boolean purge = json.isPurge();</span>
<span class="fc" id="L941">    final boolean clean = json.isClean();</span>
<span class="pc bpc" id="L942" title="1 of 2 branches missed.">    final Timestamp start = json.getStart() == null? null :</span>
<span class="pc" id="L943">        new Timestamp(json.getStart().getTime());</span>
<span class="fc" id="L944">    final Timestamp stop =</span>
<span class="pc bpc" id="L945" title="1 of 2 branches missed.">        json.getStop() == null? null : new Timestamp(json.getStop().getTime());</span>
<span class="fc" id="L946">    final String startid = json.getStartid();</span>
<span class="fc" id="L947">    final String stopid = json.getStopid();</span>
<span class="fc" id="L948">    final String rule = json.getRule();</span>
<span class="fc" id="L949">    final String request = json.getRequest();</span>
<span class="fc" id="L950">    final boolean pending = json.isStatuspending();</span>
<span class="fc" id="L951">    final boolean transfer = json.isStatustransfer();</span>
<span class="fc" id="L952">    final boolean done = json.isStatusdone();</span>
<span class="fc" id="L953">    final boolean error = json.isStatuserror();</span>
<span class="fc" id="L954">    final boolean isPurge =</span>
<span class="pc bpc" id="L955" title="1 of 4 branches missed.">        packet.getTypeValid() == LocalPacketFactory.LOGPURGEPACKET || purge;</span>
<span class="fc" id="L956">    session.newState(VALIDOTHER);</span>
<span class="fc" id="L957">    final String[] sresult =</span>
<span class="fc" id="L958">        logPurge(purge, clean, start, stop, startid, stopid, rule, request,</span>
                 pending, transfer, done, error, isPurge);
<span class="fc" id="L960">    final LogResponseJsonPacket newjson = new LogResponseJsonPacket();</span>
<span class="fc" id="L961">    newjson.fromJson(json);</span>
    // Now answer
<span class="fc" id="L963">    newjson.setCommand(packet.getTypeValid());</span>
<span class="fc" id="L964">    newjson.setFilename(sresult[0]);</span>
<span class="fc" id="L965">    newjson.setExported(Long.parseLong(sresult[1]));</span>
<span class="fc" id="L966">    newjson.setPurged(Long.parseLong(sresult[2]));</span>
<span class="fc" id="L967">    final R66Result result =</span>
        new R66Result(session, true, ErrorCode.CompleteOk, null);
<span class="fc" id="L969">    final JsonCommandPacket valid =</span>
<span class="fc" id="L970">        new JsonCommandPacket(newjson, result.getCode().getCode(),</span>
                              LocalPacketFactory.REQUESTUSERPACKET);
<span class="fc" id="L972">    localChannelReference.validateRequest(result);</span>
    try {
<span class="fc" id="L974">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid,</span>
                                            false);
<span class="nc" id="L976">    } catch (final OpenR66ProtocolPacketException ignored) {</span>
      // ignore
<span class="fc" id="L978">    }</span>
<span class="fc" id="L979">    localChannelReference.close();</span>
<span class="fc" id="L980">  }</span>

  private void jsonCommandRequestUser(final JsonCommandPacket packet) {
<span class="fc" id="L983">    session.newState(VALIDOTHER);</span>
    // Validate user request
<span class="fc" id="L985">    final R66Result resulttest =</span>
<span class="fc" id="L986">        new R66Result(session, true, ErrorCode.getFromCode(packet.getResult()),</span>
                      null);
<span class="fc" id="L988">    resulttest.setOther(packet);</span>
<span class="pc bpc" id="L989" title="1 of 2 branches missed.">    switch (resulttest.getCode()) {</span>
      case CompleteOk:
      case InitOk:
      case PostProcessingOk:
      case PreProcessingOk:
      case QueryAlreadyFinished:
      case QueryStillRunning:
      case Running:
      case TransferOk:
<span class="fc" id="L998">        break;</span>
      default:
<span class="nc" id="L1000">        localChannelReference.invalidateRequest(resulttest);</span>
<span class="nc" id="L1001">        session.setStatus(102);</span>
<span class="nc" id="L1002">        localChannelReference.close();</span>
<span class="nc" id="L1003">        return;</span>
    }
<span class="fc" id="L1005">    localChannelReference.validateRequest(resulttest);</span>
<span class="fc" id="L1006">    session.setStatus(28);</span>
<span class="fc" id="L1007">    localChannelReference.close();</span>
<span class="fc" id="L1008">  }</span>

  private void jsonCommandValid(final JsonCommandPacket packet,
                                final RestartTransferJsonPacket json)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolNoCorrectAuthenticationException {
<span class="nc" id="L1014">    session.newState(VALIDOTHER);</span>
<span class="nc" id="L1015">    final R66Result result =</span>
<span class="nc" id="L1016">        requestRestart(json.getRequested(), json.getRequester(),</span>
<span class="nc" id="L1017">                       json.getSpecialid(), json.getRestarttime());</span>
<span class="nc" id="L1018">    result.setOther(packet);</span>
<span class="nc" id="L1019">    final JsonCommandPacket valid =</span>
<span class="nc" id="L1020">        new JsonCommandPacket(json, result.getCode().getCode(),</span>
                              LocalPacketFactory.REQUESTUSERPACKET);
<span class="nc bnc" id="L1022" title="All 2 branches missed.">    if (isCodeValid(result.getCode())) {</span>
<span class="nc" id="L1023">      localChannelReference.validateRequest(result);</span>
    } else {
<span class="nc" id="L1025">      localChannelReference.invalidateRequest(result);</span>
    }
    // inform back the requester
    try {
<span class="nc" id="L1029">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid,</span>
                                            false);
<span class="nc" id="L1031">    } catch (final OpenR66ProtocolPacketException ignored) {</span>
      // ignore
<span class="nc" id="L1033">    }</span>
<span class="nc" id="L1034">    localChannelReference.close();</span>
<span class="nc" id="L1035">  }</span>

  private void jsonCommandStopOrCancel(final JsonCommandPacket packet,
                                       final JsonPacket json)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolNoCorrectAuthenticationException {
<span class="fc" id="L1041">    final StopOrCancelJsonPacket node = (StopOrCancelJsonPacket) json;</span>
    final R66Result resulttest;
<span class="pc bpc" id="L1043" title="2 of 4 branches missed.">    if (node.getRequested() == null || node.getRequester() == null ||</span>
<span class="pc bpc" id="L1044" title="1 of 2 branches missed.">        node.getSpecialid() == ILLEGALVALUE) {</span>
<span class="nc" id="L1045">      final ErrorCode code = ErrorCode.CommandNotFound;</span>
<span class="nc" id="L1046">      resulttest = new R66Result(session, true, code, session.getRunner());</span>
<span class="nc" id="L1047">    } else {</span>
<span class="fc" id="L1048">      final String reqd = node.getRequested();</span>
<span class="fc" id="L1049">      final String reqr = node.getRequester();</span>
<span class="fc" id="L1050">      final long id = node.getSpecialid();</span>
<span class="fc" id="L1051">      session.newState(VALIDOTHER);</span>
<span class="fc" id="L1052">      resulttest = stopOrCancel(packet.getTypeValid(), reqd, reqr, id);</span>
    }
    // inform back the requester
<span class="fc" id="L1055">    final JsonCommandPacket valid =</span>
<span class="fc" id="L1056">        new JsonCommandPacket(json, resulttest.getCode().getCode(),</span>
                              LocalPacketFactory.REQUESTUSERPACKET);
<span class="fc" id="L1058">    resulttest.setOther(packet);</span>
<span class="fc" id="L1059">    localChannelReference.validateRequest(resulttest);</span>
    try {
<span class="fc" id="L1061">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid,</span>
                                            false);
<span class="nc" id="L1063">    } catch (final OpenR66ProtocolPacketException ignored) {</span>
      // ignore
<span class="fc" id="L1065">    }</span>
<span class="fc" id="L1066">    session.setStatus(27);</span>
<span class="fc" id="L1067">    localChannelReference.close();</span>
<span class="fc" id="L1068">  }</span>

  private void jsonCommandRequest(final JsonCommandPacket packet,
                                  final JsonPacket json)
      throws OpenR66ProtocolPacketException {
<span class="nc" id="L1073">    final TransferRequestJsonPacket node = (TransferRequestJsonPacket) json;</span>
<span class="nc" id="L1074">    final R66Result result = transferRequest(node);</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">    if (isCodeValid(result.getCode())) {</span>
<span class="nc" id="L1076">      final JsonCommandPacket valid =</span>
<span class="nc" id="L1077">          new JsonCommandPacket(json, result.getCode().getCode(),</span>
                                LocalPacketFactory.REQUESTUSERPACKET);
<span class="nc" id="L1079">      result.setOther(packet);</span>
<span class="nc" id="L1080">      localChannelReference.validateRequest(result);</span>
      try {
<span class="nc" id="L1082">        ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid,</span>
                                              false);
<span class="nc" id="L1084">      } catch (final OpenR66ProtocolPacketException ignored) {</span>
        // ignore
<span class="nc" id="L1086">      }</span>
<span class="nc" id="L1087">      session.setStatus(27);</span>
<span class="nc" id="L1088">      localChannelReference.close();</span>
<span class="nc" id="L1089">    } else {</span>
<span class="nc" id="L1090">      result.setOther(packet);</span>
<span class="nc" id="L1091">      localChannelReference.invalidateRequest(result);</span>
<span class="nc" id="L1092">      final ErrorPacket error = new ErrorPacket(</span>
          &quot;TransferRequest in error: for &quot; + node + &quot; since &quot; +
<span class="nc" id="L1094">          result.getMessage(), result.getCode().getCode(),</span>
          ErrorPacket.FORWARDCLOSECODE);
<span class="nc" id="L1096">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, error,</span>
                                            false);
<span class="nc" id="L1098">      ChannelCloseTimer.closeFutureTransaction(</span>
<span class="nc" id="L1099">          localChannelReference.getServerHandler());</span>
    }
<span class="nc" id="L1101">  }</span>

  private void jsonCommandInformation(final InformationJsonPacket json)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolNoDataException, OpenR66ProtocolPacketException {
    final ValidPacket validPacket;
<span class="fc bfc" id="L1107" title="All 2 branches covered.">    if (json.isIdRequest()) {</span>
<span class="fc" id="L1108">      validPacket =</span>
<span class="fc" id="L1109">          informationRequest(json.getId(), json.isTo(), json.getRulename(),</span>
                             false);
    } else {
<span class="fc" id="L1112">      validPacket = informationFile(json.getRequest(), json.getRulename(),</span>
<span class="fc" id="L1113">                                    json.getFilename(), false);</span>
    }
<span class="pc bpc" id="L1115" title="1 of 2 branches missed.">    if (validPacket != null) {</span>
<span class="fc" id="L1116">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, validPacket,</span>
                                            false);
<span class="fc" id="L1118">      localChannelReference.close();</span>
    } else {
<span class="nc" id="L1120">      session.newState(ERROR);</span>
<span class="nc" id="L1121">      final ErrorPacket error = new ErrorPacket(&quot;Error while Request &quot; + json,</span>
<span class="nc" id="L1122">                                                ErrorCode.Internal.getCode(),</span>
                                                ErrorPacket.FORWARDCLOSECODE);
<span class="nc" id="L1124">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, error,</span>
                                            false);
<span class="nc" id="L1126">      ChannelCloseTimer.closeFutureTransaction(</span>
<span class="nc" id="L1127">          localChannelReference.getServerHandler());</span>
    }
<span class="fc" id="L1129">  }</span>

  private void jsonCommandBusinessCommand(final BusinessRequestJsonPacket json)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolPacketException,
             OpenR66ProtocolNoCorrectAuthenticationException {
<span class="pc bpc" id="L1135" title="1 of 2 branches missed.">    if (json.isToApplied()) {</span>
<span class="nc" id="L1136">      session.newState(BUSINESSD);</span>
    }
<span class="fc" id="L1138">    final R66Future future =</span>
<span class="fc" id="L1139">        businessRequest(json.isToApplied(), json.getClassName(),</span>
<span class="fc" id="L1140">                        json.getArguments(), json.getExtraArguments(),</span>
<span class="fc" id="L1141">                        json.getDelay());</span>
<span class="pc bpc" id="L1142" title="2 of 4 branches missed.">    if (future != null &amp;&amp; !future.isSuccess()) {</span>
<span class="nc" id="L1143">      R66Result result = future.getResult();</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">      if (result == null) {</span>
<span class="nc" id="L1145">        result = new R66Result(session, false, ErrorCode.ExternalOp,</span>
<span class="nc" id="L1146">                               session.getRunner());</span>
      }
<span class="nc" id="L1148">      wrongResult(json, result);</span>
<span class="pc bpc" id="L1149" title="1 of 2 branches missed.">    } else if (future == null) {</span>
<span class="nc" id="L1150">      final R66Result result =</span>
          new R66Result(session, false, ErrorCode.ExternalOp,
<span class="nc" id="L1152">                        session.getRunner());</span>
<span class="nc" id="L1153">      wrongResult(json, result);</span>
<span class="nc" id="L1154">    } else {</span>
<span class="fc" id="L1155">      logger.debug(&quot;BusinessRequest part 2&quot;);</span>
<span class="fc" id="L1156">      final R66Result result = future.getResult();</span>
<span class="fc" id="L1157">      final JsonCommandPacket valid =</span>
<span class="fc" id="L1158">          new JsonCommandPacket(json, result.getCode().getCode(),</span>
                                LocalPacketFactory.REQUESTUSERPACKET);
<span class="pc bpc" id="L1160" title="1 of 2 branches missed.">      if (isCodeValid(result.getCode())) {</span>
<span class="fc" id="L1161">        localChannelReference.validateRequest(result);</span>
      } else {
<span class="nc" id="L1163">        localChannelReference.invalidateRequest(result);</span>
      }
      // inform back the requester
      try {
<span class="fc" id="L1167">        ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid,</span>
                                              false);
<span class="nc" id="L1169">      } catch (final OpenR66ProtocolPacketException ignored) {</span>
        // ignore
<span class="fc" id="L1171">      }</span>
<span class="fc" id="L1172">      localChannelReference.close();</span>
    }
<span class="fc" id="L1174">  }</span>

  private void wrongResult(final BusinessRequestJsonPacket node,
                           final R66Result result)
      throws OpenR66ProtocolPacketException {
<span class="nc" id="L1179">    logger.info(&quot;Task in Error: {} {}&quot;, node.getClassName(), result);</span>
<span class="nc bnc" id="L1180" title="All 2 branches missed.">    if (!result.isAnswered()) {</span>
<span class="nc" id="L1181">      node.setValidated(false);</span>
<span class="nc" id="L1182">      session.newState(ERROR);</span>
<span class="nc" id="L1183">      final ErrorPacket error = new ErrorPacket(</span>
          &quot;BusinessRequest in error: for &quot; + node + &quot; since &quot; +
<span class="nc" id="L1185">          result.getMessage(), result.getCode().getCode(),</span>
          ErrorPacket.FORWARDCLOSECODE);
<span class="nc" id="L1187">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, error,</span>
                                            false);
<span class="nc" id="L1189">      session.setStatus(203);</span>
    }
<span class="nc" id="L1191">    session.setStatus(204);</span>
<span class="nc" id="L1192">  }</span>

  private void jsonCommandBlockRequest(final JsonPacket json)
      throws OpenR66ProtocolShutdownException,
             OpenR66ProtocolBusinessException {
<span class="fc" id="L1197">    final ShutdownOrBlockJsonPacket node = (ShutdownOrBlockJsonPacket) json;</span>
<span class="fc" id="L1198">    final byte[] key = node.getKey();</span>
<span class="fc bfc" id="L1199" title="All 2 branches covered.">    if (node.isShutdownOrBlock()) {</span>
      // Shutdown
<span class="fc" id="L1201">      session.newState(SHUTDOWN);</span>
<span class="nc" id="L1202">      shutdown(key, node.isRestartOrBlock());</span>
    } else {
      // Block
<span class="fc" id="L1205">      final R66Result result = blockRequest(key, node.isRestartOrBlock());</span>
<span class="fc" id="L1206">      node.setComment(</span>
<span class="pc bpc" id="L1207" title="1 of 2 branches missed.">          (node.isRestartOrBlock()? &quot;Block&quot; : &quot;Unblock&quot;) + &quot; new request&quot;);</span>
<span class="fc" id="L1208">      final JsonCommandPacket valid =</span>
<span class="fc" id="L1209">          new JsonCommandPacket(json, result.getCode().getCode(),</span>
                                LocalPacketFactory.REQUESTUSERPACKET);
      try {
<span class="fc" id="L1212">        ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid,</span>
                                              false);
<span class="nc" id="L1214">      } catch (final OpenR66ProtocolPacketException ignored) {</span>
        // ignore
<span class="fc" id="L1216">      }</span>
<span class="fc" id="L1217">      localChannelReference.close();</span>
    }
<span class="fc" id="L1219">  }</span>

  private void jsonCommandShutdown(final JsonCommandPacket packet,
                                   final ShutdownRequestJsonPacket json)
      throws OpenR66RunnerErrorException, OpenR66ProtocolSystemException {
<span class="nc" id="L1224">    int rank = -1;</span>
<span class="nc bnc" id="L1225" title="All 4 branches missed.">    if (session.getRunner() != null &amp;&amp; session.getRunner().isInTransfer()) {</span>
<span class="nc" id="L1226">      rank = json.getRank();</span>
    }
<span class="nc" id="L1228">    final R66Result result =</span>
        new R66Result(new OpenR66ProtocolShutdownException(), session, true,
<span class="nc" id="L1230">                      ErrorCode.Shutdown, session.getRunner());</span>
<span class="nc" id="L1231">    result.setOther(packet);</span>
<span class="nc" id="L1232">    rank = shutdownRequest(result, rank);</span>
<span class="nc bnc" id="L1233" title="All 2 branches missed.">    if (rank &gt;= 0) {</span>
<span class="nc" id="L1234">      json.setRank(rank);</span>
<span class="nc" id="L1235">      final JsonCommandPacket valid =</span>
<span class="nc" id="L1236">          new JsonCommandPacket(json, result.getCode().getCode(),</span>
                                LocalPacketFactory.SHUTDOWNPACKET);
      try {
<span class="nc" id="L1239">        ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid,</span>
                                              false);
<span class="nc" id="L1241">      } catch (final OpenR66ProtocolPacketException ignored) {</span>
        // ignore
<span class="nc" id="L1243">      }</span>
    }
<span class="nc" id="L1245">    shutdownLocalChannel();</span>
<span class="nc" id="L1246">  }</span>

  private void jsonCommandEmptyJson(final JsonCommandPacket packet) {
    final JsonPacket json;
<span class="nc" id="L1250">    final ErrorCode code = ErrorCode.CommandNotFound;</span>
<span class="nc" id="L1251">    final R66Result resulttest =</span>
<span class="nc" id="L1252">        new R66Result(session, true, code, session.getRunner());</span>
<span class="nc" id="L1253">    json = new JsonPacket();</span>
<span class="nc" id="L1254">    json.setComment(&quot;Invalid command&quot;);</span>
<span class="nc" id="L1255">    json.setRequestUserPacket(packet.getTypeValid());</span>
<span class="nc" id="L1256">    final JsonCommandPacket valid =</span>
<span class="nc" id="L1257">        new JsonCommandPacket(json, resulttest.getCode().getCode(),</span>
                              LocalPacketFactory.REQUESTUSERPACKET);
<span class="nc" id="L1259">    resulttest.setOther(packet);</span>
<span class="nc" id="L1260">    localChannelReference.validateRequest(resulttest);</span>
    try {
<span class="nc" id="L1262">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid,</span>
                                            false);
<span class="nc" id="L1264">    } catch (final OpenR66ProtocolPacketException ignored) {</span>
      // ignore
<span class="nc" id="L1266">    }</span>
<span class="nc" id="L1267">    session.setStatus(99);</span>
<span class="nc" id="L1268">    localChannelReference.close();</span>
<span class="nc" id="L1269">  }</span>

  /**
   * Shutdown Local Channel after the request is shutdown
   */
  private void shutdownLocalChannel() {
<span class="nc" id="L1275">    session.setStatus(26);</span>
<span class="nc" id="L1276">    logger.warn(</span>
        &quot;Will Close Local from Network Channel since Remote shutdown received&quot;);
<span class="nc" id="L1278">    ChannelCloseTimer.closeFutureTransaction(</span>
<span class="nc" id="L1279">        localChannelReference.getServerHandler());</span>
    try {
<span class="nc" id="L1281">      Thread.sleep(Configuration.WAITFORNETOP);</span>
<span class="nc" id="L1282">    } catch (final InterruptedException e) {//NOSONAR</span>
<span class="nc" id="L1283">      SysErrLogger.FAKE_LOGGER.ignoreLog(e);</span>
<span class="nc" id="L1284">      Thread.currentThread().interrupt();</span>
<span class="nc" id="L1285">    }</span>
<span class="nc" id="L1286">    final NetworkChannelReference ncr =</span>
<span class="nc" id="L1287">        localChannelReference.getNetworkChannelObject();</span>
<span class="nc" id="L1288">    ncr.lockNetwork();</span>
    try {
<span class="nc" id="L1290">      final long time = ncr.shutdownAllowed();</span>
<span class="nc bnc" id="L1291" title="All 2 branches missed.">      if (time == 0) {</span>
<span class="nc" id="L1292">        logger.info(&quot;Will close networkChannel {}&quot;, ncr.nbLocalChannels());</span>
<span class="nc" id="L1293">        NetworkTransaction.shuttingDownNetworkChannel(ncr);</span>
<span class="nc" id="L1294">        NetworkTransaction.shuttingdownNetworkChannelsPerHostID(</span>
<span class="nc" id="L1295">            ncr.getHostId());</span>
      }
    } finally {
<span class="nc" id="L1298">      ncr.unlockNetwork();</span>
    }
<span class="nc" id="L1300">  }</span>

  /**
   * Shutdown the current request with an optional rank to set for future
   * restart
   *
   * @param result the result to be associated in finalization
   * @param rank the future rank to set if restart (&lt;0 if none)
   *
   * @return the rank to set for future restart if any (&lt; 0 if none)
   *
   * @throws OpenR66RunnerErrorException
   * @throws OpenR66ProtocolSystemException
   */
  private int shutdownRequest(final R66Result result, final int rank)
      throws OpenR66RunnerErrorException, OpenR66ProtocolSystemException {
<span class="nc" id="L1316">    session.newState(SHUTDOWN);</span>
<span class="nc" id="L1317">    logger.warn(</span>
        &quot;Shutdown received so Will close channel&quot; + localChannelReference);
<span class="nc bnc" id="L1319" title="All 4 branches missed.">    if (session.getRunner() != null &amp;&amp; session.getRunner().isInTransfer()) {</span>
<span class="nc" id="L1320">      final DbTaskRunner runner = session.getRunner();</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">      if (rank &gt;= 0) {</span>
        // Save last rank from remote point of view
<span class="nc" id="L1323">        runner.setRankAtStartup(rank);</span>
<span class="nc" id="L1324">        session.setFinalizeTransfer(false, result);</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">      } else if (!session.isSender()) {</span>
        // is receiver so informs back for the rank to use next time
<span class="nc" id="L1327">        final int newrank = runner.getRank();</span>
        try {
<span class="nc" id="L1329">          runner.saveStatus();</span>
<span class="nc" id="L1330">        } catch (final OpenR66RunnerErrorException ignored) {</span>
          // ignore
<span class="nc" id="L1332">        }</span>
<span class="nc" id="L1333">        session.setFinalizeTransfer(false, result);</span>
<span class="nc" id="L1334">        return newrank;</span>
      } else {
<span class="nc" id="L1336">        session.setFinalizeTransfer(false, result);</span>
      }
<span class="nc" id="L1338">    } else {</span>
<span class="nc" id="L1339">      session.setFinalizeTransfer(false, result);</span>
    }
<span class="nc" id="L1341">    return -1;</span>
  }

  /**
   * Get or Set the bandwidth configuration
   *
   * @param setter
   * @param writeglobal
   * @param readglobal
   * @param writesession
   * @param readsession
   *
   * @return the 4 current values for the bandwidth (in the same order)
   *
   * @throws OpenR66ProtocolNotAuthenticatedException
   */
  public final long[] bandwidth(final boolean setter, final long writeglobal,
                                final long readglobal, final long writesession,
                                final long readsession)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolNoCorrectAuthenticationException {
    // Authentication must be the local server or LIMIT authorization
    try {
<span class="fc bfc" id="L1364" title="All 2 branches covered.">      if (!session.getAuth().getUser().equals(</span>
<span class="fc" id="L1365">          Configuration.configuration.getHostId(session.getAuth().isSsl())) &amp;&amp;</span>
<span class="pc bpc" id="L1366" title="1 of 2 branches missed.">          !session.getAuth().isValidRole(ROLE.LIMIT)) {</span>
<span class="nc" id="L1367">        throw new OpenR66ProtocolNoCorrectAuthenticationException(</span>
            NOT_CORRECTLY_AUTHENTICATED);
      }
<span class="nc" id="L1370">    } catch (final OpenR66ProtocolNoSslException e1) {</span>
<span class="nc" id="L1371">      throw new OpenR66ProtocolNotAuthenticatedException(</span>
          NOT_CORRECTLY_AUTHENTICATED_SINCE_SSL_IS_NOT_SUPPORTED, e1);
<span class="fc" id="L1373">    }</span>
<span class="fc bfc" id="L1374" title="All 2 branches covered.">    if (!setter) {</span>
      // request of current values
      // Now answer
    } else {
<span class="fc" id="L1378">      long wgl = (writeglobal / 10) * 10;</span>
<span class="fc" id="L1379">      long rgl = (readglobal / 10) * 10;</span>
<span class="fc" id="L1380">      long wsl = (writesession / 10) * 10;</span>
<span class="fc" id="L1381">      long rsl = (readsession / 10) * 10;</span>
<span class="pc bpc" id="L1382" title="1 of 2 branches missed.">      if (wgl &lt; 0) {</span>
<span class="nc" id="L1383">        wgl = Configuration.configuration.getServerGlobalWriteLimit();</span>
      }
<span class="pc bpc" id="L1385" title="1 of 2 branches missed.">      if (rgl &lt; 0) {</span>
<span class="nc" id="L1386">        rgl = Configuration.configuration.getServerGlobalReadLimit();</span>
      }
<span class="pc bpc" id="L1388" title="1 of 2 branches missed.">      if (wsl &lt; 0) {</span>
<span class="nc" id="L1389">        wsl = Configuration.configuration.getServerChannelWriteLimit();</span>
      }
<span class="pc bpc" id="L1391" title="1 of 2 branches missed.">      if (rsl &lt; 0) {</span>
<span class="nc" id="L1392">        rsl = Configuration.configuration.getServerChannelReadLimit();</span>
      }
<span class="pc bpc" id="L1394" title="1 of 2 branches missed.">      if (Configuration.configuration.getR66Mib() != null) {</span>
<span class="nc" id="L1395">        Configuration.configuration.getR66Mib().notifyWarning(</span>
            &quot;Change Bandwidth Limit Order received: Global &quot; + wgl + ':' + rgl +
            &quot; (W:R) Local &quot; + wsl + ':' + rsl + &quot; (W:R)&quot;,
<span class="nc" id="L1398">            session.getAuth().getUser());</span>
      }
<span class="fc" id="L1400">      Configuration.configuration.changeNetworkLimit(wgl, rgl, wsl, rsl,</span>
<span class="fc" id="L1401">                                                     Configuration.configuration.getDelayLimit());</span>
      // Now answer
    }
<span class="fc" id="L1404">    return new long[] {</span>
<span class="fc" id="L1405">        Configuration.configuration.getServerGlobalWriteLimit(),</span>
<span class="fc" id="L1406">        Configuration.configuration.getServerGlobalReadLimit(),</span>
<span class="fc" id="L1407">        Configuration.configuration.getServerChannelWriteLimit(),</span>
<span class="fc" id="L1408">        Configuration.configuration.getServerChannelReadLimit()</span>
    };
  }

  /**
   * Import configuration from files as parameter
   *
   * @param json
   *
   * @return the packet to answer
   *
   * @throws OpenR66ProtocolNotAuthenticatedException
   * @throws OpenR66ProtocolSystemException
   */
  public final ConfigImportResponseJsonPacket configImport(
      final ConfigImportJsonPacket json)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolNoCorrectAuthenticationException,
             OpenR66ProtocolSystemException {
<span class="fc" id="L1427">    session.newState(VALIDOTHER);</span>
    // Authentication must be the local server or CONFIGADMIN authorization
    try {
<span class="pc bpc" id="L1430" title="1 of 2 branches missed.">      if (!session.getAuth().getUser().equals(</span>
<span class="fc" id="L1431">          Configuration.configuration.getHostId(session.getAuth().isSsl())) &amp;&amp;</span>
<span class="nc bnc" id="L1432" title="All 2 branches missed.">          !session.getAuth().isValidRole(ROLE.CONFIGADMIN)) {</span>
<span class="nc" id="L1433">        throw new OpenR66ProtocolNoCorrectAuthenticationException(</span>
            NOT_CORRECTLY_AUTHENTICATED);
      }
<span class="nc" id="L1436">    } catch (final OpenR66ProtocolNoSslException e1) {</span>
<span class="nc" id="L1437">      throw new OpenR66ProtocolNotAuthenticatedException(</span>
          NOT_CORRECTLY_AUTHENTICATED_SINCE_SSL_IS_NOT_SUPPORTED, e1);
<span class="fc" id="L1439">    }</span>
<span class="pc bpc" id="L1440" title="1 of 2 branches missed.">    if (Configuration.configuration.getR66Mib() != null) {</span>
<span class="nc" id="L1441">      Configuration.configuration.getR66Mib().notifyWarning(</span>
<span class="nc" id="L1442">          &quot;Import Configuration Order received&quot;, session.getAuth().getUser());</span>
    }
    // purgehost, purgerule, purgebusiness, purgealias, purgeroles, host, rule, business, alias, roles
<span class="fc" id="L1445">    final boolean bhostPurge = json.isPurgehost();</span>
<span class="fc" id="L1446">    final boolean brulePurge = json.isPurgerule();</span>
<span class="fc" id="L1447">    final boolean bbusinessPurge = json.isPurgebusiness();</span>
<span class="fc" id="L1448">    final boolean baliasPurge = json.isPurgealias();</span>
<span class="fc" id="L1449">    final boolean brolesPurge = json.isPurgeroles();</span>
<span class="fc" id="L1450">    boolean importedhost = false;</span>
<span class="fc" id="L1451">    boolean importedrule = false;</span>
<span class="fc" id="L1452">    boolean importedbusiness = false;</span>
<span class="fc" id="L1453">    boolean importedalias = false;</span>
<span class="fc" id="L1454">    boolean importedroles = false;</span>
<span class="fc" id="L1455">    String shost = json.getHost();</span>
<span class="fc" id="L1456">    String srule = json.getRule();</span>
<span class="fc" id="L1457">    String sbusiness = json.getBusiness();</span>
<span class="fc" id="L1458">    String salias = json.getAlias();</span>
<span class="fc" id="L1459">    String sroles = json.getRoles();</span>
<span class="fc" id="L1460">    final long hostid = json.getHostid();</span>
<span class="fc" id="L1461">    final long ruleid = json.getRuleid();</span>
<span class="fc" id="L1462">    final long businessid = json.getBusinessid();</span>
<span class="fc" id="L1463">    final long aliasid = json.getAliasid();</span>
<span class="fc" id="L1464">    final long roleid = json.getRolesid();</span>

<span class="fc" id="L1466">    localChannelReference.getDbSession();</span>

<span class="fc" id="L1468">    final String remote = session.getAuth().getUser();</span>
<span class="fc" id="L1469">    String local = null;</span>
    try {
<span class="fc" id="L1471">      local = Configuration.configuration.getHostId(session.getAuth().isSsl());</span>
<span class="nc" id="L1472">    } catch (final OpenR66ProtocolNoSslException e1) {</span>
<span class="nc" id="L1473">      logger.warn(&quot;Local Ssl Host is unknown&quot; + &quot; : {}&quot;, e1.getMessage());</span>
<span class="fc" id="L1474">    }</span>
<span class="pc bpc" id="L1475" title="5 of 6 branches missed.">    if (shost != null || hostid != ILLEGALVALUE &amp;&amp; local != null) {</span>
<span class="fc" id="L1476">      DbHostAuth[] oldHosts = null;</span>
      final DbTaskRunner runner;
<span class="pc bpc" id="L1478" title="3 of 4 branches missed.">      if (hostid != ILLEGALVALUE &amp;&amp; local != null) {</span>
        // need to find the local filename
        try {
<span class="nc" id="L1481">          runner = new DbTaskRunner(session, null, hostid, remote, local);</span>
<span class="nc" id="L1482">          shost = runner.getFullFilePath();</span>
<span class="nc" id="L1483">        } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L1484">          logger.error(RUNNER_TASK_IS_NOT_FOUND + hostid, e);</span>
<span class="nc" id="L1485">          shost = null;</span>
<span class="nc" id="L1486">        } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L1487">          logger.error(FILE_IS_NOT_FOUND + hostid, e);</span>
<span class="nc" id="L1488">          shost = null;</span>
<span class="nc" id="L1489">        }</span>
      }
<span class="pc bpc" id="L1491" title="1 of 2 branches missed.">      if (shost != null) {</span>
<span class="pc bpc" id="L1492" title="1 of 2 branches missed.">        if (bhostPurge) {</span>
          // Need to first delete all entries
          try {
<span class="nc" id="L1495">            oldHosts = DbHostAuth.deleteAll();</span>
<span class="nc" id="L1496">          } catch (final WaarpDatabaseException e) {</span>
            // ignore
<span class="nc" id="L1498">          }</span>
        }
<span class="pc bpc" id="L1500" title="1 of 2 branches missed.">        if (AuthenticationFileBasedConfiguration.loadAuthentication(</span>
            Configuration.configuration, shost)) {
<span class="fc" id="L1502">          importedhost = true;</span>
<span class="fc" id="L1503">          logger.debug(&quot;Host configuration imported from {}&quot;, shost);</span>
        } else {
<span class="nc" id="L1505">          logger.error(&quot;Error in Load Hosts&quot;);</span>
<span class="nc" id="L1506">          importedhost = false;</span>
        }
<span class="pc bpc" id="L1508" title="5 of 6 branches missed.">        if (!importedhost &amp;&amp; bhostPurge &amp;&amp; oldHosts != null) {</span>
<span class="nc bnc" id="L1509" title="All 2 branches missed.">          for (final DbHostAuth dbHost : oldHosts) {</span>
            try {
<span class="nc bnc" id="L1511" title="All 2 branches missed.">              if (!dbHost.exist()) {</span>
<span class="nc" id="L1512">                dbHost.insert();</span>
              }
<span class="nc" id="L1514">            } catch (final WaarpDatabaseException e1) {</span>
              // ignore
<span class="nc" id="L1516">            }</span>
          }
        }
      }
    }
<span class="pc bpc" id="L1521" title="5 of 6 branches missed.">    if (srule != null || ruleid != ILLEGALVALUE &amp;&amp; local != null) {</span>
<span class="fc" id="L1522">      DbRule[] oldRules = null;</span>
      final DbTaskRunner runner;
<span class="pc bpc" id="L1524" title="3 of 4 branches missed.">      if (ruleid != ILLEGALVALUE &amp;&amp; local != null) {</span>
        // need to find the local filename
        try {
<span class="nc" id="L1527">          runner = new DbTaskRunner(session, null, ruleid, remote, local);</span>
<span class="nc" id="L1528">          srule = runner.getFullFilePath();</span>
<span class="nc" id="L1529">        } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L1530">          logger.error(RUNNER_TASK_IS_NOT_FOUND + ruleid, e);</span>
<span class="nc" id="L1531">          srule = null;</span>
<span class="nc" id="L1532">        } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L1533">          logger.error(FILE_IS_NOT_FOUND + hostid, e);</span>
<span class="nc" id="L1534">          srule = null;</span>
<span class="nc" id="L1535">        }</span>
      }
<span class="pc bpc" id="L1537" title="1 of 2 branches missed.">      if (srule != null) {</span>
<span class="pc bpc" id="L1538" title="1 of 2 branches missed.">        if (brulePurge) {</span>
          // Need to first delete all entries
          try {
<span class="nc" id="L1541">            oldRules = DbRule.deleteAll();</span>
<span class="nc" id="L1542">          } catch (final WaarpDatabaseException e) {</span>
            // ignore
<span class="nc" id="L1544">          }</span>
        }
<span class="fc" id="L1546">        final File file = new File(srule);</span>
        try {
<span class="fc" id="L1548">          RuleFileBasedConfiguration.getMultipleFromFile(file);</span>
<span class="fc" id="L1549">          importedrule = true;</span>
<span class="fc" id="L1550">          logger.debug(&quot;Rule configuration imported from {}&quot;, srule);</span>
<span class="nc" id="L1551">        } catch (final WaarpDatabaseNoConnectionException e) {</span>
<span class="nc" id="L1552">          logger.error(&quot;Error: {}&quot;, e.getMessage());</span>
<span class="nc" id="L1553">          importedrule = false;</span>
<span class="nc" id="L1554">        } catch (final WaarpDatabaseSqlException e) {</span>
<span class="nc" id="L1555">          logger.error(&quot;Error&quot;, e);</span>
<span class="nc" id="L1556">          importedrule = false;</span>
<span class="nc" id="L1557">        } catch (final WaarpDatabaseNoDataException e) {</span>
<span class="nc" id="L1558">          logger.error(&quot;Error&quot;, e);</span>
<span class="nc" id="L1559">          importedrule = false;</span>
<span class="nc" id="L1560">        } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L1561">          logger.error(&quot;Error&quot;, e);</span>
<span class="nc" id="L1562">          importedrule = false;</span>
<span class="pc" id="L1563">        }</span>
<span class="pc bpc" id="L1564" title="5 of 6 branches missed.">        if (!importedrule &amp;&amp; brulePurge &amp;&amp; oldRules != null) {</span>
<span class="nc bnc" id="L1565" title="All 2 branches missed.">          for (final DbRule dbRule : oldRules) {</span>
            try {
<span class="nc bnc" id="L1567" title="All 2 branches missed.">              if (!dbRule.exist()) {</span>
<span class="nc" id="L1568">                dbRule.insert();</span>
              }
<span class="nc" id="L1570">            } catch (final WaarpDatabaseException e1) {</span>
              // ignore
<span class="nc" id="L1572">            }</span>
          }
        }
      }
    }
    // load from file ! not from filename ! Moreover: filename might be incorrect =&gt; Must get the remote filename
    // (recv)
<span class="pc bpc" id="L1579" title="11 of 20 branches missed.">    if (sbusiness != null || salias != null || sroles != null ||</span>
        bbusinessPurge || baliasPurge || brolesPurge ||
        (businessid != ILLEGALVALUE || aliasid != ILLEGALVALUE ||
         roleid != ILLEGALVALUE) &amp;&amp; local != null) {
      final DbHostConfiguration host;
      try {
<span class="nc" id="L1585">        host = new DbHostConfiguration(Configuration.configuration.getHostId());</span>
        DbTaskRunner runner;
<span class="nc bnc" id="L1587" title="All 4 branches missed.">        if (businessid != ILLEGALVALUE &amp;&amp; local != null) {</span>
          // need to find the local filename
          try {
<span class="nc" id="L1590">            runner = new DbTaskRunner(session, null, businessid, remote, local);</span>
<span class="nc" id="L1591">            sbusiness = runner.getFullFilePath();</span>
<span class="nc" id="L1592">          } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L1593">            logger.error(RUNNER_TASK_IS_NOT_FOUND + businessid, e);</span>
<span class="nc" id="L1594">            sbusiness = null;</span>
<span class="nc" id="L1595">          } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L1596">            logger.error(FILE_IS_NOT_FOUND + hostid, e);</span>
<span class="nc" id="L1597">            sbusiness = null;</span>
<span class="nc" id="L1598">          }</span>
        }
<span class="nc bnc" id="L1600" title="All 2 branches missed.">        if (sbusiness != null) {</span>
          try {
<span class="nc" id="L1602">            final String content =</span>
<span class="nc" id="L1603">                WaarpStringUtils.readFileException(sbusiness);</span>
<span class="nc" id="L1604">            importedbusiness =</span>
<span class="nc" id="L1605">                host.updateBusiness(Configuration.configuration, content,</span>
                                    bbusinessPurge);
<span class="nc" id="L1607">            logger.debug(&quot;Business configuration imported from {}({})&quot;,</span>
<span class="nc" id="L1608">                         sbusiness, importedbusiness);</span>
<span class="nc" id="L1609">          } catch (final FileTransferException e) {</span>
<span class="nc" id="L1610">            logger.error(&quot;Error&quot;, e);</span>
<span class="nc" id="L1611">            importedbusiness = false;</span>
<span class="nc" id="L1612">          }</span>
        }
<span class="nc bnc" id="L1614" title="All 4 branches missed.">        if (aliasid != ILLEGALVALUE &amp;&amp; local != null) {</span>
          // need to find the local filename
          try {
<span class="nc" id="L1617">            runner = new DbTaskRunner(session, null, aliasid, remote, local);</span>
<span class="nc" id="L1618">            salias = runner.getFullFilePath();</span>
<span class="nc" id="L1619">          } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L1620">            logger.error(RUNNER_TASK_IS_NOT_FOUND + aliasid, e);</span>
<span class="nc" id="L1621">            salias = null;</span>
<span class="nc" id="L1622">          } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L1623">            logger.error(FILE_IS_NOT_FOUND + hostid, e);</span>
<span class="nc" id="L1624">            salias = null;</span>
<span class="nc" id="L1625">          }</span>
        }
<span class="nc bnc" id="L1627" title="All 2 branches missed.">        if (salias != null) {</span>
          try {
<span class="nc" id="L1629">            final String content = WaarpStringUtils.readFileException(salias);</span>
<span class="nc" id="L1630">            importedalias =</span>
<span class="nc" id="L1631">                host.updateAlias(Configuration.configuration, content,</span>
                                 baliasPurge);
<span class="nc" id="L1633">            logger.debug(&quot;Alias configuration imported from {}({})&quot;, salias,</span>
<span class="nc" id="L1634">                         importedalias);</span>
<span class="nc" id="L1635">          } catch (final FileTransferException e) {</span>
<span class="nc" id="L1636">            logger.error(&quot;Error&quot;, e);</span>
<span class="nc" id="L1637">            importedalias = false;</span>
<span class="nc" id="L1638">          }</span>
        }
<span class="nc bnc" id="L1640" title="All 4 branches missed.">        if (roleid != ILLEGALVALUE &amp;&amp; local != null) {</span>
          // need to find the local filename
          try {
<span class="nc" id="L1643">            runner = new DbTaskRunner(session, null, roleid, remote, local);</span>
<span class="nc" id="L1644">            sroles = runner.getFullFilePath();</span>
<span class="nc" id="L1645">          } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L1646">            logger.error(RUNNER_TASK_IS_NOT_FOUND + roleid, e);</span>
<span class="nc" id="L1647">            sroles = null;</span>
<span class="nc" id="L1648">          } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L1649">            logger.error(FILE_IS_NOT_FOUND + hostid, e);</span>
<span class="nc" id="L1650">            sroles = null;</span>
<span class="nc" id="L1651">          }</span>
        }
<span class="nc bnc" id="L1653" title="All 2 branches missed.">        if (sroles != null) {</span>
          try {
<span class="nc" id="L1655">            final String content = WaarpStringUtils.readFileException(sroles);</span>
<span class="nc" id="L1656">            importedroles =</span>
<span class="nc" id="L1657">                host.updateRoles(Configuration.configuration, content,</span>
                                 brolesPurge);
<span class="nc" id="L1659">            logger.debug(&quot;Roles configuration imported from {}({})&quot;, sroles,</span>
<span class="nc" id="L1660">                         importedroles);</span>
<span class="nc" id="L1661">          } catch (final FileTransferException e) {</span>
<span class="nc" id="L1662">            logger.error(&quot;Error&quot;, e);</span>
<span class="nc" id="L1663">            importedroles = false;</span>
<span class="nc" id="L1664">          }</span>
        }
<span class="nc" id="L1666">      } catch (final WaarpDatabaseException e1) {</span>
<span class="nc" id="L1667">        logger.error(&quot;Error while trying to open: &quot; + sbusiness, e1);</span>
<span class="nc" id="L1668">        importedbusiness = false;</span>
<span class="nc" id="L1669">        importedalias = false;</span>
<span class="nc" id="L1670">        importedroles = false;</span>
<span class="nc" id="L1671">      }</span>
    }
    // Now answer
<span class="fc" id="L1674">    final ConfigImportResponseJsonPacket resp =</span>
        new ConfigImportResponseJsonPacket();
<span class="fc" id="L1676">    resp.fromJson(json);</span>
<span class="pc bpc" id="L1677" title="2 of 4 branches missed.">    if (bhostPurge || shost != null) {</span>
<span class="fc" id="L1678">      resp.setPurgedhost(bhostPurge);</span>
<span class="fc" id="L1679">      resp.setImportedhost(importedhost);</span>
    }
<span class="pc bpc" id="L1681" title="2 of 4 branches missed.">    if (brulePurge || srule != null) {</span>
<span class="fc" id="L1682">      resp.setPurgedrule(brulePurge);</span>
<span class="fc" id="L1683">      resp.setImportedrule(importedrule);</span>
    }
<span class="pc bpc" id="L1685" title="2 of 4 branches missed.">    if (bbusinessPurge || sbusiness != null) {</span>
<span class="nc" id="L1686">      resp.setPurgedbusiness(bbusinessPurge);</span>
<span class="nc" id="L1687">      resp.setImportedbusiness(importedbusiness);</span>
    }
<span class="pc bpc" id="L1689" title="2 of 4 branches missed.">    if (baliasPurge || salias != null) {</span>
<span class="nc" id="L1690">      resp.setPurgedalias(baliasPurge);</span>
<span class="nc" id="L1691">      resp.setImportedalias(importedalias);</span>
    }
<span class="pc bpc" id="L1693" title="2 of 4 branches missed.">    if (brolesPurge || sroles != null) {</span>
<span class="nc" id="L1694">      resp.setPurgedroles(brolesPurge);</span>
<span class="nc" id="L1695">      resp.setImportedroles(importedroles);</span>
    }
<span class="fc" id="L1697">    return resp;</span>
  }

  /**
   * Export configuration and return filenames in order
   *
   * @param bhost
   * @param brule
   * @param bbusiness
   * @param balias
   * @param broles
   *
   * @return filenames in order
   *
   * @throws OpenR66ProtocolNotAuthenticatedException
   */
  public final String[] configExport(final boolean bhost, final boolean brule,
                                     final boolean bbusiness,
                                     final boolean balias, final boolean broles)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolNoCorrectAuthenticationException {
    // Authentication must be the local server or CONFIGADMIN authorization
    try {
<span class="pc bpc" id="L1720" title="1 of 2 branches missed.">      if (!session.getAuth().getUser().equals(</span>
<span class="fc" id="L1721">          Configuration.configuration.getHostId(session.getAuth().isSsl())) &amp;&amp;</span>
<span class="nc bnc" id="L1722" title="All 2 branches missed.">          !session.getAuth().isValidRole(ROLE.CONFIGADMIN)) {</span>
<span class="nc" id="L1723">        throw new OpenR66ProtocolNoCorrectAuthenticationException(</span>
            NOT_CORRECTLY_AUTHENTICATED);
      }
<span class="nc" id="L1726">    } catch (final OpenR66ProtocolNoSslException e1) {</span>
<span class="nc" id="L1727">      throw new OpenR66ProtocolNotAuthenticatedException(</span>
          NOT_CORRECTLY_AUTHENTICATED_SINCE_SSL_IS_NOT_SUPPORTED, e1);
<span class="fc" id="L1729">    }</span>
<span class="pc bpc" id="L1730" title="1 of 2 branches missed.">    if (Configuration.configuration.getR66Mib() != null) {</span>
<span class="nc" id="L1731">      Configuration.configuration.getR66Mib().notifyWarning(</span>
<span class="nc" id="L1732">          &quot;Export Configuration Order received&quot;, session.getAuth().getUser());</span>
    }
<span class="fc" id="L1734">    final String dir = Configuration.configuration.getBaseDirectory() +</span>
<span class="fc" id="L1735">                       Configuration.configuration.getArchivePath();</span>
<span class="fc" id="L1736">    return staticConfigExport(dir, bhost, brule, bbusiness, balias, broles);</span>
  }

  /**
   * Export configuration and return filenames in order
   *
   * @param dir
   * @param bhost
   * @param brule
   * @param bbusiness
   * @param balias
   * @param broles
   *
   * @return filenames in order
   */
  public static String[] staticConfigExport(final String dir, boolean bhost,
                                            boolean brule, boolean bbusiness,
                                            boolean balias, boolean broles) {
<span class="fc" id="L1754">    String shost = null;</span>
<span class="fc" id="L1755">    String srule = null;</span>
<span class="fc" id="L1756">    String sbusiness = null;</span>
<span class="fc" id="L1757">    String salias = null;</span>
<span class="fc" id="L1758">    String sroles = null;</span>
<span class="fc" id="L1759">    final String hostname = Configuration.configuration.getHostId();</span>
<span class="pc bpc" id="L1760" title="1 of 2 branches missed.">    if (bhost) {</span>
<span class="fc" id="L1761">      final String filename =</span>
          dir + File.separator + hostname + &quot;_Authentications.xml&quot;;
      try {
<span class="fc" id="L1764">        AuthenticationFileBasedConfiguration.writeXML(</span>
            Configuration.configuration, filename);
<span class="fc" id="L1766">        shost = filename;</span>
<span class="nc" id="L1767">      } catch (final WaarpDatabaseNoConnectionException e) {</span>
<span class="nc" id="L1768">        logger.error(&quot;Error&quot;, e);</span>
<span class="nc" id="L1769">        shost = null;</span>
<span class="nc" id="L1770">        bhost = false;</span>
<span class="nc" id="L1771">      } catch (final OpenR66ProtocolSystemException e) {</span>
<span class="nc" id="L1772">        logger.error(&quot;Error&quot;, e);</span>
<span class="nc" id="L1773">        shost = null;</span>
<span class="nc" id="L1774">        bhost = false;</span>
<span class="pc" id="L1775">      }</span>
    }
<span class="pc bpc" id="L1777" title="1 of 2 branches missed.">    if (brule) {</span>
      try {
<span class="fc" id="L1779">        srule = RuleFileBasedConfiguration.writeOneXml(dir, hostname);</span>
<span class="nc" id="L1780">      } catch (final WaarpDatabaseNoConnectionException e1) {</span>
<span class="nc" id="L1781">        logger.error(&quot;Error&quot;, e1);</span>
<span class="nc" id="L1782">        srule = null;</span>
<span class="nc" id="L1783">        brule = false;</span>
<span class="nc" id="L1784">      } catch (final OpenR66ProtocolSystemException e1) {</span>
<span class="nc" id="L1785">        logger.error(&quot;Error&quot;, e1);</span>
<span class="nc" id="L1786">        srule = null;</span>
<span class="nc" id="L1787">        brule = false;</span>
<span class="pc" id="L1788">      }</span>
    }
<span class="pc bpc" id="L1790" title="2 of 6 branches missed.">    if (bbusiness || balias || broles) {</span>
      try {
<span class="fc" id="L1792">        final DbHostConfiguration host =</span>
<span class="fc" id="L1793">            new DbHostConfiguration(Configuration.configuration.getHostId());</span>
<span class="pc bpc" id="L1794" title="1 of 2 branches missed.">        if (bbusiness) {</span>
<span class="fc" id="L1795">          sbusiness = host.getBusiness();</span>
<span class="pc bpc" id="L1796" title="1 of 2 branches missed.">          if (sbusiness != null) {</span>
<span class="fc" id="L1797">            final String filename =</span>
                dir + File.separator + hostname + &quot;_Business.xml&quot;;
<span class="fc" id="L1799">            FileOutputStream outputStream = null;</span>
            try {
<span class="fc" id="L1801">              outputStream = new FileOutputStream(filename);</span>
<span class="fc" id="L1802">              outputStream.write(sbusiness.getBytes(WaarpStringUtils.UTF8));</span>
            } finally {
<span class="fc" id="L1804">              FileUtils.close(outputStream);</span>
            }
<span class="fc" id="L1806">            sbusiness = filename;</span>
          }
<span class="pc bpc" id="L1808" title="1 of 2 branches missed.">          bbusiness = sbusiness != null;</span>
        }
<span class="pc bpc" id="L1810" title="1 of 2 branches missed.">        if (balias) {</span>
<span class="fc" id="L1811">          salias = host.getAliases();</span>
<span class="pc bpc" id="L1812" title="1 of 2 branches missed.">          if (salias != null) {</span>
<span class="fc" id="L1813">            final String filename =</span>
                dir + File.separator + hostname + &quot;_Aliases.xml&quot;;
<span class="fc" id="L1815">            FileOutputStream outputStream = null;</span>
            try {
<span class="fc" id="L1817">              outputStream = new FileOutputStream(filename);</span>
<span class="fc" id="L1818">              outputStream.write(salias.getBytes(WaarpStringUtils.UTF8));</span>
            } finally {
<span class="fc" id="L1820">              FileUtils.close(outputStream);</span>
            }
<span class="fc" id="L1822">            salias = filename;</span>
          }
<span class="pc bpc" id="L1824" title="1 of 2 branches missed.">          balias = salias != null;</span>
        }
<span class="pc bpc" id="L1826" title="1 of 2 branches missed.">        if (broles) {</span>
<span class="fc" id="L1827">          sroles = host.getRoles();</span>
<span class="pc bpc" id="L1828" title="1 of 2 branches missed.">          if (sroles != null) {</span>
<span class="fc" id="L1829">            final String filename =</span>
                dir + File.separator + hostname + &quot;_Roles.xml&quot;;
<span class="fc" id="L1831">            FileOutputStream outputStream = null;</span>
            try {
<span class="fc" id="L1833">              outputStream = new FileOutputStream(filename);</span>
<span class="fc" id="L1834">              outputStream.write(sroles.getBytes(WaarpStringUtils.UTF8));</span>
            } finally {
<span class="fc" id="L1836">              FileUtils.close(outputStream);</span>
            }
<span class="fc" id="L1838">            sroles = filename;</span>
          }
<span class="pc bpc" id="L1840" title="1 of 2 branches missed.">          broles = sroles != null;</span>
        }
<span class="nc" id="L1842">      } catch (final WaarpDatabaseNoConnectionException e1) {</span>
<span class="nc" id="L1843">        logger.error(&quot;Error&quot;, e1);</span>
<span class="nc" id="L1844">      } catch (final WaarpDatabaseSqlException e1) {</span>
<span class="nc" id="L1845">        logger.error(&quot;Error&quot;, e1);</span>
<span class="nc" id="L1846">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L1847">        logger.error(&quot;Error&quot;, e);</span>
<span class="nc" id="L1848">      } catch (final IOException e) {</span>
<span class="nc" id="L1849">        logger.error(&quot;Error&quot;, e);</span>
<span class="pc" id="L1850">      }</span>
    }
    // Now answer
<span class="fc" id="L1853">    return new String[] { shost, srule, sbusiness, salias, sroles };</span>
  }

  /**
   * Request to restart a transfer
   *
   * @param reqd requested
   * @param reqr requester
   * @param id id of the Transfer
   * @param date time start if any
   *
   * @return the Result including the error code to use in return
   *
   * @throws OpenR66ProtocolNotAuthenticatedException
   */
  public final R66Result requestRestart(final String reqd, final String reqr,
                                        final long id, final Date date)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolNoCorrectAuthenticationException {
<span class="fc" id="L1872">    ErrorCode returnCode = ErrorCode.Internal;</span>
    R66Result resulttest;
    // should be from the local server or from an authorized hosts: TRANSFER
    try {
<span class="pc bpc" id="L1876" title="1 of 2 branches missed.">      if (!session.getAuth().getUser().equals(</span>
<span class="fc" id="L1877">          Configuration.configuration.getHostId(session.getAuth().isSsl())) &amp;&amp;</span>
<span class="nc bnc" id="L1878" title="All 2 branches missed.">          !session.getAuth().isValidRole(ROLE.TRANSFER)) {</span>
<span class="nc" id="L1879">        throw new OpenR66ProtocolNoCorrectAuthenticationException(</span>
            NOT_CORRECTLY_AUTHENTICATED);
      }
<span class="nc" id="L1882">    } catch (final OpenR66ProtocolNoSslException e1) {</span>
<span class="nc" id="L1883">      throw new OpenR66ProtocolNotAuthenticatedException(</span>
          NOT_CORRECTLY_AUTHENTICATED_SINCE_SSL_IS_NOT_SUPPORTED, e1);
<span class="fc" id="L1885">    }</span>
    // Try to validate a restarting transfer
    // validLimit on requested side
<span class="fc" id="L1888">    if (Configuration.configuration.getConstraintLimitHandler()</span>
<span class="pc bpc" id="L1889" title="1 of 2 branches missed.">                                   .checkConstraints()) {</span>
<span class="nc" id="L1890">      logger.error(</span>
          &quot;Limit exceeded {} while asking to relaunch a task&quot; + reqd + ':' +
          reqr + ':' + id,
<span class="nc" id="L1893">          Configuration.configuration.getConstraintLimitHandler().lastAlert);</span>
<span class="nc" id="L1894">      session.setStatus(100);</span>
<span class="nc" id="L1895">      returnCode = ErrorCode.ServerOverloaded;</span>
<span class="nc" id="L1896">      resulttest = new R66Result(null, session, true, returnCode, null);</span>
    } else {
      // Try to validate a restarting transfer
      // header = ?; middle = requested+blank+requester+blank+specialId
      // note: might contains one more argument = time to reschedule in yyyyMMddHHmmss format
<span class="pc bpc" id="L1901" title="3 of 6 branches missed.">      if (reqd == null || reqr == null || id == ILLEGALVALUE) {</span>
        // not enough args
<span class="nc" id="L1903">        returnCode = ErrorCode.IncorrectCommand;</span>
<span class="nc" id="L1904">        resulttest = new R66Result(</span>
            new OpenR66ProtocolBusinessRemoteFileNotFoundException(
                &quot;Not enough arguments&quot;), session, true, returnCode, null);
      } else {
<span class="fc" id="L1908">        DbTaskRunner taskRunner = null;</span>
        try {
<span class="fc" id="L1910">          localChannelReference.getDbSession();</span>
<span class="nc" id="L1911">          taskRunner = new DbTaskRunner(session, null, id, reqr, reqd);</span>
          final Timestamp timestart;
<span class="nc bnc" id="L1913" title="All 2 branches missed.">          if (date != null) {</span>
            // time to reschedule in yyyyMMddHHmmss format
<span class="nc" id="L1915">            logger.debug(&quot;Debug: restart with {}&quot;, date);</span>
<span class="nc" id="L1916">            timestart = new Timestamp(date.getTime());</span>
<span class="nc" id="L1917">            taskRunner.setStart(timestart);</span>
          }
<span class="nc" id="L1919">          final LocalChannelReference lcr =</span>
<span class="nc" id="L1920">              Configuration.configuration.getLocalTransaction().getFromRequest(</span>
                  reqd + ' ' + reqr + ' ' + id);
          // since it comes from a request transfer, cannot redo it
<span class="nc bnc" id="L1923" title="All 2 branches missed.">          if (logger.isInfoEnabled()) {</span>
<span class="nc" id="L1924">            logger.info(&quot;Will try to restart: {}&quot;, taskRunner.toShortString());</span>
          }
<span class="nc" id="L1926">          resulttest = TransferUtils.restartTransfer(taskRunner, lcr);</span>
<span class="nc" id="L1927">          returnCode = resulttest.getCode();</span>
<span class="fc" id="L1928">        } catch (final WaarpDatabaseException e1) {</span>
<span class="fc" id="L1929">          returnCode = ErrorCode.Internal;</span>
<span class="fc" id="L1930">          resulttest =</span>
              new R66Result(new OpenR66DatabaseGlobalException(e1), session,
                            true, returnCode, taskRunner);
<span class="nc" id="L1933">        }</span>
      }
    }
<span class="fc" id="L1936">    return resulttest;</span>
  }

  /**
   * @param code
   *
   * @return True if the code is an OK code and not an error
   */
  public final boolean isCodeValid(final ErrorCode code) {
<span class="fc bfc" id="L1945" title="All 2 branches covered.">    switch (code) {</span>
      case CompleteOk:
      case InitOk:
      case PostProcessingOk:
      case PreProcessingOk:
      case QueryAlreadyFinished:
      case QueryStillRunning:
      case Running:
      case TransferOk:
<span class="fc" id="L1954">        return true;</span>
      case BadAuthent:
      case CanceledTransfer:
      case CommandNotFound:
      case ConnectionImpossible:
      case Disconnection:
      case ExternalOp:
      case FileNotAllowed:
      case FileNotFound:
      case FinalOp:
      case IncorrectCommand:
      case Internal:
      case LoopSelfRequestedHost:
      case MD5Error:
      case NotKnownHost:
      case PassThroughMode:
      case QueryRemotelyUnknown:
      case RemoteError:
      case RemoteShutdown:
      case ServerOverloaded:
      case Shutdown:
      case SizeNotAllowed:
      case StoppedTransfer:
      case TransferError:
      case Unimplemented:
      case Unknown:
      case Warning:
      default:
<span class="fc" id="L1982">        return false;</span>
    }
  }

  /**
   * Purge the logs as required
   *
   * @param purge
   * @param clean
   * @param start
   * @param stop
   * @param startid
   * @param stopid
   * @param rule
   * @param request
   * @param pending
   * @param transfer
   * @param done
   * @param error
   * @param isPurge
   *
   * @return an array of Strings as: filename, nb of exported, nb of purged
   *
   * @throws OpenR66ProtocolNotAuthenticatedException
   * @throws OpenR66ProtocolBusinessException
   */
  public final String[] logPurge(final boolean purge, final boolean clean,
                                 final Timestamp start, final Timestamp stop,
                                 final String startid, String stopid,
                                 final String rule, final String request,
                                 final boolean pending, final boolean transfer,
                                 final boolean done, final boolean error,
                                 final boolean isPurge)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolBusinessException {
    // should be from the local server or from an authorized hosts: LOGCONTROL
    try {
<span class="pc bpc" id="L2019" title="1 of 2 branches missed.">      if (!session.getAuth().getUser().equals(</span>
<span class="fc" id="L2020">          Configuration.configuration.getHostId(session.getAuth().isSsl())) &amp;&amp;</span>
<span class="nc bnc" id="L2021" title="All 2 branches missed.">          !session.getAuth().isValidRole(ROLE.LOGCONTROL)) {</span>
<span class="nc" id="L2022">        throw new OpenR66ProtocolNoCorrectAuthenticationException(</span>
            NOT_CORRECTLY_AUTHENTICATED);
      }
<span class="nc" id="L2025">    } catch (final OpenR66ProtocolNoSslException e1) {</span>
<span class="nc" id="L2026">      throw new OpenR66ProtocolNotAuthenticatedException(</span>
          NOT_CORRECTLY_AUTHENTICATED_SINCE_SSL_IS_NOT_SUPPORTED, e1);
<span class="fc" id="L2028">    }</span>
<span class="pc bpc" id="L2029" title="1 of 2 branches missed.">    final DbSession dbSession =</span>
<span class="pc" id="L2030">        localChannelReference != null? localChannelReference.getDbSession() :</span>
<span class="pc" id="L2031">            admin.getSession();</span>
    // first clean if ask
<span class="pc bpc" id="L2033" title="1 of 2 branches missed.">    if (clean) {</span>
      // Update all UpdatedInfo to DONE
      // where GlobalLastStep = ALLDONETASK and status = CompleteOk
      try {
<span class="fc" id="L2037">        DbTaskRunner.changeFinishedToDone();</span>
<span class="nc" id="L2038">      } catch (final WaarpDatabaseNoConnectionException e) {</span>
<span class="nc" id="L2039">        logger.warn(&quot;Clean cannot be done {}&quot;, e.getMessage());</span>
<span class="fc" id="L2040">      }</span>
    }
    // create export of log and optionally purge them from database
<span class="fc" id="L2043">    final String filename = Configuration.configuration.getBaseDirectory() +</span>
<span class="fc" id="L2044">                            Configuration.configuration.getArchivePath() +</span>
                            DirInterface.SEPARATOR +
<span class="fc" id="L2046">                            Configuration.configuration.getHostId() + '_' +</span>
<span class="fc" id="L2047">                            System.currentTimeMillis() + &quot;_runners.xml&quot;;</span>
    NbAndSpecialId nb;
<span class="fc" id="L2049">    DbPreparedStatement getValid = null;</span>
    try {
<span class="fc" id="L2051">      getValid = DbTaskRunner.getFilterPrepareStatement(dbSession, 0,</span>
                                                        // 0 means no limit
                                                        true, startid, stopid,
                                                        start, stop, rule,
                                                        request, pending,
                                                        transfer, error, done,
                                                        false);
<span class="fc" id="L2058">      nb = DbTaskRunner.writeXMLWriter(getValid, filename);</span>
<span class="nc" id="L2059">    } catch (final WaarpDatabaseNoConnectionException e1) {</span>
<span class="nc" id="L2060">      throw new OpenR66ProtocolBusinessException(e1);</span>
<span class="nc" id="L2061">    } catch (final WaarpDatabaseSqlException e1) {</span>
<span class="nc" id="L2062">      throw new OpenR66ProtocolBusinessException(e1);</span>
    } finally {
<span class="pc bpc" id="L2064" title="1 of 2 branches missed.">      if (getValid != null) {</span>
<span class="fc" id="L2065">        getValid.realClose();</span>
      }
    }

    // in case of purge
<span class="fc" id="L2070">    int npurge = 0;</span>
<span class="pc bpc" id="L2071" title="3 of 8 branches missed.">    if (nb != null &amp;&amp; nb.nb &gt; 0 &amp;&amp; (purge || isPurge)) {</span>
      // purge in same interval all runners with globallaststep
      // as ALLDONETASK or ERRORTASK
<span class="pc bpc" id="L2074" title="1 of 2 branches missed.">      if (Configuration.configuration.getR66Mib() != null) {</span>
<span class="nc" id="L2075">        Configuration.configuration.getR66Mib()</span>
<span class="nc" id="L2076">                                   .notifyWarning(&quot;Purge Log Order received&quot;,</span>
<span class="nc" id="L2077">                                                  session.getAuth().getUser());</span>
      }
      try {
<span class="pc bpc" id="L2080" title="1 of 2 branches missed.">        if (stopid != null) {</span>
<span class="nc" id="L2081">          final long newstopid = Long.parseLong(stopid);</span>
<span class="nc bnc" id="L2082" title="All 2 branches missed.">          if (nb.higherSpecialId &lt; newstopid) {</span>
<span class="nc" id="L2083">            stopid = Long.toString(nb.higherSpecialId);</span>
          }
<span class="nc" id="L2085">        } else {</span>
<span class="fc" id="L2086">          stopid = Long.toString(nb.higherSpecialId);</span>
        }
        // not pending or in transfer
<span class="fc" id="L2089">        npurge =</span>
<span class="fc" id="L2090">            DbTaskRunner.purgeLogPrepareStatement(dbSession, startid, stopid,</span>
                                                  start, stop, rule, request,
                                                  false, false, error, done,
                                                  false);
<span class="nc" id="L2094">      } catch (final WaarpDatabaseNoConnectionException e) {</span>
<span class="nc" id="L2095">        throw new OpenR66ProtocolBusinessException(e);</span>
<span class="nc" id="L2096">      } catch (final WaarpDatabaseSqlException e) {</span>
<span class="nc" id="L2097">        throw new OpenR66ProtocolBusinessException(e);</span>
<span class="fc" id="L2098">      }</span>
    }
<span class="pc bpc" id="L2100" title="1 of 2 branches missed.">    return new String[] {</span>
<span class="pc" id="L2101">        filename, nb != null? Long.toString(nb.nb) : &quot;0&quot;, Long.toString(npurge)</span>
    };
  }

  /**
   * Stop or Cancel a transfer.
   *
   * Warning use stopTransfer or cancelTransfer instead.
   *
   * @param type
   * @param reqd
   * @param reqr
   * @param id
   *
   * @return the Result to answer
   *
   * @throws OpenR66ProtocolNotAuthenticatedException
   */
  public final R66Result stopOrCancel(final byte type, final String reqd,
                                      final String reqr, final long id)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolNoCorrectAuthenticationException {
    // should be from the local server or from an authorized hosts: SYSTEM
    try {
<span class="pc bpc" id="L2125" title="1 of 2 branches missed.">      if (!session.getAuth().getUser().equals(</span>
<span class="fc" id="L2126">          Configuration.configuration.getHostId(session.getAuth().isSsl())) &amp;&amp;</span>
<span class="nc bnc" id="L2127" title="All 2 branches missed.">          !session.getAuth().isValidRole(ROLE.SYSTEM)) {</span>
<span class="nc" id="L2128">        throw new OpenR66ProtocolNoCorrectAuthenticationException(</span>
            NOT_CORRECTLY_AUTHENTICATED);
      }
<span class="nc" id="L2131">    } catch (final OpenR66ProtocolNoSslException e1) {</span>
<span class="nc" id="L2132">      throw new OpenR66ProtocolNotAuthenticatedException(</span>
          NOT_CORRECTLY_AUTHENTICATED_SINCE_SSL_IS_NOT_SUPPORTED, e1);
<span class="fc" id="L2134">    }</span>
    final R66Result resulttest;
<span class="fc" id="L2136">    final String key = reqd + ' ' + reqr + ' ' + id;</span>
    // header = ?; middle = requested+blank+requester+blank+specialId
<span class="fc" id="L2138">    final LocalChannelReference lcr =</span>
<span class="fc" id="L2139">        Configuration.configuration.getLocalTransaction().getFromRequest(key);</span>
    // stop the current transfer
<span class="fc bfc" id="L2141" title="All 2 branches covered.">    final ErrorCode code =</span>
        type == LocalPacketFactory.STOPPACKET? ErrorCode.StoppedTransfer :
            ErrorCode.CanceledTransfer;
<span class="pc bpc" id="L2144" title="1 of 2 branches missed.">    if (lcr != null) {</span>
<span class="nc" id="L2145">      int rank = 0;</span>
<span class="nc bnc" id="L2146" title="All 4 branches missed.">      if (code == ErrorCode.StoppedTransfer &amp;&amp; lcr.getSession() != null) {</span>
<span class="nc" id="L2147">        final DbTaskRunner taskRunner = lcr.getSession().getRunner();</span>
<span class="nc bnc" id="L2148" title="All 2 branches missed.">        if (taskRunner != null) {</span>
<span class="nc" id="L2149">          rank = taskRunner.getRank();</span>
        }
      }
<span class="nc" id="L2152">      session.newState(ERROR);</span>
<span class="nc" id="L2153">      final ErrorPacket error =</span>
<span class="nc" id="L2154">          new ErrorPacket(code.name() + ' ' + rank, code.getCode(),</span>
                          ErrorPacket.FORWARDCLOSECODE);
      try {
        // inform local instead of remote
<span class="nc" id="L2158">        LocalServerHandler.channelRead0(lcr, error);</span>
<span class="nc" id="L2159">      } catch (final Exception e) {</span>
<span class="nc" id="L2160">        logger.warn(&quot;Write local packet error&quot; + &quot; : {}&quot;, e.getMessage());</span>
<span class="nc" id="L2161">      }</span>
<span class="nc" id="L2162">      resulttest = new R66Result(session, true, ErrorCode.CompleteOk,</span>
<span class="nc" id="L2163">                                 session.getRunner());</span>
<span class="nc" id="L2164">    } else {</span>
      // Transfer is not running
      // but maybe need action on database
<span class="pc bpc" id="L2167" title="1 of 2 branches missed.">      if (stopOrCancelRunner(id, reqd, reqr, code)) {</span>
<span class="nc" id="L2168">        resulttest = new R66Result(session, true, ErrorCode.CompleteOk,</span>
<span class="nc" id="L2169">                                   session.getRunner());</span>
      } else {
<span class="fc" id="L2171">        resulttest = new R66Result(session, true, ErrorCode.TransferOk,</span>
<span class="fc" id="L2172">                                   session.getRunner());</span>
      }
    }
<span class="fc" id="L2175">    return resulttest;</span>
  }

  private final LocalChannelReference getLocalChannelReference(
      final Transfer transfer) {
<span class="nc" id="L2180">    final String key =</span>
<span class="nc" id="L2181">        transfer.getRequested() + ' ' + transfer.getRequester() + ' ' +</span>
<span class="nc" id="L2182">        transfer.getId();</span>
<span class="nc" id="L2183">    return Configuration.configuration.getLocalTransaction()</span>
<span class="nc" id="L2184">                                      .getFromRequest(key);</span>
  }

  /**
   * @param transfer the transfer to stop
   *
   * @return
   */
  public final R66Result stopTransfer(final Transfer transfer) {
<span class="nc" id="L2193">    final ErrorCode code = ErrorCode.StoppedTransfer;</span>
<span class="nc" id="L2194">    final LocalChannelReference lcr = getLocalChannelReference(transfer);</span>
<span class="nc bnc" id="L2195" title="All 2 branches missed.">    if (lcr == null) {</span>
      // Transfer is not running
<span class="nc" id="L2197">      transfer.setUpdatedInfo(UpdatedInfo.INERROR);</span>
<span class="nc" id="L2198">      transfer.setTransferInfo(code.getCode());</span>
<span class="nc" id="L2199">      return new R66Result(session, true, ErrorCode.CompleteOk,</span>
<span class="nc" id="L2200">                           session.getRunner());</span>
    }
<span class="nc" id="L2202">    final ErrorPacket error =</span>
<span class="nc" id="L2203">        new ErrorPacket(code.name() + ' ' + transfer.getRank(), code.getCode(),</span>
                        ErrorPacket.FORWARDCLOSECODE);
    try {
<span class="nc" id="L2206">      LocalServerHandler.channelRead0(lcr, error);</span>
<span class="nc" id="L2207">    } catch (final Exception e) {</span>
<span class="nc" id="L2208">      logger.error(&quot;Cannot stop transfer (&quot; + transfer + ')', e);</span>
<span class="nc" id="L2209">      return new R66Result(session, true, ErrorCode.TransferOk,</span>
<span class="nc" id="L2210">                           session.getRunner());</span>
<span class="nc" id="L2211">    }</span>
    // Update session and transfer status
<span class="nc" id="L2213">    session.setErrorState();</span>
<span class="nc" id="L2214">    transfer.setTransferInfo(code.getCode());</span>
<span class="nc" id="L2215">    return new R66Result(session, true, ErrorCode.CompleteOk,</span>
<span class="nc" id="L2216">                         session.getRunner());</span>
  }

  /**
   * @param transfer the transfer to stop
   *
   * @return
   */
  public final R66Result cancelTransfer(final Transfer transfer) {
<span class="nc" id="L2225">    final ErrorCode code = ErrorCode.CanceledTransfer;</span>
<span class="nc" id="L2226">    final LocalChannelReference lcr = getLocalChannelReference(transfer);</span>
<span class="nc bnc" id="L2227" title="All 2 branches missed.">    if (lcr == null) {</span>
      // Transfer is not running
<span class="nc" id="L2229">      transfer.setUpdatedInfo(UpdatedInfo.INERROR);</span>
<span class="nc" id="L2230">      transfer.setTransferInfo(code.getCode());</span>
<span class="nc" id="L2231">      return new R66Result(session, true, ErrorCode.CompleteOk,</span>
<span class="nc" id="L2232">                           session.getRunner());</span>
    }
<span class="nc" id="L2234">    final ErrorPacket error =</span>
<span class="nc" id="L2235">        new ErrorPacket(code.name() + ' ' + transfer.getRank(), code.getCode(),</span>
                        ErrorPacket.FORWARDCLOSECODE);
    try {
<span class="nc" id="L2238">      LocalServerHandler.channelRead0(lcr, error);</span>
<span class="nc" id="L2239">    } catch (final Exception e) {</span>
<span class="nc" id="L2240">      logger.error(&quot;Cannot cancel transfer (&quot; + transfer + ')', e);</span>
<span class="nc" id="L2241">      return new R66Result(session, true, ErrorCode.TransferOk,</span>
<span class="nc" id="L2242">                           session.getRunner());</span>
<span class="nc" id="L2243">    }</span>
    // Update session and transfer status
<span class="nc" id="L2245">    session.setErrorState();</span>
<span class="nc" id="L2246">    transfer.setTransferInfo(code.getCode());</span>
<span class="nc" id="L2247">    return new R66Result(session, true, ErrorCode.CompleteOk,</span>
<span class="nc" id="L2248">                         session.getRunner());</span>
  }

  /**
   * Stop or Cancel a Runner
   *
   * @param id
   * @param reqd
   * @param reqr
   * @param code
   *
   * @return True if correctly stopped or canceled
   */
  private boolean stopOrCancelRunner(final long id, final String reqd,
                                     final String reqr, final ErrorCode code) {
    try {
<span class="fc" id="L2264">      localChannelReference.getDbSession();</span>
<span class="fc" id="L2265">      final DbTaskRunner taskRunner =</span>
          new DbTaskRunner(session, null, id, reqr, reqd);
<span class="fc" id="L2267">      return taskRunner.stopOrCancelRunner(code);</span>
<span class="fc" id="L2268">    } catch (final WaarpDatabaseException ignored) {</span>
      // ignore
    }
<span class="fc" id="L2271">    return false;</span>
  }

  /**
   * Receive a Shutdown request
   *
   * @param packet
   *
   * @throws OpenR66ProtocolShutdownException
   * @throws OpenR66ProtocolNotAuthenticatedException
   * @throws OpenR66ProtocolBusinessException
   */
  public final void shutdown(final ShutdownPacket packet)
      throws OpenR66ProtocolShutdownException,
             OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolBusinessException {
<span class="nc" id="L2287">    session.newState(SHUTDOWN);</span>
<span class="nc" id="L2288">    shutdown(packet.getKey(), packet.isRestart());</span>
<span class="nc" id="L2289">    packet.clear();</span>
<span class="nc" id="L2290">  }</span>

  /**
   * Receive a Shutdown request
   *
   * @param key
   * @param isRestart
   *
   * @throws OpenR66ProtocolShutdownException
   * @throws OpenR66ProtocolNotAuthenticatedException
   * @throws OpenR66ProtocolBusinessException
   */
  public final void shutdown(final byte[] key, final boolean isRestart)
      throws OpenR66ProtocolShutdownException,
             OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolBusinessException {
<span class="pc bpc" id="L2306" title="1 of 2 branches missed.">    if (!session.isAuthenticated()) {</span>
<span class="nc" id="L2307">      throw new OpenR66ProtocolNotAuthenticatedException(</span>
          &quot;Not authenticated while Shutdown received&quot;);
    }
    // SYSTEM authorization
<span class="fc" id="L2311">    final boolean isAdmin = session.getAuth().isValidRole(ROLE.SYSTEM);</span>
<span class="fc" id="L2312">    final boolean isKeyValid = Configuration.configuration.isKeyValid(key);</span>
<span class="pc bpc" id="L2313" title="2 of 4 branches missed.">    if (isAdmin &amp;&amp; isKeyValid) {</span>
<span class="pc bpc" id="L2314" title="1 of 2 branches missed.">      if (Configuration.configuration.getR66Mib() != null) {</span>
<span class="nc" id="L2315">        Configuration.configuration.getR66Mib().notifyStartStop(</span>
            &quot;Shutdown Order received effective in &quot; +
<span class="nc" id="L2317">            Configuration.configuration.getTimeoutCon() + &quot; ms&quot;,</span>
<span class="nc" id="L2318">            session.getAuth().getUser());</span>
      }
<span class="pc bpc" id="L2320" title="1 of 2 branches missed.">      if (Configuration.configuration.getShutdownConfiguration().serviceFuture !=</span>
          null) {
<span class="nc" id="L2322">        logger.warn(</span>
            &quot;R66 started as a service, Windows Services might not shown it as stopped&quot;);
      }
<span class="pc bpc" id="L2325" title="1 of 2 branches missed.">      if (isRestart) {</span>
<span class="nc" id="L2326">        WaarpShutdownHook.setRestart(true);</span>
<span class="nc" id="L2327">        logger.warn(&quot;Server will shutdown and restart&quot;);</span>
      }
<span class="fc" id="L2329">      throw new OpenR66ProtocolShutdownException(&quot;Shutdown Type received&quot;);</span>
    }
<span class="nc" id="L2331">    logger.error(</span>
<span class="nc" id="L2332">        &quot;Invalid Shutdown command: from &quot; + session.getAuth().getUser() +</span>
        &quot; AdmValid: &quot; + isAdmin + &quot; KeyValid: &quot; + isKeyValid);
<span class="nc" id="L2334">    throw new OpenR66ProtocolBusinessException(&quot;Invalid Shutdown comand&quot;);</span>
  }

  /**
   * Business Request (channel should stay open)
   * &lt;p&gt;
   * Note: the thread called should manage all writeback informations, as well
   * as status, channel closing if
   * needed or not.
   *
   * @param packet
   *
   * @throws OpenR66ProtocolNotAuthenticatedException
   * @throws OpenR66ProtocolPacketException
   */
  public final void businessRequest(final BusinessRequestPacket packet)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolPacketException,
             OpenR66ProtocolNoCorrectAuthenticationException {
<span class="fc" id="L2353">    final String argRule = packet.getSheader();</span>
<span class="fc bfc" id="L2354" title="All 2 branches covered.">    if (packet.isToValidate()) {</span>
<span class="fc" id="L2355">      session.newState(BUSINESSD);</span>
    }
<span class="fc" id="L2357">    final R66Future future =</span>
<span class="fc" id="L2358">        businessRequest(packet.isToValidate(), argRule, null, null,</span>
<span class="fc" id="L2359">                        packet.getDelay());</span>
<span class="pc bpc" id="L2360" title="2 of 4 branches missed.">    if (future != null &amp;&amp; !future.isSuccess()) {</span>
<span class="nc" id="L2361">      R66Result result = future.getResult();</span>
<span class="nc bnc" id="L2362" title="All 2 branches missed.">      if (result == null) {</span>
<span class="nc" id="L2363">        result = new R66Result(session, false, ErrorCode.ExternalOp,</span>
<span class="nc" id="L2364">                               session.getRunner());</span>
      }
<span class="nc" id="L2366">      wrongResult(packet, argRule, result);</span>
<span class="pc bpc" id="L2367" title="1 of 2 branches missed.">    } else if (future == null) {</span>
<span class="nc" id="L2368">      final R66Result result =</span>
          new R66Result(session, false, ErrorCode.ExternalOp,
<span class="nc" id="L2370">                        session.getRunner());</span>
<span class="nc" id="L2371">      wrongResult(packet, argRule, result);</span>
<span class="nc" id="L2372">    } else {</span>
<span class="fc" id="L2373">      logger.debug(&quot;BusinessRequest part 2&quot;);</span>
<span class="fc" id="L2374">      final R66Result result = future.getResult();</span>
<span class="fc" id="L2375">      final LocalChannelReference localChannelReference =</span>
<span class="fc" id="L2376">          session.getLocalChannelReference();</span>
<span class="pc bpc" id="L2377" title="1 of 2 branches missed.">      if (localChannelReference != null) {</span>
<span class="fc" id="L2378">        localChannelReference.validateRequest(result);</span>
        try {
<span class="fc" id="L2380">          ChannelUtils.writeAbstractLocalPacket(localChannelReference, packet,</span>
                                                false);
<span class="nc" id="L2382">        } catch (final OpenR66ProtocolPacketException ignored) {</span>
          // ignore
<span class="fc" id="L2384">        }</span>
<span class="fc" id="L2385">        localChannelReference.close();</span>
      }
    }
<span class="fc" id="L2388">  }</span>

  private void wrongResult(final BusinessRequestPacket packet,
                           final String argRule, final R66Result result)
      throws OpenR66ProtocolPacketException {
<span class="nc" id="L2393">    logger.info(&quot;Task in Error: {} {}&quot;, argRule, result);</span>
<span class="nc bnc" id="L2394" title="All 2 branches missed.">    if (!result.isAnswered()) {</span>
<span class="nc" id="L2395">      packet.invalidate();</span>
<span class="nc" id="L2396">      session.newState(ERROR);</span>
<span class="nc" id="L2397">      final ErrorPacket error = new ErrorPacket(</span>
          &quot;BusinessRequest in error: for &quot; + packet + &quot; since &quot; +
<span class="nc" id="L2399">          result.getMessage(), result.getCode().getCode(),</span>
          ErrorPacket.FORWARDCLOSECODE);
<span class="nc" id="L2401">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, error,</span>
                                            false);
<span class="nc" id="L2403">      session.setStatus(203);</span>
    }
<span class="nc" id="L2405">    session.setStatus(204);</span>
<span class="nc" id="L2406">    packet.clear();</span>
<span class="nc" id="L2407">  }</span>

  /**
   * Business Request (channel should stay open)
   * &lt;p&gt;
   * Note: the thread called should manage all writeback informations, as well
   * as status, channel closing if
   * needed or not.
   *
   * @param isToApplied True means this is an action request, False it
   *     is
   *     the feedback
   * @param className
   * @param arguments
   * @param extraArguments
   * @param delay
   *
   * @return future of the execution
   *
   * @throws OpenR66ProtocolNotAuthenticatedException
   */
  public final R66Future businessRequest(final boolean isToApplied,
                                         final String className,
                                         final String arguments,
                                         final String extraArguments,
                                         final int delay)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolNoCorrectAuthenticationException {
<span class="pc bpc" id="L2435" title="1 of 2 branches missed.">    if (!session.isAuthenticated()) {</span>
<span class="nc" id="L2436">      throw new OpenR66ProtocolNotAuthenticatedException(</span>
          &quot;Not authenticated while BusinessRequest received&quot;);
    }
<span class="fc bfc" id="L2439" title="All 2 branches covered.">    if (isToApplied &amp;&amp; !Configuration.configuration.getBusinessWhiteSet()</span>
<span class="pc bpc" id="L2440" title="1 of 2 branches missed.">                                                   .contains(session.getAuth()</span>
<span class="fc" id="L2441">                                                                    .getUser())) {</span>
<span class="nc" id="L2442">      logger.warn(&quot;Not allow to execute a BusinessRequest: &quot; +</span>
<span class="nc" id="L2443">                  session.getAuth().getUser());</span>
<span class="nc" id="L2444">      throw new OpenR66ProtocolNoCorrectAuthenticationException(</span>
          &quot;Not allow to execute a BusinessRequest&quot;);
    }
<span class="fc" id="L2447">    session.setStatus(200);</span>
<span class="fc" id="L2448">    String argRule = className;</span>
<span class="fc bfc" id="L2449" title="All 2 branches covered.">    if (arguments != null) {</span>
<span class="fc" id="L2450">      argRule += ' ' + arguments;</span>
    }
<span class="fc" id="L2452">    final ExecJavaTask task =</span>
        new ExecJavaTask(argRule + ' ' + isToApplied, delay, extraArguments,
                         session);
<span class="fc" id="L2455">    task.setBusinessRequest(true);</span>
<span class="fc" id="L2456">    task.run();</span>
<span class="fc" id="L2457">    session.setStatus(201);</span>
<span class="pc bpc" id="L2458" title="1 of 2 branches missed.">    if (task.isSuccess()) {</span>
<span class="fc" id="L2459">      session.setStatus(202);</span>
<span class="fc" id="L2460">      logger.info(&quot;Task done: &quot; + className.split(&quot; &quot;)[0]);</span>
    }
<span class="fc" id="L2462">    return task.getFutureCompletion();</span>
  }

  /**
   * Block/Unblock Request
   *
   * @param packet
   *
   * @throws OpenR66ProtocolBusinessException
   */
  public final void blockRequest(final BlockRequestPacket packet)
      throws OpenR66ProtocolBusinessException {
<span class="nc" id="L2474">    final R66Result result = blockRequest(packet.getKey(), packet.getBlock());</span>
<span class="nc" id="L2475">    final ValidPacket valid = new ValidPacket(</span>
<span class="nc bnc" id="L2476" title="All 2 branches missed.">        (packet.getBlock()? &quot;Block&quot; : &quot;Unblock&quot;) + &quot; new request&quot;,</span>
<span class="nc" id="L2477">        result.getCode().getCode(), LocalPacketFactory.REQUESTUSERPACKET);</span>
    try {
<span class="nc" id="L2479">      ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid,</span>
                                            false);
<span class="nc" id="L2481">    } catch (final OpenR66ProtocolPacketException ignored) {</span>
      // ignore
<span class="nc" id="L2483">    }</span>
<span class="nc" id="L2484">    localChannelReference.close();</span>
<span class="nc" id="L2485">    packet.clear();</span>
<span class="nc" id="L2486">  }</span>

  /**
   * Block/Unblock Request
   *
   * @param key
   * @param isBlocking
   *
   * @return The result
   *
   * @throws OpenR66ProtocolPacketException
   * @throws OpenR66ProtocolBusinessException
   */
  public final R66Result blockRequest(final byte[] key,
                                      final boolean isBlocking)
      throws OpenR66ProtocolBusinessException {
<span class="pc bpc" id="L2502" title="1 of 2 branches missed.">    if (!session.isAuthenticated()) {</span>
<span class="nc" id="L2503">      throw new OpenR66ProtocolNotAuthenticatedException(</span>
          &quot;Not authenticated while BlockRequest received&quot;);
    }
    // SYSTEM authorization
<span class="fc" id="L2507">    final boolean isAdmin = session.getAuth().isValidRole(ROLE.SYSTEM);</span>
<span class="fc" id="L2508">    final boolean isKeyValid = Configuration.configuration.isKeyValid(key);</span>
<span class="pc bpc" id="L2509" title="2 of 4 branches missed.">    if (isAdmin &amp;&amp; isKeyValid) {</span>
<span class="pc bpc" id="L2510" title="1 of 2 branches missed.">      if (Configuration.configuration.getR66Mib() != null) {</span>
<span class="nc bnc" id="L2511" title="All 2 branches missed.">        Configuration.configuration.getR66Mib().notifyWarning(</span>
            (isBlocking? &quot;Block&quot; : &quot;Unblock&quot;) + &quot; Order received&quot;,
<span class="nc" id="L2513">            session.getAuth().getUser());</span>
      }
<span class="pc bpc" id="L2515" title="1 of 2 branches missed.">      logger.debug((isBlocking? &quot;Block&quot; : &quot;Unblock&quot;) + &quot; Order received&quot;);</span>
<span class="fc" id="L2516">      Configuration.configuration.setShutdown(isBlocking);</span>
      // inform back the requester
      // request of current values
<span class="fc" id="L2519">      final R66Result result =</span>
          new R66Result(session, true, ErrorCode.CompleteOk, null);
<span class="pc bpc" id="L2521" title="1 of 2 branches missed.">      if (localChannelReference != null) {</span>
<span class="fc" id="L2522">        localChannelReference.validateRequest(result);</span>
      }
<span class="fc" id="L2524">      return result;</span>
    }
<span class="nc" id="L2526">    logger.error(&quot;Invalid Block command: from &quot; + session.getAuth().getUser() +</span>
                 &quot; AdmValid: &quot; + isAdmin + &quot; KeyValid: &quot; + isKeyValid);
<span class="nc" id="L2528">    throw new OpenR66ProtocolBusinessException(&quot;Invalid Block comand&quot;);</span>
  }

  /**
   * Receive a request of information (Transfer information or File listing)
   *
   * @param request InformationPacket.ASKENUM ordinal
   * @param rulename rulename for file path
   * @param filename partial name (including wildcard)
   * @param jsonOutput ValidPacket will contain Json format ?
   *
   * @return the ValidPacket to answer containing: File Listing as Header and
   *     Number of entries as Middle
   *
   * @throws OpenR66ProtocolNotAuthenticatedException
   * @throws OpenR66ProtocolNoDataException
   */
  public final ValidPacket informationFile(final byte request,
                                           final String rulename,
                                           final String filename,
                                           final boolean jsonOutput)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolNoDataException {
<span class="pc bpc" id="L2551" title="1 of 2 branches missed.">    if (!session.isAuthenticated()) {</span>
<span class="nc" id="L2552">      throw new OpenR66ProtocolNotAuthenticatedException(</span>
          &quot;Not authenticated while Information received&quot;);
    }
<span class="fc" id="L2555">    localChannelReference.getDbSession();</span>
    final DbRule rule;
    try {
<span class="fc" id="L2558">      rule = new DbRule(rulename);</span>
<span class="nc" id="L2559">    } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L2560">      logger.error(&quot;Rule is unknown: &quot; + rulename, e);</span>
<span class="nc" id="L2561">      throw new OpenR66ProtocolNoDataException(e);</span>
<span class="fc" id="L2562">    }</span>
    try {
<span class="fc" id="L2564">      session.getDir().changeDirectory(rule.getSendPath());</span>

<span class="fc bfc" id="L2566" title="All 2 branches covered.">      if (request == InformationPacket.ASKENUM.ASKLIST.ordinal() ||</span>
<span class="fc bfc" id="L2567" title="All 2 branches covered.">          request == InformationPacket.ASKENUM.ASKMLSLIST.ordinal()) {</span>
        // ls or mls from current directory
        final List&lt;String&gt; list;
<span class="fc bfc" id="L2570" title="All 2 branches covered.">        if (request == InformationPacket.ASKENUM.ASKLIST.ordinal()) {</span>
<span class="fc" id="L2571">          list = session.getDir().list(filename);</span>
        } else {
<span class="fc" id="L2573">          list = session.getDir().listFull(filename, false);</span>
        }

<span class="fc" id="L2576">        final StringBuilder builder = new StringBuilder();</span>
<span class="pc bpc" id="L2577" title="1 of 2 branches missed.">        if (jsonOutput) {</span>
<span class="nc" id="L2578">          final ObjectNode node = JsonHandler.createObjectNode();</span>
<span class="nc" id="L2579">          final String asked =</span>
<span class="nc bnc" id="L2580" title="All 2 branches missed.">              request == InformationPacket.ASKENUM.ASKLIST.ordinal()? &quot;ls&quot; :</span>
                  &quot;mls&quot;;
<span class="nc" id="L2582">          final ArrayNode array = node.putArray(asked);</span>
<span class="nc bnc" id="L2583" title="All 2 branches missed.">          for (final String elt : list) {</span>
<span class="nc" id="L2584">            array.add(elt);</span>
<span class="nc" id="L2585">          }</span>
<span class="nc" id="L2586">          builder.append(JsonHandler.writeAsString(node));</span>
<span class="nc" id="L2587">        } else {</span>
<span class="fc bfc" id="L2588" title="All 2 branches covered.">          for (final String elt : list) {</span>
<span class="fc" id="L2589">            builder.append(elt).append('\n');</span>
<span class="fc" id="L2590">          }</span>
        }
<span class="pc bpc" id="L2592" title="1 of 2 branches missed.">        if (!jsonOutput) {</span>
<span class="fc" id="L2593">          session.newState(VALIDOTHER);</span>
        }
<span class="fc" id="L2595">        final ValidPacket validPacket =</span>
<span class="fc" id="L2596">            new ValidPacket(builder.toString(), String.valueOf(list.size()),</span>
                            LocalPacketFactory.INFORMATIONPACKET);
<span class="fc" id="L2598">        final R66Result result =</span>
            new R66Result(session, true, ErrorCode.CompleteOk, null);
<span class="fc" id="L2600">        result.setOther(validPacket);</span>
<span class="pc bpc" id="L2601" title="1 of 2 branches missed.">        if (localChannelReference != null) {</span>
<span class="fc" id="L2602">          localChannelReference.validateEndTransfer(result);</span>
<span class="fc" id="L2603">          localChannelReference.validateRequest(result);</span>
        }
<span class="fc" id="L2605">        return validPacket;</span>
      } else {
        // exists or ls or mls from current directory and filename
<span class="fc" id="L2608">        final R66File file =</span>
<span class="fc" id="L2609">            (R66File) session.getDir().setFile(filename, false);</span>
        String sresult;
<span class="fc bfc" id="L2611" title="All 2 branches covered.">        if (request == InformationPacket.ASKENUM.ASKEXIST.ordinal()) {</span>
<span class="pc bpc" id="L2612" title="1 of 2 branches missed.">          if (jsonOutput) {</span>
<span class="nc" id="L2613">            final ObjectNode node = JsonHandler.createObjectNode();</span>
<span class="nc" id="L2614">            node.put(&quot;exist&quot;, file.exists());</span>
<span class="nc" id="L2615">            sresult = JsonHandler.writeAsString(node);</span>
<span class="nc" id="L2616">          } else {</span>
<span class="fc" id="L2617">            sresult = String.valueOf(file.exists());</span>
          }
<span class="fc" id="L2619">        } else if (request ==</span>
<span class="pc bpc" id="L2620" title="1 of 2 branches missed.">                   InformationPacket.ASKENUM.ASKMLSDETAIL.ordinal()) {</span>
<span class="fc" id="L2621">          sresult = session.getDir().fileFull(filename, false);</span>
<span class="fc" id="L2622">          final String[] list = sresult.split(&quot;\n&quot;);</span>
<span class="fc" id="L2623">          sresult = list[1];</span>
<span class="pc bpc" id="L2624" title="1 of 2 branches missed.">          if (jsonOutput) {</span>
<span class="nc" id="L2625">            final ObjectNode node = JsonHandler.createObjectNode();</span>
<span class="nc" id="L2626">            node.put(&quot;mls&quot;, sresult);</span>
<span class="nc" id="L2627">            sresult = JsonHandler.writeAsString(node);</span>
          }
<span class="fc" id="L2629">        } else {</span>
<span class="nc" id="L2630">          session.newState(ERROR);</span>
<span class="nc" id="L2631">          logger.warn(&quot;Unknown Request &quot; + request);</span>
<span class="nc" id="L2632">          return null;</span>
        }
<span class="pc bpc" id="L2634" title="1 of 2 branches missed.">        if (!jsonOutput) {</span>
<span class="fc" id="L2635">          session.newState(VALIDOTHER);</span>
        }
<span class="fc" id="L2637">        final ValidPacket validPacket =</span>
            new ValidPacket(sresult, &quot;1&quot;, LocalPacketFactory.INFORMATIONPACKET);
<span class="fc" id="L2639">        final R66Result result =</span>
            new R66Result(session, true, ErrorCode.CompleteOk, null);
<span class="fc" id="L2641">        result.setOther(validPacket);</span>
<span class="pc bpc" id="L2642" title="1 of 2 branches missed.">        if (localChannelReference != null) {</span>
<span class="fc" id="L2643">          localChannelReference.validateEndTransfer(result);</span>
<span class="fc" id="L2644">          localChannelReference.validateRequest(result);</span>
        }
<span class="fc" id="L2646">        return validPacket;</span>
      }
<span class="nc" id="L2648">    } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L2649">      session.newState(ERROR);</span>
<span class="nc" id="L2650">      logger.warn(&quot;Error while Request &quot; + request + ' ' + e.getMessage());</span>
<span class="nc" id="L2651">      return null;</span>
    }
  }

  /**
   * Receive a request of information (Transfer information or File listing)
   *
   * @param id Id of request
   * @param isTo True for remote host is requester, False for
   *     requested
   *     (default)
   * @param remoteHost requester/requested for transfer if jsonOutput
   *     is
   *     True, else (jsonOutput False)
   *     remoteHost is from current Authenticated user
   * @param jsonOutput ValidPacket will contain Json format ?
   *
   * @return the ValidPacket to answer containing: Transfer Information as
   *     Header
   *
   * @throws OpenR66ProtocolNotAuthenticatedException
   * @throws OpenR66ProtocolNoDataException
   */
  public final ValidPacket informationRequest(final long id, final boolean isTo,
                                              final String remoteHost,
                                              final boolean jsonOutput)
      throws OpenR66ProtocolNotAuthenticatedException,
             OpenR66ProtocolNoDataException {
<span class="pc bpc" id="L2679" title="1 of 2 branches missed.">    if (!session.isAuthenticated()) {</span>
<span class="nc" id="L2680">      throw new OpenR66ProtocolNotAuthenticatedException(</span>
          &quot;Not authenticated while Information received&quot;);
    }
<span class="fc" id="L2683">    String remote = session.getAuth().getUser();</span>
<span class="pc bpc" id="L2684" title="3 of 4 branches missed.">    if (jsonOutput &amp;&amp; ParametersChecker.isNotEmpty(remoteHost)) {</span>
<span class="nc" id="L2685">      remote = remoteHost;</span>
    }
    final String local;
    try {
<span class="fc" id="L2689">      local = Configuration.configuration.getHostId(remote);</span>
<span class="nc" id="L2690">    } catch (final WaarpDatabaseException e1) {</span>
<span class="nc" id="L2691">      logger.error(&quot;Remote Host is unknown&quot;, e1);</span>
<span class="nc" id="L2692">      throw new OpenR66ProtocolNoDataException(&quot;Remote Host is unknown&quot;, e1);</span>
<span class="fc" id="L2693">    }</span>
    final DbTaskRunner runner;
<span class="fc bfc" id="L2695" title="All 2 branches covered.">    if (isTo) {</span>
<span class="fc" id="L2696">      logger.info(&quot;{} {} {}&quot;, id, remote, local);</span>
      try {
<span class="fc" id="L2698">        runner = new DbTaskRunner(session, null, id, remote, local);</span>
<span class="nc" id="L2699">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L2700">        logger.error(</span>
<span class="nc" id="L2701">            Messages.getString(&quot;LocalServerHandler.21&quot;) + id); //$NON-NLS-1$</span>
<span class="nc" id="L2702">        logger.debug(RUNNER_TASK_IS_NOT_FOUND + id + ':' + remote + ':' + local,</span>
                     e);
<span class="nc" id="L2704">        throw new OpenR66ProtocolNoDataException(</span>
<span class="nc" id="L2705">            Messages.getString(&quot;LocalServerHandler.22&quot;) + id, e); //$NON-NLS-1$</span>
<span class="fc" id="L2706">      }</span>
    } else {
      try {
<span class="fc" id="L2709">        runner = new DbTaskRunner(session, null, id, local, remote);</span>
<span class="nc" id="L2710">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L2711">        logger.debug(RUNNER_TASK_IS_NOT_FOUND + id + ':' + local + ':' + remote,</span>
                     e);
<span class="nc" id="L2713">        logger.error(Messages.getString(&quot;LocalServerHandler.21&quot;) + id);</span>
<span class="nc" id="L2714">        throw new OpenR66ProtocolNoDataException(</span>
<span class="nc" id="L2715">            &quot;(Local) &quot; + Messages.getString(&quot;LocalServerHandler.21&quot;) + id, e);</span>
<span class="fc" id="L2716">      }</span>
    }
<span class="pc bpc" id="L2718" title="1 of 2 branches missed.">    if (!jsonOutput) {</span>
<span class="fc" id="L2719">      session.newState(VALIDOTHER);</span>
    }
<span class="pc bpc" id="L2721" title="1 of 2 branches missed.">    final ValidPacket validPacket =</span>
<span class="pc" id="L2722">        new ValidPacket(jsonOutput? runner.asJson() : runner.asXML(), &quot;&quot;,</span>
                        LocalPacketFactory.INFORMATIONPACKET);
<span class="fc" id="L2724">    final R66Result result =</span>
        new R66Result(session, true, ErrorCode.CompleteOk, null);
<span class="fc" id="L2726">    result.setOther(validPacket);</span>
<span class="pc bpc" id="L2727" title="1 of 2 branches missed.">    if (localChannelReference != null) {</span>
<span class="fc" id="L2728">      localChannelReference.validateEndTransfer(result);</span>
<span class="fc" id="L2729">      localChannelReference.validateRequest(result);</span>
    }
<span class="fc" id="L2731">    return validPacket;</span>
  }

  /**
   * Receive a TransferRequest in JSON mode: just setting it to be scheduled
   *
   * @param request
   *
   * @return the result associated with the new transfer request
   */
  public final R66Result transferRequest(
      final TransferRequestJsonPacket request) {
<span class="nc" id="L2743">    final DbTaskRunner runner = initTransferRequest(request);</span>
<span class="nc bnc" id="L2744" title="All 2 branches missed.">    if (runner != null) {</span>
<span class="nc" id="L2745">      runner.changeUpdatedInfo(AbstractDbData.UpdatedInfo.TOSUBMIT);</span>
<span class="nc" id="L2746">      final boolean isSender = runner.isSender();</span>
<span class="nc bnc" id="L2747" title="All 2 branches missed.">      if (!runner.forceSaveStatus()) {</span>
<span class="nc" id="L2748">        logger.warn(&quot;Cannot prepare task&quot;);</span>
<span class="nc" id="L2749">        return new R66Result(session, false, ErrorCode.CommandNotFound, runner);</span>
      }
<span class="nc" id="L2751">      final R66Result result =</span>
          new R66Result(session, false, ErrorCode.InitOk, runner);
      try {
<span class="nc" id="L2754">        runner.select();</span>
<span class="nc" id="L2755">      } catch (final WaarpDatabaseException ignored) {</span>
        // ignore
<span class="nc" id="L2757">      }</span>
<span class="nc" id="L2758">      runner.setSender(isSender);</span>
<span class="nc" id="L2759">      request.setFromDbTaskRunner(runner);</span>
<span class="nc" id="L2760">      request.validate();</span>
<span class="nc" id="L2761">      return result;</span>
    } else {
<span class="nc" id="L2763">      logger.warn(&quot;ERROR: Transfer NOT scheduled&quot;);</span>
<span class="nc" id="L2764">      return new R66Result(session, false, ErrorCode.Internal, null);</span>
    }
  }

  /**
   * initialize a new Transfer Request
   *
   * @param request
   *
   * @return the associated DbTaskRunner
   */
  private DbTaskRunner initTransferRequest(
      final TransferRequestJsonPacket request) {
<span class="nc" id="L2777">    Timestamp ttimestart = null;</span>
<span class="nc" id="L2778">    final Date date = request.getStart();</span>
<span class="nc bnc" id="L2779" title="All 2 branches missed.">    if (date != null) {</span>
<span class="nc" id="L2780">      ttimestart = new Timestamp(date.getTime());</span>
<span class="nc bnc" id="L2781" title="All 2 branches missed.">    } else if (request.getDelay() &gt; 0) {</span>
<span class="nc bnc" id="L2782" title="All 2 branches missed.">      if (request.isAdditionalDelay()) {</span>
<span class="nc" id="L2783">        ttimestart =</span>
<span class="nc" id="L2784">            new Timestamp(System.currentTimeMillis() + request.getDelay());</span>
      } else {
<span class="nc" id="L2786">        ttimestart = new Timestamp(request.getDelay());</span>
      }
    }
    final DbRule rule;
    try {
<span class="nc" id="L2791">      rule = new DbRule(request.getRulename());</span>
<span class="nc" id="L2792">    } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L2793">      logger.warn(&quot;Cannot get Rule: &quot; + request.getRulename() + &quot; : {}&quot;,</span>
<span class="nc" id="L2794">                  e.getMessage());</span>
<span class="nc" id="L2795">      return null;</span>
<span class="nc" id="L2796">    }</span>
<span class="nc" id="L2797">    int mode = rule.getMode();</span>
<span class="nc bnc" id="L2798" title="All 2 branches missed.">    if (RequestPacket.isMD5Mode(request.getMode())) {</span>
<span class="nc" id="L2799">      mode = RequestPacket.getModeMD5(mode);</span>
    }
    final DbTaskRunner taskRunner;
<span class="nc" id="L2802">    long tid = ILLEGALVALUE;</span>
<span class="nc bnc" id="L2803" title="All 4 branches missed.">    if (request.getSpecialId() != 0 || request.getSpecialId() == ILLEGALVALUE) {</span>
<span class="nc" id="L2804">      tid = request.getSpecialId();</span>
    }
<span class="nc bnc" id="L2806" title="All 2 branches missed.">    if (tid != ILLEGALVALUE) {</span>
      try {
<span class="nc" id="L2808">        taskRunner = new DbTaskRunner(tid, request.getRequested());</span>
        // requested
<span class="nc" id="L2810">        taskRunner.setSenderByRequestToValidate(true);</span>
<span class="nc" id="L2811">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L2812">        logger.warn(&quot;Cannot get task&quot; + &quot; : {}&quot;, e.getMessage());</span>
<span class="nc" id="L2813">        return null;</span>
<span class="nc" id="L2814">      }</span>
    } else {
<span class="nc" id="L2816">      final String sep =</span>
<span class="nc" id="L2817">          PartnerConfiguration.getSeparator(request.getRequested());</span>
<span class="nc" id="L2818">      final RequestPacket requestPacket =</span>
<span class="nc" id="L2819">          new RequestPacket(request.getRulename(), mode, request.getFilename(),</span>
<span class="nc" id="L2820">                            request.getBlocksize(), 0, tid,</span>
<span class="nc" id="L2821">                            request.getFileInformation(), -1, sep);</span>
      // Not isRecv since it is the requester, so send =&gt; isRetrieve is true
<span class="nc" id="L2823">      final boolean isRetrieve =</span>
<span class="nc bnc" id="L2824" title="All 2 branches missed.">          !RequestPacket.isRecvMode(requestPacket.getMode());</span>
      try {
<span class="nc" id="L2826">        taskRunner = new DbTaskRunner(rule, isRetrieve, requestPacket,</span>
<span class="nc" id="L2827">                                      request.getRequested(), ttimestart);</span>
<span class="nc" id="L2828">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L2829">        logger.warn(&quot;Cannot get task&quot; + &quot; : {}&quot;, e.getMessage());</span>
<span class="nc" id="L2830">        return null;</span>
<span class="nc" id="L2831">      }</span>
    }
<span class="nc" id="L2833">    return taskRunner;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>