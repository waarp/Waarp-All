!function(e){function n(e){return RegExp("(\\()"+e+"(?=[\\s\\)])")}function a(e){return RegExp("([\\s([])"+e+"(?=[\\s)])")}var t="[-+*/_~!@$%^=<>{}\\w]+",r="(\\()",i="(?=\\))",s="(?=\\s)",o={heading:{pattern:/;;;.*/,alias:["comment","title"]},comment:/;.*/,string:{pattern:/"(?:[^"\\]|\\.)*"/,greedy:!0,inside:{argument:/[-A-Z]+(?=[.,\s])/,symbol:/`[-+*\/_~!@$%^=<>{}\w]+'/}},"quoted-symbol":{pattern:/#?'[-+*\/_~!@$%^=<>{}\w]+/,alias:["variable","symbol"]},"lisp-property":{pattern:/:[-+*\/_~!@$%^=<>{}\w]+/,alias:"property"},splice:{pattern:/,@?[-+*\/_~!@$%^=<>{}\w]+/,alias:["symbol","variable"]},keyword:[{pattern:/(\()(?:(?:lexical-)?let\*?|(?:cl-)?letf|if|when|while|unless|cons|cl-loop|and|or|not|cond|setq|error|message|null|require|provide|use-package)(?=\s)/,lookbehind:!0},{pattern:/(\()(?:for|do|collect|return|finally|append|concat|in|by)(?=\s)/,lookbehind:!0}],declare:{pattern:n("declare"),lookbehind:!0,alias:"keyword"},interactive:{pattern:n("interactive"),lookbehind:!0,alias:"keyword"},boolean:{pattern:a("(?:t|nil)"),lookbehind:!0},number:{pattern:a("[-+]?\\d+(?:\\.\\d*)?"),lookbehind:!0},defvar:{pattern:/(\()def(?:var|const|custom|group)\s+[-+*\/_~!@$%^=<>{}\w]+/,lookbehind:!0,inside:{keyword:/^def[a-z]+/,variable:/[-+*\/_~!@$%^=<>{}\w]+/}},defun:{pattern:/(\()(?:cl-)?(?:defun\*?|defmacro)\s+[-+*\/_~!@$%^=<>{}\w]+\s+\([\s\S]*?\)/,lookbehind:!0,inside:{keyword:/^(?:cl-)?def\S+/,arguments:null,function:{pattern:/(^\s)[-+*\/_~!@$%^=<>{}\w]+/,lookbehind:!0},punctuation:/[()]/}},lambda:{pattern:/(\()lambda\s+\((?:&?[-+*\/_~!@$%^=<>{}\w]+\s*)*\)/,lookbehind:!0,inside:{keyword:/^lambda/,arguments:null,punctuation:/[()]/}},car:{pattern:/(\()[-+*\/_~!@$%^=<>{}\w]+/,lookbehind:!0},punctuation:[/(['`,]?\(|[)\[\]])/,{pattern:/(\s)\.(?=\s)/,lookbehind:!0}]},l={"lisp-marker":/&[-+*\/_~!@$%^=<>{}\w]+/,rest:{argument:{pattern:/[-+*\/_~!@$%^=<>{}\w]+/,alias:"variable"},varform:{pattern:/(\()[-+*\/_~!@$%^=<>{}\w]+\s+\S[\s\S]*(?=\))/,lookbehind:!0,inside:{string:o.string,boolean:o.boolean,number:o.number,symbol:o.symbol,punctuation:/[()]/}}}},p="\\S+(?:\\s+\\S+)*",d={pattern:/(\()[\s\S]*(?=\))/,lookbehind:!0,inside:{"rest-vars":{pattern:/&(?:rest|body)\s+\S+(?:\s+\S+)*/,inside:l},"other-marker-vars":{pattern:/&(?:optional|aux)\s+\S+(?:\s+\S+)*/,inside:l},keys:{pattern:/&key\s+\S+(?:\s+\S+)*(?:\s+&allow-other-keys)?/,inside:l},argument:{pattern:/[-+*\/_~!@$%^=<>{}\w]+/,alias:"variable"},punctuation:/[()]/}};o.lambda.inside.arguments=d,o.defun.inside.arguments=e.util.clone(d),o.defun.inside.arguments.inside.sublist=d,e.languages.lisp=o,e.languages.elisp=o,e.languages.emacs=o,e.languages["emacs-lisp"]=o}(Prism);