(function(Prism){// Functions to construct regular expressions
// simple form
// e.g. (interactive ... or (interactive)
function simple_form(name){return RegExp("(\\()"+name+"(?=[\\s\\)])")}// booleans and numbers
function primitive(pattern){return RegExp("([\\s([])"+pattern+"(?=[\\s)])")}// Patterns in regular expressions
// Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html
// & and : are excluded as they are usually used for special purposes
var symbol="[-+*/_~!@$%^=<>{}\\w]+",marker="&"+symbol,par="(\\()",endpar="(?=\\))",space="(?=\\s)",language={// Three or four semicolons are considered a heading.
// See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html
heading:{pattern:/;;;.*/,alias:["comment","title"]},comment:/;.*/,string:{pattern:/"(?:[^"\\]|\\.)*"/,greedy:!0,inside:{argument:/[-A-Z]+(?=[.,\s])/,symbol:/`[-+*\/_~!@$%^=<>{}\w]+'/}},"quoted-symbol":{pattern:/#?'[-+*\/_~!@$%^=<>{}\w]+/,alias:["variable","symbol"]},"lisp-property":{pattern:/:[-+*\/_~!@$%^=<>{}\w]+/,alias:"property"},splice:{pattern:/,@?[-+*\/_~!@$%^=<>{}\w]+/,alias:["symbol","variable"]},keyword:[{pattern:RegExp(par+"(?:(?:lexical-)?let\\*?|(?:cl-)?letf|if|when|while|unless|cons|cl-loop|and|or|not|cond|setq|error|message|null|require|provide|use-package)"+space),lookbehind:!0},{pattern:RegExp(par+"(?:for|do|collect|return|finally|append|concat|in|by)"+space),lookbehind:!0}],declare:{pattern:simple_form("declare"),lookbehind:!0,alias:"keyword"},interactive:{pattern:simple_form("interactive"),lookbehind:!0,alias:"keyword"},boolean:{pattern:primitive("(?:t|nil)"),lookbehind:!0},number:{pattern:primitive("[-+]?\\d+(?:\\.\\d*)?"),lookbehind:!0},defvar:{pattern:RegExp(par+"def(?:var|const|custom|group)\\s+"+symbol),lookbehind:!0,inside:{keyword:/^def[a-z]+/,variable:/[-+*\/_~!@$%^=<>{}\w]+/}},defun:{pattern:RegExp(par+"(?:cl-)?(?:defun\\*?|defmacro)\\s+"+symbol+"\\s+\\([\\s\\S]*?\\)"),lookbehind:!0,inside:{keyword:/^(?:cl-)?def\S+/,// See below, this property needs to be defined later so that it can
// reference the language object.
arguments:null,function:{pattern:/(^\s)[-+*\/_~!@$%^=<>{}\w]+/,lookbehind:!0},punctuation:/[()]/}},lambda:{pattern:RegExp(par+"lambda\\s+\\((?:&?"+symbol+"\\s*)*\\)"),lookbehind:!0,inside:{keyword:/^lambda/,// See below, this property needs to be defined later so that it can
// reference the language object.
arguments:null,punctuation:/[()]/}},car:{pattern:RegExp(par+symbol),lookbehind:!0},punctuation:[// open paren, brackets, and close paren
/(['`,]?\(|[)\[\]])/,// cons
{pattern:/(\s)\.(?=\s)/,lookbehind:!0}]},arg={"lisp-marker":RegExp(marker),rest:{argument:{pattern:/[-+*\/_~!@$%^=<>{}\w]+/,alias:"variable"},varform:{pattern:RegExp(par+symbol+"\\s+\\S[\\s\\S]*"+endpar),lookbehind:!0,inside:{string:language.string,boolean:language.boolean,number:language.number,symbol:language.symbol,punctuation:/[()]/}}}},forms="\\S+(?:\\s+\\S+)*",arglist={pattern:RegExp(par+"[\\s\\S]*"+endpar),lookbehind:!0,inside:{"rest-vars":{pattern:RegExp("&(?:rest|body)\\s+"+forms),inside:arg},"other-marker-vars":{pattern:RegExp("&(?:optional|aux)\\s+"+forms),inside:arg},keys:{pattern:RegExp("&key\\s+"+forms+"(?:\\s+&allow-other-keys)?"),inside:arg},argument:{pattern:/[-+*\/_~!@$%^=<>{}\w]+/,alias:"variable"},punctuation:/[()]/}};// symbol starting with & used in function arguments
language.lambda.inside.arguments=arglist;language.defun.inside.arguments=Prism.util.clone(arglist);language.defun.inside.arguments.inside.sublist=arglist;Prism.languages.lisp=language;Prism.languages.elisp=language;Prism.languages.emacs=language;Prism.languages["emacs-lisp"]=language})(Prism);