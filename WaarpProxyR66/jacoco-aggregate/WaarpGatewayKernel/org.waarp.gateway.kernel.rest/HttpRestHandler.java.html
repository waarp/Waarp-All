<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>HttpRestHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Proxy in R66 protocol</a> &gt; <a href="../index.html" class="el_bundle">WaarpGatewayKernel</a> &gt; <a href="index.source.html" class="el_package">org.waarp.gateway.kernel.rest</a> &gt; <span class="el_source">HttpRestHandler.java</span></div><h1>HttpRestHandler.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.gateway.kernel.rest;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.channel.group.ChannelGroup;
import io.netty.handler.codec.http.DefaultFullHttpResponse;
import io.netty.handler.codec.http.FullHttpRequest;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.HttpContent;
import io.netty.handler.codec.http.HttpHeaderNames;
import io.netty.handler.codec.http.HttpHeaderValues;
import io.netty.handler.codec.http.HttpMethod;
import io.netty.handler.codec.http.HttpObject;
import io.netty.handler.codec.http.HttpRequest;
import io.netty.handler.codec.http.HttpResponseStatus;
import io.netty.handler.codec.http.HttpUtil;
import io.netty.handler.codec.http.HttpVersion;
import io.netty.handler.codec.http.LastHttpContent;
import io.netty.handler.codec.http.cookie.ServerCookieEncoder;
import io.netty.handler.codec.http.multipart.Attribute;
import io.netty.handler.codec.http.multipart.DefaultHttpDataFactory;
import io.netty.handler.codec.http.multipart.DiskAttribute;
import io.netty.handler.codec.http.multipart.DiskFileUpload;
import io.netty.handler.codec.http.multipart.FileUpload;
import io.netty.handler.codec.http.multipart.HttpDataFactory;
import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;
import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.EndOfDataDecoderException;
import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.ErrorDataDecoderException;
import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.NotEnoughDataDecoderException;
import io.netty.handler.codec.http.multipart.InterfaceHttpData;
import io.netty.handler.codec.http.multipart.InterfaceHttpData.HttpDataType;
import org.waarp.common.crypto.ssl.WaarpSslUtility;
import org.waarp.common.database.DbSession;
import org.waarp.common.exception.CryptoException;
import org.waarp.common.json.JsonHandler;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.WaarpNettyUtil;
import org.waarp.common.utility.WaarpStringUtils;
import org.waarp.gateway.kernel.database.DbConstantGateway;
import org.waarp.gateway.kernel.exception.HttpForbiddenRequestException;
import org.waarp.gateway.kernel.exception.HttpIncorrectRequestException;
import org.waarp.gateway.kernel.exception.HttpInvalidAuthenticationException;
import org.waarp.gateway.kernel.exception.HttpMethodNotAllowedRequestException;
import org.waarp.gateway.kernel.exception.HttpNotFoundRequestException;

import java.io.File;
import java.io.IOException;
import java.nio.channels.ClosedChannelException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map.Entry;

/**
 * Handler for HTTP Rest support
 */
public abstract class HttpRestHandler
    extends SimpleChannelInboundHandler&lt;HttpObject&gt; {
  /**
   * Internal Logger
   */
<span class="fc" id="L88">  private static final WaarpLogger logger =</span>
<span class="fc" id="L89">      WaarpLoggerFactory.getLogger(HttpRestHandler.class);</span>

  /*
   * Note: Presence de BODY dans toutes les requetes/responses = Content-Length ou Transfer-Encoding HEAD:
   * response pas de BODY
   *
   */

<span class="fc" id="L97">  public enum METHOD {</span>
    /**
     * REST: Standard GET item
     * &lt;p&gt;
     * The GET method means retrieve whatever information (in the form of
     * an
     * entity) is identified by the
     * Request-URI. If the Request-URI refers to a data-producing process,
     * it is
     * the produced data which shall be
     * returned as the entity in the response and not the source text of
     * the
     * process, unless that text happens to
     * be the output of the process.
     */
<span class="fc" id="L112">    GET(HttpMethod.GET),</span>
    /**
     * REST: Update existing item
     * &lt;p&gt;
     * The PUT method requests that the enclosed entity be stored under the
     * supplied Request-URI.
     */
<span class="fc" id="L119">    PUT(HttpMethod.PUT),</span>
    /**
     * REST: Create a new item
     * &lt;p&gt;
     * The POST method is used to request that the origin server accept the
     * entity enclosed in the request as a
     * new subordinate of the resource identified by the Request-URI in the
     * Request-Line.
     */
<span class="fc" id="L128">    POST(HttpMethod.POST),</span>
    /**
     * REST: Delete existing item
     * &lt;p&gt;
     * The DELETE method requests that the origin server delete the resource
     * identified by the Request-URI.
     */
<span class="fc" id="L135">    DELETE(HttpMethod.DELETE),</span>
    /**
     * REST: what options are supported for the URI
     * &lt;p&gt;
     * The OPTIONS method represents a request for information about the
     * communication options available on the
     * request/response chain identified by the Request-URI. This method
     * allows
     * the client to determine the
     * options and/or requirements associated with a resource, or the
     * capabilities of a server, without implying a
     * resource action or initiating a resource retrieval.
     */
<span class="fc" id="L148">    OPTIONS(HttpMethod.OPTIONS),</span>
    /**
     * REST: as GET but no BODY (existence ? metadata ?)
     * &lt;p&gt;
     * The HEAD method is identical to GET except that the server MUST NOT
     * return a message-body in the response.
     */
<span class="fc" id="L155">    HEAD(HttpMethod.HEAD),</span>
    /**
     * REST: should not be used, use POST instead
     * &lt;p&gt;
     * The PATCH method requests that a set of changes described in the
     * request
     * entity be applied to the resource
     * identified by the Request-URI.
     */
<span class="fc" id="L164">    PATCH(HttpMethod.PATCH),</span>
    /**
     * REST: unknown usage
     * &lt;p&gt;
     * The TRACE method is used to invoke a remote, application-layer
     * loop-back
     * of the request message.
     */
<span class="fc" id="L172">    TRACE(HttpMethod.TRACE),</span>
    /**
     * REST: unknown
     * &lt;p&gt;
     * This specification reserves the method name CONNECT for use with a
     * proxy
     * that can dynamically switch to
     * being a tunnel
     */
<span class="fc" id="L181">    CONNECT(HttpMethod.CONNECT);</span>

    public final HttpMethod method;

<span class="fc" id="L185">    METHOD(final HttpMethod method) {</span>
<span class="fc" id="L186">      this.method = method;</span>
<span class="fc" id="L187">    }</span>
  }

<span class="fc" id="L190">  public static final HttpDataFactory factory =</span>
      new DefaultHttpDataFactory(DefaultHttpDataFactory.MINSIZE);
  // Disk if size exceed MINSIZE = 16K
  // XXX FIXME TODO to setup outside !
<span class="fc" id="L194">  public static String TempPath = &quot;J:/GG/ARK/TMP&quot;;</span>

  public static ChannelGroup group;

  /**
   * Initialize the Disk support
   *
   * @param tempPath system temp directory
   *
   * @throws IOException
   * @throws CryptoException
   */
  public static void initialize(final String tempPath) {
<span class="fc" id="L207">    TempPath = tempPath;</span>
<span class="fc" id="L208">    final File file = new File(tempPath);</span>
<span class="fc" id="L209">    file.mkdirs();//NOSONAR</span>
<span class="fc" id="L210">    DiskFileUpload.deleteOnExitTemporaryFile = true; // should delete file</span>
    // on exit (in normal
    // exit)
<span class="fc" id="L213">    DiskFileUpload.baseDirectory = TempPath; // system temp</span>
    // directory
<span class="fc" id="L215">    DiskAttribute.deleteOnExitTemporaryFile = true; // should delete file on</span>
    // exit (in normal exit)
<span class="fc" id="L217">    DiskAttribute.baseDirectory = TempPath; // system temp directory</span>
<span class="fc" id="L218">  }</span>

<span class="fc" id="L220">  public static final RestConfiguration defaultConfiguration =</span>
      new RestConfiguration();

  public HashMap&lt;String, RestMethodHandler&gt; restHashMap;
  public final RestConfiguration restConfiguration;
  protected final RootOptionsRestMethodHandler rootHandler;

  protected HttpPostRequestDecoder decoder;
<span class="fc" id="L228">  protected HttpResponseStatus status = HttpResponseStatus.OK;</span>

  protected HttpRequest request;
  protected RestMethodHandler handler;

  protected DbSession dbSession;

  private boolean willClose;

  /**
   * Arguments received
   */
  protected RestArgument arguments;
  /**
   * The only structure that might be needed is: ARGS_COOKIE (subset)
   */
  protected RestArgument response;
  /**
   * JSON decoded object
   */
  protected Object jsonObject;
  /**
   * Cumulative chunks
   */
  protected ByteBuf cumulativeBody;

<span class="fc" id="L254">  protected HttpRestHandler(final RestConfiguration config) {</span>
<span class="fc" id="L255">    restConfiguration = config;</span>
<span class="fc" id="L256">    rootHandler = new RootOptionsRestMethodHandler(config);</span>
<span class="fc" id="L257">  }</span>

  protected static class HttpCleanChannelFutureListener
      implements ChannelFutureListener {
    protected final HttpRestHandler handler;

    /**
     * @param handler
     */
<span class="nc" id="L266">    public HttpCleanChannelFutureListener(final HttpRestHandler handler) {</span>
<span class="nc" id="L267">      this.handler = handler;</span>
<span class="nc" id="L268">    }</span>

    @Override
    public final void operationComplete(final ChannelFuture future) {
<span class="nc" id="L272">      handler.clean();</span>
<span class="nc" id="L273">    }</span>
  }

  @Override
  public final void channelActive(final ChannelHandlerContext ctx)
      throws Exception {
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">    if (group != null) {</span>
<span class="fc" id="L280">      group.add(ctx.channel());</span>
    }
<span class="fc" id="L282">    super.channelActive(ctx);</span>
<span class="fc" id="L283">  }</span>

  /**
   * Clean method
   * &lt;p&gt;
   * Override if needed
   */
  protected final void clean() {
<span class="fc bfc" id="L291" title="All 2 branches covered.">    if (arguments != null) {</span>
<span class="fc" id="L292">      arguments.clean();</span>
<span class="fc" id="L293">      arguments = null;</span>
    }
<span class="fc bfc" id="L295" title="All 2 branches covered.">    if (response != null) {</span>
<span class="fc" id="L296">      response.clean();</span>
<span class="fc" id="L297">      response = null;</span>
    }
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">    if (decoder != null) {</span>
<span class="nc" id="L300">      decoder.cleanFiles();</span>
<span class="nc" id="L301">      decoder = null;</span>
    }
<span class="fc" id="L303">    handler = null;</span>
<span class="fc" id="L304">    cumulativeBody = null;</span>
<span class="fc" id="L305">    jsonObject = null;</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">    if (dbSession != null) {</span>
<span class="nc" id="L307">      dbSession.enUseConnectionNoDisconnect();</span>
<span class="nc" id="L308">      dbSession = null;</span>
    }
<span class="fc" id="L310">  }</span>

  /**
   * Called at the beginning of every new request
   * &lt;p&gt;
   * Override if needed
   */
  protected final void initialize() {
    // clean previous FileUpload if Any
<span class="fc" id="L319">    clean();</span>
<span class="fc" id="L320">    status = HttpResponseStatus.OK;</span>
<span class="fc" id="L321">    request = null;</span>
<span class="fc" id="L322">    setWillClose(false);</span>
<span class="fc" id="L323">    arguments = new RestArgument(JsonHandler.createObjectNode());</span>
<span class="fc" id="L324">    response = new RestArgument(JsonHandler.createObjectNode());</span>
<span class="fc" id="L325">  }</span>

  /**
   * @return the DbSession associated with the current request (might be Admin
   *     dbSession if none)
   */
  public final DbSession getDbSession() {
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">    return dbSession == null? DbConstantGateway.admin.getSession() : dbSession;</span>
  }

  /**
   * To be used for instance to check correctness of connection&lt;br&gt;
   * Note that ARG_METHOD is only set from current request. It might be also
   * set
   * from URI or HEADER and
   * therefore should be done in this method.
   *
   * @param ctx
   *
   * @throws HttpInvalidAuthenticationException
   */
  protected abstract void checkConnection(ChannelHandlerContext ctx)
      throws HttpInvalidAuthenticationException;

  /**
   * Method to set Cookies in httpResponse from response ObjectNode
   *
   * @param httpResponse
   */
  protected final void setCookies(final FullHttpResponse httpResponse) {
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">    if (response == null) {</span>
<span class="nc" id="L356">      return;</span>
    }
<span class="fc" id="L358">    final ObjectNode cookieON = response.getCookieArgs();</span>
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">    if (!cookieON.isMissingNode()) {</span>
<span class="fc" id="L360">      final Iterator&lt;Entry&lt;String, JsonNode&gt;&gt; iter = cookieON.fields();</span>
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">      while (iter.hasNext()) {</span>
<span class="nc" id="L362">        final Entry&lt;String, JsonNode&gt; entry = iter.next();</span>
<span class="nc" id="L363">        httpResponse.headers().add(HttpHeaderNames.SET_COOKIE,</span>
<span class="nc" id="L364">                                   ServerCookieEncoder.LAX.encode(</span>
<span class="nc" id="L365">                                       entry.getKey(),</span>
<span class="nc" id="L366">                                       entry.getValue().asText()));</span>
<span class="nc" id="L367">      }</span>
    }
<span class="fc" id="L369">  }</span>

  /**
   * Could be overwritten if necessary
   *
   * @return RestMethodHandler associated with the current context
   *
   * @throws HttpIncorrectRequestException
   * @throws HttpMethodNotAllowedRequestException
   * @throws HttpForbiddenRequestException
   */
  protected final RestMethodHandler getHandler()
      throws HttpMethodNotAllowedRequestException,
             HttpForbiddenRequestException {
<span class="fc" id="L383">    final METHOD method = arguments.getMethod();</span>
<span class="fc" id="L384">    final String uri = arguments.getBaseUri();</span>
<span class="fc" id="L385">    boolean restFound = false;</span>
<span class="fc" id="L386">    RestMethodHandler handlerNew = restHashMap.get(uri);</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">    if (handlerNew != null) {</span>
<span class="fc" id="L388">      handlerNew.checkHandlerSessionCorrectness(this, arguments, response);</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">      if (handlerNew.isMethodIncluded(method)) {</span>
<span class="fc" id="L390">        restFound = true;</span>
      }
    }
<span class="pc bpc" id="L393" title="1 of 4 branches missed.">    if (handlerNew == null &amp;&amp; method == METHOD.OPTIONS) {</span>
<span class="fc" id="L394">      handlerNew = rootHandler;</span>
      // use Options default handler
<span class="fc" id="L396">      restFound = true;</span>
    }
<span class="fc" id="L398">    logger.debug(&quot;{} {} {}&quot;, method, uri, restFound);</span>
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">    if (!restFound) {</span>
<span class="nc" id="L400">      throw new HttpMethodNotAllowedRequestException(</span>
          &quot;No Method found for that URI: &quot; + uri);
    }
<span class="fc" id="L403">    return handlerNew;</span>
  }

  @Override
  protected void channelRead0(final ChannelHandlerContext ctx,
                              final HttpObject msg) {
<span class="fc" id="L409">    logger.debug(&quot;Msg Received&quot;);</span>
    try {
<span class="fc bfc" id="L411" title="All 2 branches covered.">      if (msg instanceof HttpRequest) {</span>
<span class="fc" id="L412">        initialize();</span>
<span class="fc" id="L413">        request = (HttpRequest) msg;</span>
<span class="fc" id="L414">        arguments.setRequest(request);</span>
<span class="fc" id="L415">        final Iterator&lt;Entry&lt;CharSequence, CharSequence&gt;&gt; iterator =</span>
<span class="fc" id="L416">            request.headers().iteratorCharSequence();</span>
<span class="fc" id="L417">        arguments.setHeaderArgs(iterator);</span>
<span class="fc" id="L418">        arguments.setCookieArgs(request.headers().get(HttpHeaderNames.COOKIE));</span>
<span class="fc" id="L419">        logger.debug(&quot;DEBUG: {}&quot;, arguments);</span>
<span class="fc" id="L420">        checkConnection(ctx);</span>
<span class="fc" id="L421">        handler = getHandler();</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">        if (arguments.getMethod() == METHOD.OPTIONS) {</span>
<span class="fc" id="L423">          response.setFromArgument(arguments);</span>
<span class="fc" id="L424">          handler.optionsCommand(this, arguments, response);</span>
<span class="fc" id="L425">          finalizeSend(ctx);</span>
<span class="fc" id="L426">          return;</span>
        }
<span class="fc bfc" id="L428" title="All 2 branches covered.">        if (request instanceof FullHttpRequest) {</span>
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">          if (handler.isBodyJsonDecoded()) {</span>
<span class="fc" id="L430">            final ByteBuf buffer = ((FullHttpRequest) request).content();</span>
<span class="fc" id="L431">            jsonObject = getBodyJsonArgs(buffer);</span>
<span class="fc" id="L432">          } else {</span>
            // decoder for 1 chunk
<span class="nc" id="L434">            createDecoder();</span>
            // Not chunk version
<span class="nc" id="L436">            readAllHttpData();</span>
          }
<span class="fc" id="L438">          response.setFromArgument(arguments);</span>
<span class="fc" id="L439">          handler.endParsingRequest(this, arguments, response, jsonObject);</span>
<span class="fc" id="L440">          finalizeSend(ctx);</span>
<span class="fc" id="L441">          return;</span>
        }
        // no body yet
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">        if (!handler.isBodyJsonDecoded()) {</span>
<span class="nc" id="L445">          createDecoder();</span>
        }
<span class="fc" id="L447">      } else {</span>
        // New chunk is received
<span class="fc bfc" id="L449" title="All 2 branches covered.">        if (handler != null) {</span>
<span class="nc" id="L450">          bodyChunk(ctx, (HttpContent) msg);</span>
        }
      }
<span class="nc" id="L453">    } catch (final HttpIncorrectRequestException e1) {</span>
      // real error =&gt; 400
<span class="nc bnc" id="L455" title="All 2 branches missed.">      if (handler != null) {</span>
<span class="nc" id="L456">        status =</span>
<span class="nc" id="L457">            handler.handleException(this, arguments, response, jsonObject, e1);</span>
      }
<span class="nc bnc" id="L459" title="All 2 branches missed.">      if (status == HttpResponseStatus.OK) {</span>
<span class="nc" id="L460">        status = HttpResponseStatus.BAD_REQUEST;</span>
      }
<span class="nc" id="L462">      logger.warn(&quot;Error: {}&quot;, e1.getMessage(), e1);</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">      if (response.getDetail().isEmpty()) {</span>
<span class="nc" id="L464">        response.setDetail(e1.getMessage());</span>
      }
<span class="nc bnc" id="L466" title="All 2 branches missed.">      if (handler != null) {</span>
<span class="nc" id="L467">        finalizeSend(ctx);</span>
      } else {
<span class="nc" id="L469">        forceClosing(ctx);</span>
      }
<span class="nc" id="L471">    } catch (final HttpMethodNotAllowedRequestException e1) {</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">      if (handler != null) {</span>
<span class="nc" id="L473">        status =</span>
<span class="nc" id="L474">            handler.handleException(this, arguments, response, jsonObject, e1);</span>
      }
<span class="nc bnc" id="L476" title="All 2 branches missed.">      if (status == HttpResponseStatus.OK) {</span>
<span class="nc" id="L477">        status = HttpResponseStatus.METHOD_NOT_ALLOWED;</span>
      }
<span class="nc" id="L479">      logger.warn(&quot;Error: {}&quot;, e1.getMessage());</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">      if (response.getDetail().isEmpty()) {</span>
<span class="nc" id="L481">        response.setDetail(e1.getMessage());</span>
      }
<span class="nc bnc" id="L483" title="All 2 branches missed.">      if (handler != null) {</span>
<span class="nc" id="L484">        finalizeSend(ctx);</span>
      } else {
<span class="nc" id="L486">        forceClosing(ctx);</span>
      }
<span class="nc" id="L488">    } catch (final HttpForbiddenRequestException e1) {</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">      if (handler != null) {</span>
<span class="nc" id="L490">        status =</span>
<span class="nc" id="L491">            handler.handleException(this, arguments, response, jsonObject, e1);</span>
      }
<span class="nc bnc" id="L493" title="All 2 branches missed.">      if (status == HttpResponseStatus.OK) {</span>
<span class="nc" id="L494">        status = HttpResponseStatus.FORBIDDEN;</span>
      }
<span class="nc" id="L496">      logger.warn(&quot;Error: {}&quot;, e1.getMessage());</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">      if (response.getDetail().isEmpty()) {</span>
<span class="nc" id="L498">        response.setDetail(e1.getMessage());</span>
      }
<span class="nc bnc" id="L500" title="All 2 branches missed.">      if (handler != null) {</span>
<span class="nc" id="L501">        finalizeSend(ctx);</span>
      } else {
<span class="nc" id="L503">        forceClosing(ctx);</span>
      }
<span class="fc" id="L505">    } catch (final HttpInvalidAuthenticationException e1) {</span>
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">      if (handler != null) {</span>
<span class="nc" id="L507">        status =</span>
<span class="nc" id="L508">            handler.handleException(this, arguments, response, jsonObject, e1);</span>
      }
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">      if (status == HttpResponseStatus.OK) {</span>
<span class="nc" id="L511">        status = HttpResponseStatus.UNAUTHORIZED;</span>
      }
<span class="fc" id="L513">      logger.warn(&quot;Error: {}&quot;, e1.getMessage());</span>
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">      if (response.getDetail().isEmpty()) {</span>
<span class="fc" id="L515">        response.setDetail(e1.getMessage());</span>
      }
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">      if (handler != null) {</span>
<span class="nc" id="L518">        finalizeSend(ctx);</span>
      } else {
<span class="fc" id="L520">        forceClosing(ctx);</span>
      }
<span class="fc" id="L522">    } catch (final HttpNotFoundRequestException e1) {</span>
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">      if (handler != null) {</span>
<span class="fc" id="L524">        status =</span>
<span class="fc" id="L525">            handler.handleException(this, arguments, response, jsonObject, e1);</span>
      }
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">      if (status == HttpResponseStatus.OK) {</span>
<span class="nc" id="L528">        status = HttpResponseStatus.NOT_FOUND;</span>
      }
<span class="fc" id="L530">      logger.warn(&quot;Error: {}&quot;, e1.getMessage());</span>
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">      if (response.getDetail().isEmpty()) {</span>
<span class="fc" id="L532">        response.setDetail(e1.getMessage());</span>
      }
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">      if (handler != null) {</span>
<span class="fc" id="L535">        finalizeSend(ctx);</span>
      } else {
<span class="nc" id="L537">        forceClosing(ctx);</span>
      }
<span class="pc" id="L539">    }</span>
<span class="fc" id="L540">  }</span>

  /**
   * Create the decoder
   *
   * @throws HttpIncorrectRequestException
   */
  protected final void createDecoder() throws HttpIncorrectRequestException {
<span class="nc" id="L548">    final HttpMethod method = request.method();</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">    if (!method.equals(HttpMethod.HEAD)) {</span>
      // in order decoder allows to parse
<span class="nc" id="L551">      request.setMethod(HttpMethod.POST);</span>
    }
    try {
<span class="nc" id="L554">      decoder = new HttpPostRequestDecoder(factory, request);</span>
<span class="nc" id="L555">    } catch (final ErrorDataDecoderException e1) {</span>
<span class="nc" id="L556">      status = HttpResponseStatus.NOT_ACCEPTABLE;</span>
<span class="nc" id="L557">      throw new HttpIncorrectRequestException(e1);</span>
<span class="nc" id="L558">    } catch (final Exception e1) {</span>
      // GETDOWNLOAD Method: should not try to create a HttpPostRequestDecoder
      // So OK but stop here
<span class="nc" id="L561">      status = HttpResponseStatus.NOT_ACCEPTABLE;</span>
<span class="nc" id="L562">      throw new HttpIncorrectRequestException(e1);</span>
<span class="nc" id="L563">    }</span>
<span class="nc" id="L564">  }</span>

  /**
   * Read all InterfaceHttpData from finished transfer
   *
   * @throws HttpIncorrectRequestException
   */
  protected final void readAllHttpData() throws HttpIncorrectRequestException {
    final List&lt;InterfaceHttpData&gt; datas;
    try {
<span class="nc" id="L574">      datas = decoder.getBodyHttpDatas();</span>
<span class="nc" id="L575">    } catch (final NotEnoughDataDecoderException e1) {</span>
      // Should not be!
<span class="nc" id="L577">      logger.warn(&quot;decoder issue: {}&quot;, e1.getMessage());</span>
<span class="nc" id="L578">      status = HttpResponseStatus.NOT_ACCEPTABLE;</span>
<span class="nc" id="L579">      throw new HttpIncorrectRequestException(e1);</span>
<span class="nc" id="L580">    }</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">    for (final InterfaceHttpData data : datas) {</span>
<span class="nc" id="L582">      readHttpData(data);</span>
<span class="nc" id="L583">    }</span>
<span class="nc" id="L584">  }</span>

  /**
   * Read one Data
   *
   * @param data
   *
   * @throws HttpIncorrectRequestException
   */
  protected final void readHttpData(final InterfaceHttpData data)
      throws HttpIncorrectRequestException {
<span class="nc bnc" id="L595" title="All 2 branches missed.">    if (data.getHttpDataType() == HttpDataType.Attribute) {</span>
<span class="nc" id="L596">      final ObjectNode body = arguments.getBody();</span>
      try {
<span class="nc" id="L598">        body.put(data.getName(), ((Attribute) data).getValue());</span>
<span class="nc" id="L599">      } catch (final IOException e) {</span>
<span class="nc" id="L600">        throw new HttpIncorrectRequestException(&quot;Bad reading&quot;, e);</span>
<span class="nc" id="L601">      }</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">    } else if (data.getHttpDataType() == HttpDataType.FileUpload) {</span>
<span class="nc" id="L603">      final FileUpload fileUpload = (FileUpload) data;</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">      if (fileUpload.isCompleted()) {</span>
<span class="nc" id="L605">        handler.getFileUpload(this, fileUpload, arguments, response);</span>
      } else {
<span class="nc" id="L607">        logger.warn(&quot;File still pending but should not&quot;);</span>
<span class="nc" id="L608">        fileUpload.delete();</span>
<span class="nc" id="L609">        status = HttpResponseStatus.INTERNAL_SERVER_ERROR;</span>
<span class="nc" id="L610">        throw new HttpIncorrectRequestException(</span>
            &quot;File still pending but should not&quot;);
      }
<span class="nc" id="L613">    } else {</span>
<span class="nc" id="L614">      logger.warn(&quot;Unknown element: &quot; + data);</span>
    }
<span class="nc" id="L616">  }</span>

  /**
   * To allow quick answer even if in very bad shape
   *
   * @param ctx
   */
  protected final void forceClosing(final ChannelHandlerContext ctx) {
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">    if (status == HttpResponseStatus.OK) {</span>
<span class="nc" id="L625">      status = HttpResponseStatus.INTERNAL_SERVER_ERROR;</span>
    }
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">    if (ctx.channel().isActive()) {</span>
<span class="fc" id="L628">      setWillClose(true);</span>
<span class="fc" id="L629">      final String answer =</span>
<span class="fc" id="L630">          &quot;&lt;html&gt;&lt;body&gt;Error &quot; + status.reasonPhrase() + &quot;&lt;/body&gt;&lt;/html&gt;&quot;;</span>
<span class="fc" id="L631">      final FullHttpResponse httpResponse = getResponse(</span>
<span class="fc" id="L632">          Unpooled.wrappedBuffer(answer.getBytes(WaarpStringUtils.UTF8)));</span>
<span class="fc" id="L633">      httpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE, &quot;text/html&quot;);</span>
<span class="fc" id="L634">      httpResponse.headers().set(HttpHeaderNames.REFERER, request.uri());</span>
<span class="fc" id="L635">      final ChannelFuture future = ctx.writeAndFlush(httpResponse);</span>
<span class="fc" id="L636">      logger.debug(&quot;Will close&quot;);</span>
<span class="fc" id="L637">      future.addListener(WaarpSslUtility.SSLCLOSE);</span>
    }
<span class="fc" id="L639">    clean();</span>
<span class="fc" id="L640">  }</span>

  /**
   * @param content
   *
   * @return the Http Response according to the status and the content if not
   *     null (setting the CONTENT_LENGTH)
   */
  public final FullHttpResponse getResponse(final ByteBuf content) {
    // Decide whether to close the connection or not.
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">    if (request == null) {</span>
      final FullHttpResponse httpResponse;
<span class="nc bnc" id="L652" title="All 2 branches missed.">      if (content == null) {</span>
<span class="nc" id="L653">        httpResponse =</span>
            new DefaultFullHttpResponse(HttpVersion.HTTP_1_0, status);
      } else {
<span class="nc" id="L656">        httpResponse =</span>
            new DefaultFullHttpResponse(HttpVersion.HTTP_1_0, status, content);
<span class="nc" id="L658">        httpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH,</span>
<span class="nc" id="L659">                                   content.array().length);</span>
      }
<span class="nc" id="L661">      setCookies(httpResponse);</span>
<span class="nc" id="L662">      setWillClose(true);</span>
<span class="nc" id="L663">      return httpResponse;</span>
    }
<span class="fc" id="L665">    boolean keepAlive = HttpUtil.isKeepAlive(request);</span>
<span class="fc bfc" id="L666" title="All 4 branches covered.">    setWillClose(isWillClose() || status != HttpResponseStatus.OK ||</span>
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">                 HttpHeaderValues.CLOSE.contentEqualsIgnoreCase(</span>
<span class="fc" id="L668">                     request.headers().get(HttpHeaderNames.CONNECTION)) ||</span>
<span class="pc bpc" id="L669" title="3 of 4 branches missed.">                 request.protocolVersion().equals(HttpVersion.HTTP_1_0) &amp;&amp;</span>
                 !keepAlive);
<span class="fc bfc" id="L671" title="All 2 branches covered.">    if (isWillClose()) {</span>
<span class="fc" id="L672">      keepAlive = false;</span>
    }
    // Build the response object.
    final FullHttpResponse httpResponse;
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">    if (content != null) {</span>
<span class="fc" id="L677">      httpResponse =</span>
<span class="fc" id="L678">          new DefaultFullHttpResponse(request.protocolVersion(), status,</span>
                                      content);
<span class="fc" id="L680">      httpResponse.headers()</span>
<span class="fc" id="L681">                  .set(HttpHeaderNames.CONTENT_LENGTH, content.array().length);</span>
    } else {
<span class="nc" id="L683">      httpResponse =</span>
<span class="nc" id="L684">          new DefaultFullHttpResponse(request.protocolVersion(), status);</span>
    }
<span class="fc bfc" id="L686" title="All 2 branches covered.">    if (keepAlive) {</span>
<span class="fc" id="L687">      httpResponse.headers()</span>
<span class="fc" id="L688">                  .set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);</span>
    }
<span class="fc" id="L690">    setCookies(httpResponse);</span>
<span class="fc" id="L691">    return httpResponse;</span>
  }

  /**
   * Method that get a chunk of data
   *
   * @param ctx
   * @param chunk
   *
   * @throws HttpIncorrectRequestException
   * @throws HttpInvalidAuthenticationException
   * @throws HttpNotFoundRequestException
   */
  protected final void bodyChunk(final ChannelHandlerContext ctx,
                                 final HttpContent chunk)
      throws HttpIncorrectRequestException, HttpInvalidAuthenticationException,
             HttpNotFoundRequestException {
    // New chunk is received: only for Post!
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">    if (handler.isBodyJsonDecoded()) {</span>
<span class="fc" id="L710">      final ByteBuf buffer = chunk.content();</span>
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">      if (cumulativeBody != null) {</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">        if (buffer.isReadable()) {</span>
<span class="nc" id="L713">          cumulativeBody = Unpooled.wrappedBuffer(cumulativeBody, buffer);</span>
        }
      } else {
<span class="fc" id="L716">        cumulativeBody = buffer.slice();</span>
      }
<span class="fc" id="L718">    } else {</span>
      try {
<span class="nc" id="L720">        decoder.offer(chunk);</span>
<span class="nc" id="L721">      } catch (final ErrorDataDecoderException e1) {</span>
<span class="nc" id="L722">        status = HttpResponseStatus.NOT_ACCEPTABLE;</span>
<span class="nc" id="L723">        throw new HttpIncorrectRequestException(e1);</span>
<span class="nc" id="L724">      }</span>
      // example of reading chunk by chunk (minimize memory usage due to
      // Factory)
<span class="nc" id="L727">      readHttpDataChunkByChunk();</span>
    }
    // example of reading only if at the end
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">    if (chunk instanceof LastHttpContent) {</span>
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">      if (handler.isBodyJsonDecoded()) {</span>
<span class="fc" id="L732">        jsonObject = getBodyJsonArgs(cumulativeBody);</span>
<span class="fc" id="L733">        WaarpNettyUtil.release(cumulativeBody);</span>
<span class="fc" id="L734">        cumulativeBody = null;</span>
      }
<span class="fc" id="L736">      response.setFromArgument(arguments);</span>
<span class="nc" id="L737">      handler.endParsingRequest(this, arguments, response, jsonObject);</span>
<span class="nc" id="L738">      finalizeSend(ctx);</span>
    }
<span class="nc" id="L740">  }</span>

  protected final void finalizeSend(final ChannelHandlerContext ctx) {
    final ChannelFuture future;
<span class="fc bfc" id="L744" title="All 2 branches covered.">    if (arguments.getMethod() == METHOD.OPTIONS) {</span>
<span class="fc" id="L745">      future = handler.sendOptionsResponse(this, ctx, response, status);</span>
    } else {
<span class="fc" id="L747">      future = handler.sendResponse(this, ctx, arguments, response, jsonObject,</span>
                                    status);
    }
<span class="fc bfc" id="L750" title="All 2 branches covered.">    if (future != null) {</span>
<span class="fc" id="L751">      future.addListener(WaarpSslUtility.SSLCLOSE);</span>
    }
<span class="fc" id="L753">    clean();</span>
<span class="fc" id="L754">    logger.debug(&quot;Cleaned&quot;);</span>
<span class="fc" id="L755">  }</span>

  /**
   * Get Body args as JSON body
   *
   * @param data
   *
   * @throws HttpIncorrectRequestException
   */
  protected final Object getBodyJsonArgs(final ByteBuf data)
      throws HttpIncorrectRequestException {
<span class="pc bpc" id="L766" title="1 of 4 branches missed.">    if (data == null || data.readableBytes() == 0) {</span>
<span class="fc" id="L767">      return null;</span>
    }
<span class="fc" id="L769">    return handler.getBody(this, data, arguments, response);</span>
  }

  /**
   * Read request by chunk and getting values from chunk to chunk
   *
   * @throws HttpIncorrectRequestException
   */
  protected final void readHttpDataChunkByChunk()
      throws HttpIncorrectRequestException {
    try {
<span class="nc bnc" id="L780" title="All 2 branches missed.">      while (decoder.hasNext()) {</span>
<span class="nc" id="L781">        final InterfaceHttpData data = decoder.next();</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">        if (data != null) {</span>
          // new value
<span class="nc" id="L784">          readHttpData(data);</span>
        }
<span class="nc" id="L786">      }</span>
<span class="nc" id="L787">    } catch (final EndOfDataDecoderException e1) {</span>
      // end
<span class="nc" id="L789">    }</span>
<span class="nc" id="L790">  }</span>

  @Override
  public final void exceptionCaught(final ChannelHandlerContext ctx,
                                    final Throwable cause) {
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">    if (ctx.channel().isActive()) {</span>
<span class="nc bnc" id="L796" title="All 4 branches missed.">      if (cause != null &amp;&amp; cause.getMessage() != null) {</span>
<span class="nc" id="L797">        logger.warn(&quot;Exception {}&quot;, cause.getMessage());</span>
      } else {
<span class="nc" id="L799">        logger.warn(&quot;Exception Received&quot;, cause);</span>
      }
<span class="nc bnc" id="L801" title="All 4 branches missed.">      if (cause instanceof ClosedChannelException ||</span>
          cause instanceof IOException) {
<span class="nc" id="L803">        return;</span>
      }
<span class="nc bnc" id="L805" title="All 2 branches missed.">      if (handler != null) {</span>
<span class="nc" id="L806">        status = handler.handleException(this, arguments, response, jsonObject,</span>
                                         (Exception) cause);
      }
<span class="nc bnc" id="L809" title="All 2 branches missed.">      if (status == HttpResponseStatus.OK) {</span>
<span class="nc" id="L810">        status = HttpResponseStatus.INTERNAL_SERVER_ERROR;</span>
      }
<span class="nc bnc" id="L812" title="All 2 branches missed.">      if (handler != null) {</span>
<span class="nc" id="L813">        finalizeSend(ctx);</span>
      } else {
<span class="nc" id="L815">        forceClosing(ctx);</span>
      }
    }
<span class="fc" id="L818">  }</span>

  @Override
  public void channelInactive(final ChannelHandlerContext ctx)
      throws Exception {
<span class="fc" id="L823">    super.channelInactive(ctx);</span>
<span class="fc" id="L824">    clean();</span>
<span class="fc" id="L825">  }</span>

  /**
   * @return the status
   */
  public final HttpResponseStatus getStatus() {
<span class="nc" id="L831">    return status;</span>
  }

  /**
   * @param status the status to set
   */
  public final void setStatus(final HttpResponseStatus status) {
<span class="fc" id="L838">    this.status = status;</span>
<span class="fc" id="L839">  }</span>

  /**
   * @return the request
   */
  public final HttpRequest getRequest() {
<span class="fc" id="L845">    return request;</span>
  }

  /**
   * @return the willClose
   */
  public final boolean isWillClose() {
<span class="fc" id="L852">    return willClose;</span>
  }

  /**
   * @param willClose the willClose to set
   */
  public final void setWillClose(final boolean willClose) {
<span class="fc" id="L859">    this.willClose = willClose;</span>
<span class="fc" id="L860">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>