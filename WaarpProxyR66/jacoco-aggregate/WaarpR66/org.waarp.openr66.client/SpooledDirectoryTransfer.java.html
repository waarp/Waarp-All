<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SpooledDirectoryTransfer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Proxy in R66 protocol</a> &gt; <a href="../index.html" class="el_bundle">WaarpR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.client</a> &gt; <span class="el_source">SpooledDirectoryTransfer.java</span></div><h1>SpooledDirectoryTransfer.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.openr66.client;

import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.waarp.common.database.exception.WaarpDatabaseException;
import org.waarp.common.filemonitor.FileMonitor;
import org.waarp.common.filemonitor.FileMonitor.FileItem;
import org.waarp.common.filemonitor.FileMonitorCommandFactory;
import org.waarp.common.filemonitor.FileMonitorCommandRunnableFuture;
import org.waarp.common.filemonitor.RegexFileFilter;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.logging.WaarpSlf4JLoggerFactory;
import org.waarp.common.utility.WaarpShutdownHook;
import org.waarp.common.utility.WaarpThreadFactory;
import org.waarp.common.xml.XmlDecl;
import org.waarp.common.xml.XmlHash;
import org.waarp.common.xml.XmlType;
import org.waarp.common.xml.XmlUtil;
import org.waarp.common.xml.XmlValue;
import org.waarp.openr66.configuration.FileBasedConfiguration;
import org.waarp.openr66.context.ErrorCode;
import org.waarp.openr66.context.R66Result;
import org.waarp.openr66.context.task.SpooledInformTask;
import org.waarp.openr66.database.data.DbRule;
import org.waarp.openr66.database.data.DbTaskRunner;
import org.waarp.openr66.protocol.configuration.Configuration;
import org.waarp.openr66.protocol.configuration.Messages;
import org.waarp.openr66.protocol.localhandler.packet.BusinessRequestPacket;
import org.waarp.openr66.protocol.networkhandler.NetworkTransaction;
import org.waarp.openr66.protocol.utils.ChannelUtils;
import org.waarp.openr66.protocol.utils.R66Future;

import java.io.File;
import java.io.FileFilter;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import static org.waarp.common.database.DbConstant.*;
import static org.waarp.openr66.context.ErrorCode.*;

/**
 * Direct Transfer from a client with or without database connection or Submit
 * Transfer from a client with
 * database connection to transfer files from a spooled directory to possibly
 * multiple hosts at once.&lt;br&gt;
 * -to Hosts will have to be separated by ','.&lt;br&gt;
 * -rule Rule to be used to send files to partners&lt;br&gt;
 * &lt;br&gt;
 * Mandatory additional elements:&lt;br&gt;
 * -directory source (directory to spooled on ; many directories can be
 * specified using a comma separated list
 * as &quot;directory1,directory2,directory3&quot;)&lt;br&gt;
 * -statusfile file (file to use as permanent status (if process is killed or
 * aborts))&lt;br&gt;
 * -stopfile file (file when created will stop the dameon)&lt;br&gt;
 * Other options:&lt;br&gt;
 * -info info to be send with the file as filetransfer information&lt;br&gt;
 * -md5 for md5 option&lt;br&gt;
 * -block size for block size specification&lt;br&gt;
 * -nolog to prevent saving action locally&lt;br&gt;
 * -regex regex (regular expression to filter file names from directory
 * source)&lt;br&gt;
 * -elapse elapse (elapse time in ms &gt; 100 ms between 2 checks of the
 * directory)&lt;br&gt;
 * -submit (to submit only: default: only one between submit and direct is
 * allowed)&lt;br&gt;
 * -direct (to directly transfer only: only one between submit and direct is
 * allowed)&lt;br&gt;
 * -recursive (to scan recursively from the root)&lt;br&gt;
 * -waarp WaarpHosts (seperated by ',') to inform of running spooled directory
 * (information stays in memory of
 * Waarp servers, not in database)&lt;br&gt;
 * -name name to be used as name in list printing in Waarp servers. Note this
 * name must be unique
 * globally.&lt;br&gt;
 * -elapseWaarp elapse to specify a specific timing &gt; 1000ms between to
 * information sent to Waarp servers
 * (default: 5000ms)&lt;br&gt;
 * -parallel to allow (default) parallelism between send actions and
 * information&lt;br&gt;
 * -sequential to not allow parallelism between send actions and
 * information&lt;br&gt;
 * -limitParallel limit to specify the number of concurrent actions in -direct
 * mode only&lt;br&gt;
 * -minimalSize limit to specify the minimal size of each file that will be
 * transferred (default: no
 * limit)&lt;br&gt;
 * -notlogWarn | -logWarn to deactivate or activate (default) the logging in
 * Warn mode of Send/Remove
 * information of the spool&lt;br&gt;
 */
public class SpooledDirectoryTransfer implements Runnable {
  public static final String NEEDFULL = &quot;needfull&quot;;
  public static final String PARTIALOK = &quot;Validated&quot;;

  /**
   * Internal Logger
   */
  protected static volatile WaarpLogger logger;

<span class="fc" id="L124">  protected static String infoArgs =</span>
<span class="fc" id="L125">      Messages.getString(&quot;SpooledDirectoryTransfer.0&quot;); //$NON-NLS-1$</span>

  protected static final String NO_INFO_ARGS = &quot;noinfo&quot;;

  protected final R66Future future;

  public final String name;

  protected final List&lt;String&gt; directory;

  protected final String statusFile;

  protected final String stopFile;

  protected final String ruleName;

  protected final String fileInfo;

  protected final boolean isMD5;

  protected final List&lt;String&gt; remoteHosts;

  protected final String regexFilter;

  protected final List&lt;String&gt; waarpHosts;

  protected final int blocksize;

  protected final long elapseTime;

  protected final long elapseWaarpTime;

  protected final boolean parallel;

  protected final int limitParallelTasks;

  protected final boolean submit;

  protected final boolean nolog;

  protected final boolean recurs;

  protected final long minimalSize;

  protected final boolean normalInfoAsWarn;

  protected final boolean ignoreAlreadyUsed;

  protected final NetworkTransaction networkTransaction;

  protected FileMonitor monitor;

  private long sent;
  private long error;

  /**
   * @param future
   * @param arguments
   * @param networkTransaction
   */
  public SpooledDirectoryTransfer(final R66Future future,
                                  final Arguments arguments,
<span class="fc" id="L187">                                  final NetworkTransaction networkTransaction) {</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">    if (logger == null) {</span>
<span class="fc" id="L189">      logger = WaarpLoggerFactory.getLogger(SpooledDirectoryTransfer.class);</span>
    }
<span class="fc" id="L191">    this.future = future;</span>
<span class="fc" id="L192">    this.name = arguments.name;</span>
<span class="fc" id="L193">    this.directory = arguments.localDirectory;</span>
<span class="fc" id="L194">    statusFile = arguments.statusFile;</span>
<span class="fc" id="L195">    stopFile = arguments.stopFile;</span>
<span class="fc" id="L196">    this.ruleName = arguments.rule;</span>
<span class="fc" id="L197">    this.fileInfo = arguments.fileInfo;</span>
<span class="fc" id="L198">    this.isMD5 = arguments.isMd5;</span>
<span class="fc" id="L199">    this.remoteHosts = arguments.remoteHosts;</span>
<span class="fc" id="L200">    this.blocksize = arguments.block;</span>
<span class="fc" id="L201">    regexFilter = arguments.regex;</span>
<span class="fc" id="L202">    elapseTime = arguments.elapsed;</span>
<span class="fc" id="L203">    this.submit = arguments.toSubmit;</span>
<span class="pc bpc" id="L204" title="3 of 4 branches missed.">    this.nolog = arguments.noLog &amp;&amp; !arguments.toSubmit;</span>
<span class="fc" id="L205">    AbstractTransfer.nolog = this.nolog;</span>
<span class="fc" id="L206">    recurs = arguments.recursive;</span>
<span class="fc" id="L207">    elapseWaarpTime = arguments.elapsedWaarp;</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">    if (this.submit) {</span>
<span class="fc" id="L209">      this.parallel = false;</span>
    } else {
<span class="fc" id="L211">      this.parallel = arguments.isParallel;</span>
    }
<span class="fc" id="L213">    limitParallelTasks = arguments.limitParallel;</span>
<span class="fc" id="L214">    waarpHosts = arguments.waarpHosts;</span>
<span class="fc" id="L215">    this.minimalSize = arguments.minimalSize;</span>
<span class="fc" id="L216">    normalInfoAsWarn = arguments.logWarn;</span>
<span class="fc" id="L217">    this.ignoreAlreadyUsed = arguments.ignoreAlreadyUsed;</span>
<span class="fc" id="L218">    this.networkTransaction = networkTransaction;</span>
<span class="fc" id="L219">  }</span>

  @Override
  public void run() {
<span class="fc" id="L223">    setSent(0);</span>
<span class="fc" id="L224">    setError(0);</span>
    // first check if rule is for SEND
    final DbRule dbrule;
    try {
<span class="fc" id="L228">      dbrule = new DbRule(ruleName);</span>
<span class="nc" id="L229">    } catch (final WaarpDatabaseException e1) {</span>
<span class="nc" id="L230">      logger.error(Messages.getString(&quot;Transfer.18&quot;), e1); //$NON-NLS-1$</span>
<span class="nc" id="L231">      future.setFailure(e1);</span>
<span class="nc" id="L232">      if (Configuration.configuration</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">              .getShutdownConfiguration().serviceFuture != null) {</span>
<span class="nc" id="L234">        Configuration.configuration.getShutdownConfiguration().serviceFuture</span>
<span class="nc" id="L235">            .setFailure(new Exception(</span>
<span class="nc" id="L236">                Messages.getString(&quot;Transfer.18&quot;) + e1.getMessage()));</span>
      }
<span class="nc" id="L238">      return;</span>
<span class="fc" id="L239">    }</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">    if (dbrule.isRecvMode()) {</span>
<span class="nc" id="L241">      logger.error(</span>
<span class="nc" id="L242">          Messages.getString(&quot;SpooledDirectoryTransfer.5&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L243">      future.cancel();</span>
<span class="nc" id="L244">      if (Configuration.configuration</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">              .getShutdownConfiguration().serviceFuture != null) {</span>
<span class="nc" id="L246">        Configuration.configuration.getShutdownConfiguration().serviceFuture</span>
<span class="nc" id="L247">            .setFailure(new Exception(</span>
<span class="nc" id="L248">                Messages.getString(&quot;SpooledDirectoryTransfer.5&quot;)));</span>
      }
<span class="nc" id="L250">      return;</span>
    }
<span class="fc" id="L252">    final File status = new File(statusFile);</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">    if (status.isDirectory()) {</span>
<span class="nc" id="L254">      logger.error(</span>
<span class="nc" id="L255">          Messages.getString(&quot;SpooledDirectoryTransfer.6&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L256">      future.cancel();</span>
<span class="nc" id="L257">      if (Configuration.configuration</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">              .getShutdownConfiguration().serviceFuture != null) {</span>
<span class="nc" id="L259">        Configuration.configuration.getShutdownConfiguration().serviceFuture</span>
<span class="nc" id="L260">            .setFailure(new Exception(</span>
<span class="nc" id="L261">                Messages.getString(&quot;SpooledDirectoryTransfer.6&quot;)));</span>
      }
<span class="nc" id="L263">      return;</span>
    }
<span class="fc" id="L265">    final File stop = new File(stopFile);</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">    if (stop.isDirectory()) {</span>
<span class="nc" id="L267">      logger.error(</span>
<span class="nc" id="L268">          Messages.getString(&quot;SpooledDirectoryTransfer.7&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L269">      future.cancel();</span>
<span class="nc" id="L270">      if (Configuration.configuration</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">              .getShutdownConfiguration().serviceFuture != null) {</span>
<span class="nc" id="L272">        Configuration.configuration.getShutdownConfiguration().serviceFuture</span>
<span class="nc" id="L273">            .setFailure(new Exception(</span>
<span class="nc" id="L274">                Messages.getString(&quot;SpooledDirectoryTransfer.7&quot;)));</span>
      }
<span class="nc" id="L276">      return;</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">    } else if (stop.exists()) {</span>
<span class="nc" id="L278">      logger</span>
<span class="nc" id="L279">          .warn(Messages.getString(&quot;SpooledDirectoryTransfer.8&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L280">      future.setSuccess();</span>
<span class="nc" id="L281">      if (Configuration.configuration</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">              .getShutdownConfiguration().serviceFuture != null) {</span>
<span class="nc" id="L283">        Configuration.configuration.getShutdownConfiguration().serviceFuture</span>
<span class="nc" id="L284">            .setFailure(new Exception(</span>
<span class="nc" id="L285">                Messages.getString(&quot;SpooledDirectoryTransfer.8&quot;)));</span>
      }
<span class="nc" id="L287">      return;</span>
    }
<span class="fc bfc" id="L289" title="All 2 branches covered.">    for (final String dirname : directory) {</span>
<span class="fc" id="L290">      final File dir = new File(dirname);</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">      if (!dir.isDirectory()) {</span>
<span class="nc" id="L292">        logger.error(Messages.getString(&quot;SpooledDirectoryTransfer.9&quot;) + &quot; : &quot; +</span>
                     dir); //$NON-NLS-1$
<span class="nc" id="L294">        future.cancel();</span>
<span class="nc" id="L295">        if (Configuration.configuration</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">                .getShutdownConfiguration().serviceFuture != null) {</span>
<span class="nc" id="L297">          Configuration.configuration.getShutdownConfiguration().serviceFuture</span>
<span class="nc" id="L298">              .setFailure(new Exception(</span>
<span class="nc" id="L299">                  Messages.getString(&quot;SpooledDirectoryTransfer.9&quot;)));</span>
        }
<span class="nc" id="L301">        return;</span>
      }
<span class="fc" id="L303">    }</span>
<span class="fc" id="L304">    FileFilter filter = null;</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">    if (regexFilter != null) {</span>
<span class="nc" id="L306">      filter = new RegexFileFilter(regexFilter, minimalSize);</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">    } else if (minimalSize &gt; 0) {</span>
<span class="fc" id="L308">      filter = new RegexFileFilter(minimalSize);</span>
    }
<span class="fc" id="L310">    final FileMonitorCommandRunnableFuture commandValidFile =</span>
<span class="fc" id="L311">        initializeFileMonitorCommandRunnableFuture(status, stop, filter);</span>
    File dir;
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">    if (!monitor.initialized()) {</span>
      // wrong
<span class="nc" id="L315">      logger.error(</span>
<span class="nc" id="L316">          Messages.getString(&quot;Configuration.WrongInit&quot;) + &quot; : already running&quot;);</span>
<span class="nc" id="L317">      future.cancel();</span>
<span class="nc" id="L318">      if (Configuration.configuration</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">              .getShutdownConfiguration().serviceFuture != null) {</span>
<span class="nc" id="L320">        Configuration.configuration.getShutdownConfiguration().serviceFuture</span>
<span class="nc" id="L321">            .setFailure(new Exception(</span>
<span class="nc" id="L322">                Messages.getString(&quot;Configuration.WrongInit&quot;) +</span>
                &quot; : already running&quot;));
      }
<span class="nc" id="L325">      return;</span>
    }
<span class="fc" id="L327">    commandValidFile.setMonitor(monitor);</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">    if (parallel) {</span>
<span class="fc" id="L329">      final FileMonitorCommandFactory factory =</span>
<span class="fc" id="L330">          new FileMonitorCommandFactory() {</span>

            @Override
            public FileMonitorCommandRunnableFuture create(
                final FileItem fileItem) {
<span class="fc" id="L335">              final SpooledRunner runner = new SpooledRunner(fileItem);</span>
<span class="fc" id="L336">              runner.setMonitor(monitor);</span>
<span class="fc" id="L337">              return runner;</span>
            }
          };
<span class="fc" id="L340">      monitor.setCommandValidFileFactory(factory, limitParallelTasks);</span>
    }
<span class="fc" id="L342">    final FileMonitor monitorArg = monitor;</span>
<span class="pc bpc" id="L343" title="2 of 4 branches missed.">    if (waarpHosts != null &amp;&amp; !waarpHosts.isEmpty()) {</span>
<span class="fc" id="L344">      setWaarpHostCommand(monitorArg);</span>
    }
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">    for (int i = 1; i &lt; directory.size(); i++) {</span>
<span class="nc" id="L347">      dir = new File(directory.get(i));</span>
<span class="nc" id="L348">      monitor.addDirectory(dir);</span>
    }
<span class="fc" id="L350">    logger.warn(&quot;SpooledDirectoryTransfer starts name:&quot; + name + &quot; directory:&quot; +</span>
                directory + &quot; statusFile:&quot; + statusFile + &quot; stopFile:&quot; +
                stopFile + &quot; rulename:&quot; + ruleName + &quot; fileinfo:&quot; + fileInfo +
                &quot; hosts:&quot; + remoteHosts + &quot; regex:&quot; + regexFilter +
                &quot; minimalSize:&quot; + minimalSize + &quot; waarp:&quot; + waarpHosts +
                &quot; elapse:&quot; + elapseTime + &quot; waarpElapse:&quot; + elapseWaarpTime +
                &quot; parallel:&quot; + parallel + &quot; limitParallel:&quot; +
                limitParallelTasks + &quot; submit:&quot; + submit + &quot; recursive:&quot; +
                recurs);
<span class="fc" id="L359">    monitor.start();</span>
<span class="fc" id="L360">    monitor.waitForStopFile();</span>
<span class="fc" id="L361">    future.setSuccess();</span>
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">    if (Configuration.configuration.getShutdownConfiguration().serviceFuture !=</span>
        null) {
<span class="nc" id="L364">      Configuration.configuration.getShutdownConfiguration().serviceFuture</span>
<span class="nc" id="L365">          .setSuccess();</span>
    }
<span class="fc" id="L367">  }</span>

  private void setWaarpHostCommand(final FileMonitor monitorArg) {
    final FileMonitorCommandRunnableFuture waarpHostCommand;
<span class="fc" id="L371">    waarpHostCommand = new FileMonitorCommandRunnableFuture() {</span>
      @Override
      public void run(final FileItem notused) {
        try {
<span class="fc" id="L375">          Thread.currentThread().setName(&quot;FileMonitorInformation_&quot; + name);</span>
<span class="pc bpc" id="L376" title="1 of 4 branches missed.">          if (admin.getSession() != null &amp;&amp; admin.getSession().isDisActive()) {</span>
<span class="nc" id="L377">            admin.getSession().checkConnectionNoException();</span>
          }
<span class="fc" id="L379">          String status = monitorArg.getStatus();</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">          if (normalInfoAsWarn) {</span>
<span class="fc" id="L381">            logger.warn(&quot;Will inform back Waarp hosts of current history: &quot; +</span>
<span class="fc" id="L382">                        monitorArg.getCurrentHistoryNb());</span>
          } else {
<span class="fc" id="L384">            logger.info(&quot;Will inform back Waarp hosts of current history: {}&quot;,</span>
<span class="fc" id="L385">                        monitorArg.getCurrentHistoryNb());</span>
          }
<span class="fc bfc" id="L387" title="All 2 branches covered.">          for (String host : waarpHosts) {</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">            if (host == null) {</span>
<span class="nc" id="L389">              continue;</span>
            }
<span class="fc" id="L391">            host = host.trim();</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">            if (!host.isEmpty()) {</span>
<span class="fc" id="L393">              final R66Future r66Future = new R66Future(true);</span>
<span class="fc" id="L394">              final BusinessRequestPacket packet = new BusinessRequestPacket(</span>
<span class="fc" id="L395">                  SpooledInformTask.class.getName() + ' ' + status, 0);</span>
<span class="fc" id="L396">              final BusinessRequest transaction =</span>
                  new BusinessRequest(networkTransaction, r66Future, host,
                                      packet);
<span class="fc" id="L399">              transaction.run();</span>
<span class="fc" id="L400">              r66Future.awaitOrInterruptible();</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">              if (!r66Future.isSuccess()) {</span>
<span class="fc" id="L402">                logger.info(&quot;Can't inform Waarp server: {} since {}&quot;, host,</span>
<span class="fc" id="L403">                            r66Future.getCause());</span>
              } else {
<span class="fc" id="L405">                final R66Result result = r66Future.getResult();</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">                if (result == null) {</span>
<span class="nc" id="L407">                  monitorArg.setNextAsFullStatus();</span>
                } else {
<span class="fc" id="L409">                  status = (String) result.getOther();</span>
<span class="pc bpc" id="L410" title="2 of 4 branches missed.">                  if (status == null || status.equalsIgnoreCase(NEEDFULL)) {</span>
<span class="nc" id="L411">                    monitorArg.setNextAsFullStatus();</span>
                  }
                }
<span class="fc" id="L414">                logger.debug(&quot;Inform back Waarp hosts over for: {}&quot;, host);</span>
              }
            }
<span class="fc" id="L417">          }</span>
<span class="nc" id="L418">        } catch (final Throwable e) {</span>
<span class="nc" id="L419">          logger.error(&quot;Issue during Waarp information&quot;, e);</span>
          // ignore
<span class="fc" id="L421">        }</span>
<span class="fc" id="L422">      }</span>
    };
<span class="fc" id="L424">    monitor.setCommandCheckIteration(waarpHostCommand);</span>
<span class="fc" id="L425">    monitor.setElapseWaarpTime(elapseWaarpTime);</span>
<span class="fc" id="L426">  }</span>

  private FileMonitorCommandRunnableFuture initializeFileMonitorCommandRunnableFuture(
      final File status, final File stop, final FileFilter filter) {
    // Will be used if no parallelism
<span class="fc" id="L431">    final FileMonitorCommandRunnableFuture commandValidFile =</span>
        new SpooledRunner(null);
<span class="fc" id="L433">    final FileMonitorCommandRunnableFuture waarpRemovedCommand =</span>
<span class="fc" id="L434">        new FileMonitorCommandRunnableFuture() {</span>
          @Override
          public void run(final FileItem file) {
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">            if (normalInfoAsWarn) {</span>
<span class="fc" id="L438">              logger.warn(&quot;File removed: {}&quot;, file.file);</span>
            } else {
<span class="nc" id="L440">              logger.info(&quot;File removed: {}&quot;, file.file);</span>
            }
<span class="fc" id="L442">          }</span>
        };
<span class="fc" id="L444">    final File dir = new File(directory.get(0));</span>
<span class="fc" id="L445">    monitor = new FileMonitor(name, status, stop, dir, null, elapseTime, filter,</span>
                              recurs, commandValidFile, waarpRemovedCommand,
                              null);
<span class="fc" id="L448">    monitor.setIgnoreAlreadyUsed(ignoreAlreadyUsed);</span>
<span class="fc" id="L449">    return commandValidFile;</span>
  }

  public void stop() {
<span class="nc bnc" id="L453" title="All 2 branches missed.">    if (monitor != null) {</span>
<span class="nc" id="L454">      logger.info(&quot;Stop Monitor&quot;);</span>
<span class="nc" id="L455">      monitor.stop();</span>
<span class="nc" id="L456">      logger.info(&quot;Monitor Stopped&quot;);</span>
    } else {
<span class="nc" id="L458">      logger.warn(&quot;NO MONITOR found&quot;);</span>
    }
<span class="nc" id="L460">  }</span>

  public class SpooledRunner extends FileMonitorCommandRunnableFuture {
    private static final String REQUEST_INFORMATION_FAILURE =
        &quot;RequestInformation.Failure&quot;;
    private static final String REMOTE2 = &quot;&lt;/REMOTE&gt;&quot;;
    private static final String REMOTE = &quot;&lt;REMOTE&gt;&quot;;

<span class="fc" id="L468">    public SpooledRunner(final FileItem fileItem) {</span>
<span class="fc" id="L469">      super(fileItem);</span>
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">      if (logger == null) {</span>
<span class="nc" id="L471">        logger = WaarpLoggerFactory.getLogger(SpooledDirectoryTransfer.class);</span>
      }
<span class="fc" id="L473">    }</span>

    @Override
    public void run(final FileItem fileItem) {
<span class="fc" id="L477">      setFileItem(fileItem);</span>
<span class="fc" id="L478">      checkReuse(ignoreAlreadyUsed);</span>
<span class="pc bpc" id="L479" title="1 of 4 branches missed.">      if (admin.getSession() != null &amp;&amp; admin.getSession().isDisActive()) {</span>
<span class="nc" id="L480">        admin.getSession().checkConnectionNoException();</span>
      }
<span class="fc" id="L482">      boolean finalStatus = false;</span>
<span class="fc" id="L483">      int ko = 0;</span>
<span class="fc" id="L484">      long specialId =</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">          remoteHosts.size() &gt; 1? ILLEGALVALUE : fileItem.specialId;</span>
<span class="fc" id="L486">      long newSpecialId = ILLEGALVALUE;</span>
      // check if already launched before
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">      if (isIgnored(ignoreAlreadyUsed)) {</span>
        // Nothing to do
<span class="nc" id="L490">        return;</span>
      }
<span class="fc" id="L492">      specialId = checkReuseUniqueHost(fileItem, specialId);</span>
      try {
<span class="fc bfc" id="L494" title="All 2 branches covered.">        for (String host : remoteHosts) {</span>
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">          if (host == null) {</span>
<span class="nc" id="L496">            continue;</span>
          }
<span class="fc" id="L498">          host = host.trim();</span>
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">          if (!host.isEmpty()) {</span>
<span class="fc" id="L500">            final String filename = fileItem.file.getAbsolutePath();</span>
<span class="fc" id="L501">            logger</span>
<span class="fc" id="L502">                .info(&quot;Launch transfer to &quot; + host + &quot; with file &quot; + filename);</span>
<span class="fc" id="L503">            R66Future r66Future = new R66Future(true);</span>
            final String text;
<span class="fc bfc" id="L505" title="All 2 branches covered.">            if (submit) {</span>
<span class="fc" id="L506">              text = submitTransfer(specialId, host, filename, r66Future);</span>
            } else {
<span class="fc bfc" id="L508" title="All 2 branches covered.">              if (specialId != ILLEGALVALUE) {</span>
                // Clean previously transfer if any
<span class="fc" id="L510">                cleanPreviousTransfer(specialId, host, filename, r66Future);</span>
              }
<span class="fc" id="L512">              text = &quot;Direct Transfer: &quot;;</span>
<span class="fc" id="L513">              r66Future = new R66Future(true);</span>
<span class="fc" id="L514">              directTransfer(host, filename, r66Future, text);</span>
            }
<span class="fc" id="L516">            r66Future.awaitOrInterruptible();</span>
<span class="fc" id="L517">            final R66Result r66result = r66Future.getResult();</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">            if (r66Future.isSuccess()) {</span>
<span class="fc" id="L519">              finalStatus = true;</span>
<span class="fc" id="L520">              newSpecialId =</span>
<span class="fc" id="L521">                  finalizeInSuccess(newSpecialId, host, text, r66result);</span>
            } else {
<span class="fc" id="L523">              setError(getError() + 1);</span>
<span class="fc" id="L524">              ko++;</span>
              final DbTaskRunner runner;
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">              if (r66result != null) {</span>
<span class="fc" id="L527">                String errMsg = &quot;Unknown Error Message&quot;;</span>
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">                if (r66Future.getCause() != null) {</span>
<span class="fc" id="L529">                  errMsg = r66Future.getCause().getMessage();</span>
                }
<span class="fc" id="L531">                final boolean isConnectionImpossible =</span>
<span class="pc bpc" id="L532" title="2 of 4 branches missed.">                    r66result.getCode() == ErrorCode.ConnectionImpossible &amp;&amp;</span>
                    !normalInfoAsWarn;
<span class="fc" id="L534">                runner = r66result.getRunner();</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">                if (runner != null) {</span>
<span class="fc" id="L536">                  newSpecialId = koOnFoundRunner(host, text, runner, errMsg,</span>
                                                 isConnectionImpossible);
                } else {
<span class="nc" id="L539">                  ko = getKoOnNoRunner(ko, host, r66Future, text, r66result,</span>
                                       isConnectionImpossible);
                }
<span class="fc" id="L542">              } else {</span>
<span class="nc" id="L543">                logger.error(</span>
<span class="nc" id="L544">                    text + Messages.getString(REQUEST_INFORMATION_FAILURE)</span>
                    //$NON-NLS-1$
<span class="nc" id="L546">                    + REMOTE + host + REMOTE2, r66Future.getCause());</span>
              }
            }
          }
<span class="fc" id="L550">        }</span>
<span class="nc" id="L551">      } catch (final Throwable e) {</span>
        // catch any exception
<span class="nc" id="L553">        logger.error(&quot;Error in SpooledDirectory&quot;, e);</span>
<span class="nc" id="L554">        finalStatus = false;</span>
<span class="fc" id="L555">      }</span>
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">      specialId = remoteHosts.size() &gt; 1? ILLEGALVALUE : newSpecialId;</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">      if (ko &gt; 0) {</span>
        // If at least one is in error, the transfer is in error so should be redone
<span class="fc" id="L559">        finalStatus = false;</span>
      }
<span class="fc" id="L561">      finalizeValidFile(finalStatus, specialId);</span>
<span class="fc" id="L562">    }</span>

    private void directTransfer(final String host, final String filename,
                                final R66Future r66Future, final String text) {
<span class="fc" id="L566">      final DirectTransfer transaction =</span>
          new DirectTransfer(r66Future, host, filename, ruleName, fileInfo,
                             isMD5, blocksize, ILLEGALVALUE,
                             networkTransaction);
<span class="pc bpc" id="L570" title="1 of 2 branches missed.">      if (!fileInfo.contains(&quot;-nofollow&quot;)) {</span>
<span class="fc" id="L571">        TransferArgs.forceAnalyzeFollow(transaction);</span>
      }
      // If retry indefinitely is useful transaction.setLimitRetryConnection(true)
<span class="fc" id="L574">      transaction.normalInfoAsWarn = normalInfoAsWarn;</span>
<span class="fc" id="L575">      logger.info(&quot;{}{}&quot;, text, host);</span>
<span class="fc" id="L576">      transaction.run();</span>
<span class="fc" id="L577">    }</span>

    private String submitTransfer(final long specialId, final String host,
                                  final String filename,
                                  final R66Future r66Future) {
      final String text;
<span class="fc" id="L583">      text = &quot;Submit Transfer: &quot;;</span>
<span class="fc" id="L584">      final SubmitTransfer transaction =</span>
          new SubmitTransfer(r66Future, host, filename, ruleName, fileInfo,
                             isMD5, blocksize, specialId, null);
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">      if (!fileInfo.contains(&quot;-nofollow&quot;)) {</span>
<span class="fc" id="L588">        TransferArgs.forceAnalyzeFollow(transaction);</span>
      }
<span class="fc" id="L590">      transaction.normalInfoAsWarn = normalInfoAsWarn;</span>
<span class="fc" id="L591">      logger.info(&quot;{}{}&quot;, text, host);</span>
<span class="fc" id="L592">      transaction.run();</span>
<span class="fc" id="L593">      return text;</span>
    }

    private long koOnFoundRunner(final String host, final String text,
                                 final DbTaskRunner runner, final String errMsg,
                                 final boolean isConnectionImpossible) {
      final long newSpecialId;
<span class="fc" id="L600">      newSpecialId = runner.getSpecialId();</span>
<span class="fc" id="L601">      DbTaskRunner.removeNoDbSpecialId(newSpecialId);</span>
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">      if (isConnectionImpossible) {</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">        if (logger.isInfoEnabled()) {</span>
<span class="nc" id="L604">          logger.info(&quot;{}{}{}{}{}{}{}{}&quot;, text,</span>
<span class="nc" id="L605">                      Messages.getString(REQUEST_INFORMATION_FAILURE),</span>
                      //$NON-NLS-1$
<span class="nc" id="L607">                      runner.toShortString(), REMOTE, host, &quot;&lt;/REMOTE&gt;&lt;REASON&gt;&quot;,</span>
                      errMsg, &quot;&lt;/REASON&gt;&quot;);
        }
      } else {
<span class="fc" id="L611">        logger.error(text + Messages.getString(REQUEST_INFORMATION_FAILURE) +</span>
                     //$NON-NLS-1$
<span class="fc" id="L613">                     runner.toShortString() + REMOTE + host +</span>
                     &quot;&lt;/REMOTE&gt;&lt;REASON&gt;&quot; + errMsg + &quot;&lt;/REASON&gt;&quot;);
      }
<span class="fc" id="L616">      return newSpecialId;</span>
    }

    private int getKoOnNoRunner(int ko, final String host,
                                final R66Future r66Future, final String text,
                                final R66Result r66result,
                                final boolean isConnectionImpossible) {
<span class="nc bnc" id="L623" title="All 2 branches missed.">      if (isConnectionImpossible) {</span>
<span class="nc" id="L624">        logger.info(&quot;{}{}{}{}{}&quot;, text,</span>
<span class="nc" id="L625">                    Messages.getString(REQUEST_INFORMATION_FAILURE), REMOTE,</span>
<span class="nc" id="L626">                    host, REMOTE2, r66Future.getCause());</span>
      } else {
<span class="nc bnc" id="L628" title="All 2 branches missed.">        if (r66result.getCode() == QueryRemotelyUnknown) {</span>
<span class="nc" id="L629">          logger.info(&quot;Transfer not found {}{}{}&quot;, REMOTE, host, REMOTE2);</span>
          // False negative
<span class="nc" id="L631">          ko--;</span>
<span class="nc" id="L632">          setError(getError() - 1);</span>
        } else {
<span class="nc" id="L634">          logger.error(</span>
<span class="nc" id="L635">              text + Messages.getString(REQUEST_INFORMATION_FAILURE) + REMOTE +</span>
<span class="nc" id="L636">              host + REMOTE2, r66Future.getCause());</span>
        }
      }
<span class="nc" id="L639">      return ko;</span>
    }

    private long finalizeInSuccess(long newSpecialId, final String host,
                                   final String text,
                                   final R66Result r66result) {
<span class="fc" id="L645">      setSent(getSent() + 1);</span>
      final DbTaskRunner runner;
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">      if (r66result != null) {</span>
<span class="fc" id="L648">        runner = r66result.getRunner();</span>
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">        if (runner != null) {</span>
<span class="fc" id="L650">          newSpecialId = runner.getSpecialId();</span>
<span class="fc" id="L651">          String status =</span>
<span class="fc" id="L652">              Messages.getString(&quot;RequestInformation.Success&quot;); //$NON-NLS-1$</span>
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">          if (runner.getErrorInfo() == ErrorCode.Warning) {</span>
<span class="nc" id="L654">            status =</span>
<span class="nc" id="L655">                Messages.getString(&quot;RequestInformation.Warned&quot;); //$NON-NLS-1$</span>
          }
<span class="fc bfc" id="L657" title="All 2 branches covered.">          if (normalInfoAsWarn) {</span>
<span class="fc" id="L658">            logger.warn(</span>
<span class="fc" id="L659">                text + &quot; status: &quot; + status + &quot;     &quot; + runner.toShortString() +</span>
                &quot;     &lt;REMOTE&gt;&quot; + host + REMOTE2 + &quot;     &lt;FILEFINAL&gt;&quot; +
<span class="fc bfc" id="L661" title="All 2 branches covered.">                (r66result.getFile() != null?</span>
<span class="fc" id="L662">                    r66result.getFile() + &quot;&lt;/FILEFINAL&gt;&quot; : &quot;no file&quot;));</span>
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">          } else if (logger.isInfoEnabled()) {</span>
<span class="nc" id="L664">            logger.info(</span>
                &quot;{} status: {}     {}     &lt;REMOTE&gt;{}&lt;/REMOTE&gt;     &lt;FILEFINAL&gt;{}&quot;,
<span class="nc" id="L666">                text, status, runner.toShortString(), host,</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">                (r66result.getFile() != null?</span>
<span class="nc" id="L668">                    r66result.getFile() + &quot;&lt;/FILEFINAL&gt;&quot; : &quot;no file&quot;));</span>
          }
<span class="pc bpc" id="L670" title="3 of 4 branches missed.">          if (nolog &amp;&amp; !submit) {</span>
            // In case of success, delete the runner
            try {
<span class="nc" id="L673">              runner.delete();</span>
<span class="nc" id="L674">            } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L675">              logger.warn(&quot;Cannot apply nolog to     &quot; + runner.toShortString(),</span>
                          e);
<span class="nc" id="L677">            }</span>
          }
<span class="fc" id="L679">          DbTaskRunner.removeNoDbSpecialId(newSpecialId);</span>
<span class="fc" id="L680">        } else {</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">          if (normalInfoAsWarn) {</span>
<span class="nc" id="L682">            logger.warn(text + Messages.getString(&quot;RequestInformation.Success&quot;)</span>
                        //$NON-NLS-1$
                        + REMOTE + host + REMOTE2);
          } else {
<span class="nc" id="L686">            logger.info(&quot;{}{}{}{}{}&quot;, text,</span>
<span class="nc" id="L687">                        Messages.getString(&quot;RequestInformation.Success&quot;),</span>
                        //$NON-NLS-1$
                        REMOTE, host, REMOTE2);
          }
        }
      } else {
<span class="nc bnc" id="L693" title="All 2 branches missed.">        if (normalInfoAsWarn) {</span>
<span class="nc" id="L694">          logger.warn(text + Messages.getString(&quot;RequestInformation.Success&quot;)</span>
                      //$NON-NLS-1$
                      + REMOTE + host + REMOTE2);
        } else {
<span class="nc" id="L698">          logger.info(&quot;{}{}{}{}{}&quot;, text,</span>
<span class="nc" id="L699">                      Messages.getString(&quot;RequestInformation.Success&quot;),</span>
                      //$NON-NLS-1$
                      REMOTE, host, REMOTE2);
        }
      }
<span class="fc" id="L704">      return newSpecialId;</span>
    }

    private void cleanPreviousTransfer(final long specialId, final String host,
                                       final String filename,
                                       final R66Future r66Future) {
      final String text;
      try {
<span class="fc" id="L712">        final String srequester = Configuration.configuration.getHostId(host);</span>
<span class="fc" id="L713">        text =</span>
            &quot;Request Transfer Cancelled: &quot; + specialId + ' ' + filename + ' ';
        // Cancel
<span class="fc" id="L716">        logger.debug(&quot;Will try to cancel {}&quot;, specialId);</span>
<span class="fc" id="L717">        final RequestTransfer transaction2 =</span>
            new RequestTransfer(r66Future, specialId, host, srequester, true,
                                false, false, networkTransaction);
<span class="fc" id="L720">        transaction2.normalInfoAsWarn = normalInfoAsWarn;</span>
<span class="fc" id="L721">        logger.warn(text + host);</span>
<span class="fc" id="L722">        transaction2.run();</span>
        // special task
<span class="fc" id="L724">        r66Future.awaitOrInterruptible();</span>
<span class="nc" id="L725">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">        if (admin.getSession() != null) {</span>
<span class="nc" id="L727">          admin.getSession().checkConnectionNoException();</span>
        }
<span class="nc" id="L729">        logger.warn(Messages.getString(&quot;RequestTransfer.5&quot;) + host,</span>
                    e); //$NON-NLS-1$
<span class="fc" id="L731">      }</span>
<span class="fc" id="L732">    }</span>

    private long checkReuseUniqueHost(final FileItem fileItem, long specialId) {
<span class="pc bpc" id="L735" title="1 of 4 branches missed.">      if (isReuse() &amp;&amp; remoteHosts.size() == 1) {</span>
        // if specialId is not IllegalValue, then used was necessarily true
        // before
<span class="fc bfc" id="L738" title="All 2 branches covered.">        if (!submit) {</span>
          // reset fileItem usage
<span class="fc" id="L740">          setValid(fileItem);</span>
        } else {
          // Cancel the unique previous transfer
<span class="fc" id="L743">          String host = remoteHosts.get(0);</span>
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">          if (host == null) {</span>
<span class="nc" id="L745">            return specialId;</span>
          }
<span class="fc" id="L747">          host = host.trim();</span>
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">          if (!host.isEmpty()) {</span>
<span class="fc" id="L749">            final String filename = fileItem.file.getAbsolutePath();</span>
<span class="fc" id="L750">            final String text =</span>
                &quot;Request Transfer to be cancelled: &quot; + fileItem.specialId +
                ' ' + filename + ' ';
            try {
<span class="fc" id="L754">              final R66Future r66Future = new R66Future(true);</span>
<span class="fc" id="L755">              final String srequester =</span>
<span class="fc" id="L756">                  Configuration.configuration.getHostId(host);</span>
              // Try restart
<span class="fc" id="L758">              final RequestTransfer transaction =</span>
                  new RequestTransfer(r66Future, fileItem.specialId, host,
                                      srequester, true, false, false,
                                      networkTransaction);
<span class="fc" id="L762">              transaction.normalInfoAsWarn = normalInfoAsWarn;</span>
<span class="fc" id="L763">              logger.info(&quot;{}{}&quot;, text, host);</span>
              // special task
<span class="fc" id="L765">              transaction.run();</span>
<span class="fc" id="L766">              r66Future.awaitOrInterruptible();</span>
              // reset fileItem usage
<span class="fc" id="L768">              setValid(fileItem);</span>
<span class="fc" id="L769">              specialId = fileItem.specialId;</span>
<span class="nc" id="L770">            } catch (final WaarpDatabaseException e) {</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">              if (admin.getSession() != null) {</span>
<span class="nc" id="L772">                admin.getSession().checkConnectionNoException();</span>
              }
<span class="nc" id="L774">              logger.warn(Messages.getString(&quot;RequestTransfer.5&quot;) + host,</span>
                          e); //$NON-NLS-1$
<span class="fc" id="L776">            }</span>
          }
        }
      }
<span class="fc" id="L780">      return specialId;</span>
    }
  }

  /**
   * Default arguments
   */
<span class="fc" id="L787">  public static class Arguments {</span>
    private String name;
<span class="fc" id="L789">    private final List&lt;String&gt; remoteHosts = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L790">    private final List&lt;String&gt; localDirectory = new ArrayList&lt;String&gt;();</span>
    private String rule;
<span class="fc" id="L792">    private String fileInfo = NO_INFO_ARGS;</span>
    private boolean isMd5;
<span class="fc" id="L794">    private int block = 0x10000; // 64K as default</span>
    private String statusFile;
    private String stopFile;
    private String regex;
<span class="fc" id="L798">    private long elapsed = 1000;</span>
<span class="fc" id="L799">    private long elapsedWaarp = 5000;</span>
<span class="fc" id="L800">    private boolean toSubmit = true;</span>
    private boolean noLog;
    private boolean recursive;
<span class="fc" id="L803">    private final List&lt;String&gt; waarpHosts = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L804">    private boolean isParallel = true;</span>
    private int limitParallel;
    private long minimalSize;
<span class="fc" id="L807">    private boolean logWarn = true;</span>
<span class="fc" id="L808">    private boolean ignoreAlreadyUsed = false;</span>

    public String getName() {
<span class="fc" id="L811">      return name;</span>
    }

    public void setName(final String name) {
<span class="fc" id="L815">      this.name = name;</span>
<span class="fc" id="L816">    }</span>

    public List&lt;String&gt; getRemoteHosts() {
<span class="fc" id="L819">      return remoteHosts;</span>
    }

    public List&lt;String&gt; getLocalDirectory() {
<span class="fc" id="L823">      return localDirectory;</span>
    }

    public String getRule() {
<span class="fc" id="L827">      return rule;</span>
    }

    public void setRule(final String rule) {
<span class="fc" id="L831">      this.rule = rule;</span>
<span class="fc" id="L832">    }</span>

    public String getFileInfo() {
<span class="fc" id="L835">      return fileInfo;</span>
    }

    public void setFileInfo(final String fileInfo) {
<span class="fc" id="L839">      this.fileInfo = fileInfo;</span>
<span class="fc" id="L840">    }</span>

    public boolean isMd5() {
<span class="nc" id="L843">      return isMd5;</span>
    }

    public void setMd5(final boolean md5) {
<span class="fc" id="L847">      this.isMd5 = md5;</span>
<span class="fc" id="L848">    }</span>

    public int getBlock() {
<span class="fc" id="L851">      return block;</span>
    }

    public void setBlock(final int block) {
<span class="fc" id="L855">      this.block = block;</span>
<span class="fc" id="L856">    }</span>

    public String getStatusFile() {
<span class="fc" id="L859">      return statusFile;</span>
    }

    public void setStatusFile(final String statusFile) {
<span class="fc" id="L863">      this.statusFile = statusFile;</span>
<span class="fc" id="L864">    }</span>

    public String getStopFile() {
<span class="fc" id="L867">      return stopFile;</span>
    }

    public void setStopFile(final String stopFile) {
<span class="fc" id="L871">      this.stopFile = stopFile;</span>
<span class="fc" id="L872">    }</span>

    public String getRegex() {
<span class="nc" id="L875">      return regex;</span>
    }

    public void setRegex(final String regex) {
<span class="fc" id="L879">      this.regex = regex;</span>
<span class="fc" id="L880">    }</span>

    public long getElapsed() {
<span class="nc" id="L883">      return elapsed;</span>
    }

    public void setElapsed(final long elapsed) {
<span class="fc" id="L887">      this.elapsed = elapsed;</span>
<span class="fc" id="L888">    }</span>

    public long getElapsedWaarp() {
<span class="nc" id="L891">      return elapsedWaarp;</span>
    }

    public void setElapsedWaarp(final long elapsedWaarp) {
<span class="fc" id="L895">      this.elapsedWaarp = elapsedWaarp;</span>
<span class="fc" id="L896">    }</span>

    public boolean isToSubmit() {
<span class="nc" id="L899">      return toSubmit;</span>
    }

    public void setToSubmit(final boolean toSubmit) {
<span class="fc" id="L903">      this.toSubmit = toSubmit;</span>
<span class="fc" id="L904">    }</span>

    public boolean isNoLog() {
<span class="nc" id="L907">      return noLog;</span>
    }

    public void setNoLog(final boolean noLog) {
<span class="fc" id="L911">      this.noLog = noLog;</span>
<span class="fc" id="L912">    }</span>

    public boolean isRecursive() {
<span class="nc" id="L915">      return recursive;</span>
    }

    public void setRecursive(final boolean recursive) {
<span class="fc" id="L919">      this.recursive = recursive;</span>
<span class="fc" id="L920">    }</span>

    public List&lt;String&gt; getWaarpHosts() {
<span class="fc" id="L923">      return waarpHosts;</span>
    }

    public boolean isParallel() {
<span class="nc" id="L927">      return isParallel;</span>
    }

    public void setParallel(final boolean parallel) {
<span class="fc" id="L931">      this.isParallel = parallel;</span>
<span class="fc" id="L932">    }</span>

    public int getLimitParallel() {
<span class="nc" id="L935">      return limitParallel;</span>
    }

    public void setLimitParallel(final int limitParallel) {
<span class="fc" id="L939">      this.limitParallel = limitParallel;</span>
<span class="fc" id="L940">    }</span>

    public long getMinimalSize() {
<span class="nc" id="L943">      return minimalSize;</span>
    }

    public void setMinimalSize(final long minimalSize) {
<span class="fc" id="L947">      this.minimalSize = minimalSize;</span>
<span class="fc" id="L948">    }</span>

    public boolean isLogWarn() {
<span class="nc" id="L951">      return logWarn;</span>
    }

    public void setLogWarn(final boolean logWarn) {
<span class="fc" id="L955">      this.logWarn = logWarn;</span>
<span class="fc" id="L956">    }</span>

    public boolean isIgnoreAlreadyUsed() {
<span class="nc" id="L959">      return ignoreAlreadyUsed;</span>
    }

    public void setIgnoreAlreadyUsed(final boolean ignoreAlreadyUsed) {
<span class="fc" id="L963">      this.ignoreAlreadyUsed = ignoreAlreadyUsed;</span>
<span class="fc" id="L964">    }</span>
  }

<span class="fc" id="L967">  protected static final List&lt;Arguments&gt; arguments = new ArrayList&lt;Arguments&gt;();</span>
  private static final String XML_ROOT = &quot;/config/&quot;;
  private static final String XML_SPOOLEDDAEMON = &quot;spooleddaemon&quot;;
  private static final String XML_STOPFILE = &quot;stopfile&quot;;
  private static final String XML_SPOOLED = &quot;spooled&quot;;
  private static final String XML_NAME = &quot;name&quot;;
  private static final String XML_TO = &quot;to&quot;;
  private static final String XML_RULE = &quot;rule&quot;;
  private static final String XML_STATUSFILE = &quot;statusfile&quot;;
  private static final String XML_DIRECTORY = &quot;directory&quot;;
  private static final String XML_REGEX = &quot;regex&quot;;
  private static final String XML_RECURSIVE = &quot;recursive&quot;;
  private static final String XML_ELAPSE = &quot;elapse&quot;;
  private static final String XML_SUBMIT = &quot;submit&quot;;
  private static final String XML_PARALLEL = &quot;parallel&quot;;
  private static final String XML_LIMIT_PARALLEL = &quot;limitParallel&quot;;
  private static final String XML_INFO = &quot;info&quot;;
  private static final String XML_MD_5 = &quot;md5&quot;;
  private static final String XML_BLOCK = &quot;block&quot;;
  private static final String XML_NOLOG = &quot;nolog&quot;;
  private static final String XML_WAARP = &quot;waarp&quot;;
  private static final String XML_ELAPSE_WAARP = &quot;elapseWaarp&quot;;
  private static final String XML_MINIMAL_SIZE = &quot;minimalSize&quot;;
  private static final String XML_LOG_WARN = &quot;logWarn&quot;;
  private static final String XML_IGNORED_ALREADY_USED = &quot;ignoreAlreadyUsed&quot;;

<span class="fc" id="L993">  private static final XmlDecl[] subSpooled = {</span>
      new XmlDecl(XmlType.STRING, XML_NAME),
      new XmlDecl(XML_TO, XmlType.STRING, XML_TO, true),
      new XmlDecl(XmlType.STRING, XML_RULE),
      new XmlDecl(XmlType.STRING, XML_STATUSFILE),
      new XmlDecl(XML_DIRECTORY, XmlType.STRING, XML_DIRECTORY, true),
      new XmlDecl(XmlType.STRING, XML_REGEX),
      new XmlDecl(XmlType.BOOLEAN, XML_RECURSIVE),
      new XmlDecl(XmlType.LONG, XML_ELAPSE),
      new XmlDecl(XmlType.BOOLEAN, XML_SUBMIT),
      new XmlDecl(XmlType.BOOLEAN, XML_PARALLEL),
      new XmlDecl(XmlType.INTEGER, XML_LIMIT_PARALLEL),
      new XmlDecl(XmlType.STRING, XML_INFO),
      new XmlDecl(XmlType.BOOLEAN, XML_MD_5),
      new XmlDecl(XmlType.INTEGER, XML_BLOCK),
      new XmlDecl(XmlType.BOOLEAN, XML_NOLOG),
      new XmlDecl(XML_WAARP, XmlType.STRING, XML_WAARP, true),
      new XmlDecl(XmlType.LONG, XML_ELAPSE_WAARP),
      new XmlDecl(XmlType.BOOLEAN, XML_IGNORED_ALREADY_USED),
      new XmlDecl(XmlType.LONG, XML_MINIMAL_SIZE)
  };
<span class="fc" id="L1014">  private static final XmlDecl[] spooled = {</span>
      new XmlDecl(XmlType.STRING, XML_STOPFILE),
      new XmlDecl(XmlType.BOOLEAN, XML_LOG_WARN),
      new XmlDecl(XML_SPOOLED, XmlType.XVAL, XML_SPOOLED, subSpooled, true)
  };
<span class="fc" id="L1019">  private static final XmlDecl[] configSpooled = {</span>
      new XmlDecl(XML_SPOOLEDDAEMON, XmlType.XVAL, XML_ROOT + XML_SPOOLEDDAEMON,
                  spooled, false)
  };

  @SuppressWarnings(&quot;unchecked&quot;)
  protected static boolean getParamsFromConfigFile(final String filename) {
<span class="pc bpc" id="L1026" title="1 of 2 branches missed.">    if (logger == null) {</span>
<span class="nc" id="L1027">      logger = WaarpLoggerFactory.getLogger(SpooledDirectoryTransfer.class);</span>
    }
    final Document document;
    // Open config file
    try {
<span class="fc" id="L1032">      document = XmlUtil.getNewSaxReader().read(filename);</span>
<span class="nc" id="L1033">    } catch (final DocumentException e) {</span>
<span class="nc" id="L1034">      logger.error(</span>
<span class="nc" id="L1035">          Messages.getString(&quot;FileBasedConfiguration.CannotReadXml&quot;) + filename,</span>
          e); //$NON-NLS-1$
<span class="nc" id="L1037">      return false;</span>
<span class="fc" id="L1038">    }</span>
<span class="pc bpc" id="L1039" title="1 of 2 branches missed.">    if (document == null) {</span>
<span class="nc" id="L1040">      logger.error(Messages.getString(&quot;FileBasedConfiguration.CannotReadXml&quot;) +</span>
                   filename); //$NON-NLS-1$
<span class="nc" id="L1042">      return false;</span>
    }
<span class="fc" id="L1044">    final XmlValue[] configuration = XmlUtil.read(document, configSpooled);</span>
<span class="fc" id="L1045">    final XmlHash hashConfig = new XmlHash(configuration);</span>
<span class="fc" id="L1046">    XmlValue value = hashConfig.get(XML_STOPFILE);</span>
    final String stopfile;
<span class="pc bpc" id="L1048" title="2 of 4 branches missed.">    if (value == null || value.isEmpty()) {</span>
<span class="fc" id="L1049">      return false;</span>
    }
<span class="nc" id="L1051">    stopfile = value.getString();</span>
<span class="nc" id="L1052">    value = hashConfig.get(XML_LOG_WARN);</span>
<span class="nc" id="L1053">    boolean logWarn = true;</span>
<span class="nc bnc" id="L1054" title="All 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1055">      logWarn = value.getBoolean();</span>
    }
<span class="nc" id="L1057">    value = hashConfig.get(XML_SPOOLED);</span>
<span class="nc bnc" id="L1058" title="All 4 branches missed.">    if (value != null &amp;&amp; value.getList() != null) {</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">      for (final XmlValue[] xml : (Iterable&lt;XmlValue[]&gt;) value.getList()) {</span>
<span class="nc" id="L1060">        final Arguments arg = new Arguments();</span>
<span class="nc" id="L1061">        arg.setStopFile(stopfile);</span>
<span class="nc" id="L1062">        arg.setLogWarn(logWarn);</span>
<span class="nc" id="L1063">        final XmlHash subHash = new XmlHash(xml);</span>
<span class="nc" id="L1064">        value = subHash.get(XML_NAME);</span>
<span class="nc bnc" id="L1065" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1066">          arg.setName(value.getString());</span>
        }
<span class="nc" id="L1068">        value = subHash.get(XML_TO);</span>
<span class="nc bnc" id="L1069" title="All 4 branches missed.">        if (value != null &amp;&amp; value.getList() != null) {</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">          for (final String to : (Iterable&lt;String&gt;) value.getList()) {</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">            if (to.trim().isEmpty()) {</span>
<span class="nc" id="L1072">              continue;</span>
            }
<span class="nc" id="L1074">            arg.getRemoteHosts().add(to.trim());</span>
<span class="nc" id="L1075">          }</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">          if (arg.getRemoteHosts().isEmpty()) {</span>
<span class="nc" id="L1077">            logger.warn(&quot;to directive is empty but must not&quot;);</span>
<span class="nc" id="L1078">            continue;</span>
          }
        } else {
<span class="nc" id="L1081">          logger.warn(&quot;to directive is empty but must not&quot;);</span>
<span class="nc" id="L1082">          continue;</span>
        }
<span class="nc" id="L1084">        value = subHash.get(XML_RULE);</span>
<span class="nc bnc" id="L1085" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1086">          arg.setRule(value.getString());</span>
        } else {
<span class="nc" id="L1088">          logger.warn(&quot;rule directive is empty but must not&quot;);</span>
<span class="nc" id="L1089">          continue;</span>
        }
<span class="nc" id="L1091">        value = subHash.get(XML_STATUSFILE);</span>
<span class="nc bnc" id="L1092" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1093">          arg.setStatusFile(value.getString());</span>
        } else {
<span class="nc" id="L1095">          logger.warn(&quot;statusfile directive is empty but must not&quot;);</span>
<span class="nc" id="L1096">          continue;</span>
        }
<span class="nc" id="L1098">        value = subHash.get(XML_DIRECTORY);</span>
<span class="nc bnc" id="L1099" title="All 4 branches missed.">        if (value != null &amp;&amp; value.getList() != null) {</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">          for (final String dir : (Iterable&lt;String&gt;) value.getList()) {</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">            if (dir.trim().isEmpty()) {</span>
<span class="nc" id="L1102">              continue;</span>
            }
<span class="nc" id="L1104">            arg.getLocalDirectory().add(dir.trim());</span>
<span class="nc" id="L1105">          }</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">          if (arg.getLocalDirectory().isEmpty()) {</span>
<span class="nc" id="L1107">            logger.warn(&quot;directory directive is empty but must not&quot;);</span>
<span class="nc" id="L1108">            continue;</span>
          }
        } else {
<span class="nc" id="L1111">          logger.warn(&quot;directory directive is empty but must not&quot;);</span>
<span class="nc" id="L1112">          continue;</span>
        }
<span class="nc" id="L1114">        value = subHash.get(XML_REGEX);</span>
<span class="nc bnc" id="L1115" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1116">          arg.setRegex(value.getString());</span>
        }
<span class="nc" id="L1118">        value = subHash.get(XML_RECURSIVE);</span>
<span class="nc bnc" id="L1119" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1120">          arg.setRecursive(value.getBoolean());</span>
        }
<span class="nc" id="L1122">        value = subHash.get(XML_ELAPSE);</span>
<span class="nc bnc" id="L1123" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1124">          arg.setElapsed(value.getLong());</span>
        }
<span class="nc" id="L1126">        value = subHash.get(XML_SUBMIT);</span>
<span class="nc bnc" id="L1127" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1128">          arg.setToSubmit(value.getBoolean());</span>
        }
<span class="nc" id="L1130">        value = subHash.get(XML_PARALLEL);</span>
<span class="nc bnc" id="L1131" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1132">          arg.setParallel(value.getBoolean());</span>
        }
<span class="nc" id="L1134">        value = subHash.get(XML_LIMIT_PARALLEL);</span>
<span class="nc bnc" id="L1135" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1136">          arg.setLimitParallel(value.getInteger());</span>
        }
<span class="nc" id="L1138">        value = subHash.get(XML_INFO);</span>
<span class="nc bnc" id="L1139" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1140">          arg.setFileInfo(value.getString());</span>
        }
<span class="nc" id="L1142">        value = subHash.get(XML_MD_5);</span>
<span class="nc bnc" id="L1143" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1144">          arg.setMd5(value.getBoolean());</span>
        }
<span class="nc" id="L1146">        value = subHash.get(XML_BLOCK);</span>
<span class="nc bnc" id="L1147" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1148">          arg.setBlock(value.getInteger());</span>
        }
<span class="nc" id="L1150">        value = subHash.get(XML_NOLOG);</span>
<span class="nc bnc" id="L1151" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1152">          arg.setNoLog(value.getBoolean());</span>
        }
<span class="nc" id="L1154">        value = subHash.get(XML_WAARP);</span>
<span class="nc bnc" id="L1155" title="All 4 branches missed.">        if (value != null &amp;&amp; value.getList() != null) {</span>
<span class="nc bnc" id="L1156" title="All 2 branches missed.">          for (final String host : (Iterable&lt;String&gt;) value.getList()) {</span>
<span class="nc bnc" id="L1157" title="All 2 branches missed.">            if (host.trim().isEmpty()) {</span>
<span class="nc" id="L1158">              continue;</span>
            }
<span class="nc" id="L1160">            arg.getWaarpHosts().add(host.trim());</span>
<span class="nc" id="L1161">          }</span>
        }
<span class="nc" id="L1163">        value = subHash.get(XML_ELAPSE_WAARP);</span>
<span class="nc bnc" id="L1164" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1165">          arg.setElapsedWaarp(value.getLong());</span>
        }
<span class="nc" id="L1167">        value = subHash.get(XML_MINIMAL_SIZE);</span>
<span class="nc bnc" id="L1168" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1169">          arg.setMinimalSize(value.getLong());</span>
        }
<span class="nc" id="L1171">        value = subHash.get(XML_IGNORED_ALREADY_USED);</span>
<span class="nc bnc" id="L1172" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1173">          arg.setIgnoreAlreadyUsed(value.getBoolean());</span>
        }
<span class="nc" id="L1175">        arguments.add(arg);</span>
<span class="nc" id="L1176">      }</span>
    }
<span class="nc" id="L1178">    hashConfig.clear();</span>
<span class="nc bnc" id="L1179" title="All 2 branches missed.">    return !arguments.isEmpty();</span>
  }

  /**
   * Parse the parameter and set current values
   *
   * @param args
   *
   * @return True if all parameters were found and correct
   */
  protected static boolean getParams(final String[] args) {
<span class="fc bfc" id="L1190" title="All 2 branches covered.">    if (logger == null) {</span>
<span class="fc" id="L1191">      logger = WaarpLoggerFactory.getLogger(SpooledDirectoryTransfer.class);</span>
    }
<span class="fc" id="L1193">    infoArgs = Messages.getString(&quot;SpooledDirectoryTransfer.0&quot;); //$NON-NLS-1$</span>
<span class="pc bpc" id="L1194" title="1 of 2 branches missed.">    if (args.length &lt; 1) {</span>
<span class="nc" id="L1195">      logger.error(infoArgs);</span>
<span class="nc" id="L1196">      return false;</span>
    }
<span class="fc" id="L1198">    if (!FileBasedConfiguration</span>
<span class="pc bpc" id="L1199" title="1 of 2 branches missed.">        .setClientConfigurationFromXml(Configuration.configuration, args[0])) {</span>
<span class="nc" id="L1200">      logger.error(</span>
<span class="nc" id="L1201">          Messages.getString(&quot;Configuration.NeedCorrectConfig&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L1202">      return false;</span>
    }
    // Now check if the configuration file contains already elements of specifications
<span class="pc bpc" id="L1205" title="1 of 2 branches missed.">    if (!getParamsFromConfigFile(args[0])) {</span>
<span class="pc bpc" id="L1206" title="1 of 2 branches missed.">      if (args.length &lt; 11) {</span>
<span class="nc" id="L1207">        logger.error(infoArgs);</span>
<span class="nc" id="L1208">        return false;</span>
      }
      // Now set default values from configuration
<span class="fc" id="L1211">      final Arguments arg = new Arguments();</span>
<span class="fc" id="L1212">      arg.setBlock(Configuration.configuration.getBlockSize());</span>
<span class="fc" id="L1213">      int i = 1;</span>
      try {
<span class="fc bfc" id="L1215" title="All 2 branches covered.">        for (i = 1; i &lt; args.length; i++) {</span>
<span class="fc bfc" id="L1216" title="All 2 branches covered.">          if (&quot;-to&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="fc" id="L1217">            i++;</span>
<span class="fc" id="L1218">            final String[] rhosts = args[i].split(&quot;,&quot;);</span>
<span class="fc bfc" id="L1219" title="All 2 branches covered.">            for (String string : rhosts) {</span>
<span class="fc" id="L1220">              string = string.trim();</span>
<span class="pc bpc" id="L1221" title="1 of 2 branches missed.">              if (string.isEmpty()) {</span>
<span class="nc" id="L1222">                continue;</span>
              }
<span class="fc" id="L1224">              if (Configuration.configuration.getAliases()</span>
<span class="pc bpc" id="L1225" title="1 of 2 branches missed.">                                             .containsKey(string)) {</span>
<span class="nc" id="L1226">                string = Configuration.configuration.getAliases().get(string);</span>
              }
<span class="fc" id="L1228">              arg.getRemoteHosts().add(string);</span>
            }
<span class="fc bfc" id="L1230" title="All 2 branches covered.">          } else if (&quot;-name&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="fc" id="L1231">            i++;</span>
<span class="fc" id="L1232">            arg.setName(args[i]);</span>
<span class="fc bfc" id="L1233" title="All 2 branches covered.">          } else if (&quot;-directory&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="fc" id="L1234">            i++;</span>
<span class="fc" id="L1235">            final String[] dir = args[i].split(&quot;,&quot;);</span>
<span class="fc bfc" id="L1236" title="All 2 branches covered.">            for (final String string : dir) {</span>
<span class="pc bpc" id="L1237" title="1 of 2 branches missed.">              if (string.trim().isEmpty()) {</span>
<span class="nc" id="L1238">                continue;</span>
              }
<span class="fc" id="L1240">              arg.getLocalDirectory().add(string.trim());</span>
            }
<span class="fc bfc" id="L1242" title="All 2 branches covered.">          } else if (&quot;-rule&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="fc" id="L1243">            i++;</span>
<span class="fc" id="L1244">            arg.setRule(args[i]);</span>
<span class="fc bfc" id="L1245" title="All 2 branches covered.">          } else if (&quot;-statusfile&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="fc" id="L1246">            i++;</span>
<span class="fc" id="L1247">            arg.setStatusFile(args[i]);</span>
<span class="fc bfc" id="L1248" title="All 2 branches covered.">          } else if (&quot;-stopfile&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="fc" id="L1249">            i++;</span>
<span class="fc" id="L1250">            arg.setStopFile(args[i]);</span>
<span class="fc bfc" id="L1251" title="All 2 branches covered.">          } else if (&quot;-info&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="fc" id="L1252">            i++;</span>
<span class="fc" id="L1253">            arg.setFileInfo(args[i]);</span>
<span class="fc bfc" id="L1254" title="All 2 branches covered.">          } else if (&quot;-md5&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="fc" id="L1255">            arg.setMd5(true);</span>
<span class="fc bfc" id="L1256" title="All 2 branches covered.">          } else if (&quot;-block&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="fc" id="L1257">            i++;</span>
<span class="fc" id="L1258">            arg.setBlock(Integer.parseInt(args[i]));</span>
<span class="pc bpc" id="L1259" title="1 of 2 branches missed.">            if (arg.getBlock() &lt; 100) {</span>
<span class="nc" id="L1260">              logger.error(Messages.getString(&quot;AbstractTransfer.1&quot;) +</span>
<span class="nc" id="L1261">                           arg.getBlock()); //$NON-NLS-1$</span>
<span class="nc" id="L1262">              return false;</span>
            }
<span class="pc bpc" id="L1264" title="1 of 2 branches missed.">          } else if (&quot;-nolog&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="nc" id="L1265">            arg.setNoLog(true);</span>
<span class="fc bfc" id="L1266" title="All 2 branches covered.">          } else if (&quot;-submit&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="fc" id="L1267">            arg.setToSubmit(true);</span>
<span class="fc bfc" id="L1268" title="All 2 branches covered.">          } else if (&quot;-direct&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="fc" id="L1269">            arg.setToSubmit(false);</span>
<span class="pc bpc" id="L1270" title="1 of 2 branches missed.">          } else if (&quot;-recursive&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="nc" id="L1271">            arg.setRecursive(true);</span>
<span class="pc bpc" id="L1272" title="1 of 2 branches missed.">          } else if (&quot;-logWarn&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="nc" id="L1273">            arg.setLogWarn(true);</span>
<span class="fc bfc" id="L1274" title="All 2 branches covered.">          } else if (&quot;-notlogWarn&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="fc" id="L1275">            arg.setLogWarn(false);</span>
<span class="pc bpc" id="L1276" title="1 of 2 branches missed.">          } else if (&quot;-regex&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="nc" id="L1277">            i++;</span>
<span class="nc" id="L1278">            arg.setRegex(args[i]);</span>
<span class="fc bfc" id="L1279" title="All 2 branches covered.">          } else if (&quot;-waarp&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="fc" id="L1280">            i++;</span>
<span class="fc" id="L1281">            final String[] host = args[i].split(&quot;,&quot;);</span>
<span class="fc bfc" id="L1282" title="All 2 branches covered.">            for (final String string : host) {</span>
<span class="pc bpc" id="L1283" title="1 of 2 branches missed.">              if (string.trim().isEmpty()) {</span>
<span class="nc" id="L1284">                continue;</span>
              }
<span class="fc" id="L1286">              arg.getWaarpHosts().add(string.trim());</span>
            }
<span class="fc bfc" id="L1288" title="All 2 branches covered.">          } else if (&quot;-elapse&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="fc" id="L1289">            i++;</span>
<span class="fc" id="L1290">            arg.setElapsed(Long.parseLong(args[i]));</span>
<span class="fc bfc" id="L1291" title="All 2 branches covered.">          } else if (&quot;-elapseWaarp&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="fc" id="L1292">            i++;</span>
<span class="fc" id="L1293">            arg.setElapsedWaarp(Long.parseLong(args[i]));</span>
<span class="fc bfc" id="L1294" title="All 2 branches covered.">          } else if (&quot;-minimalSize&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="fc" id="L1295">            i++;</span>
<span class="fc" id="L1296">            arg.setMinimalSize(Long.parseLong(args[i]));</span>
<span class="fc bfc" id="L1297" title="All 2 branches covered.">          } else if (&quot;-limitParallel&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="fc" id="L1298">            i++;</span>
<span class="fc" id="L1299">            arg.setLimitParallel(Integer.parseInt(args[i]));</span>
<span class="pc bpc" id="L1300" title="1 of 2 branches missed.">          } else if (&quot;-parallel&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="nc" id="L1301">            arg.setParallel(true);</span>
<span class="pc bpc" id="L1302" title="1 of 2 branches missed.">          } else if (&quot;-sequential&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="nc" id="L1303">            arg.setParallel(false);</span>
<span class="fc bfc" id="L1304" title="All 2 branches covered.">          } else if (&quot;-ignoreAlreadyUsed&quot;.equalsIgnoreCase(args[i])) {</span>
<span class="fc" id="L1305">            arg.setIgnoreAlreadyUsed(true);</span>
          }
        }
<span class="nc" id="L1308">      } catch (final NumberFormatException e) {</span>
<span class="nc" id="L1309">        logger</span>
<span class="nc" id="L1310">            .error(Messages.getString(&quot;AbstractTransfer.20&quot;) + i); //$NON-NLS-1$</span>
<span class="nc" id="L1311">        return false;</span>
<span class="fc" id="L1312">      }</span>
<span class="pc bpc" id="L1313" title="1 of 2 branches missed.">      if (arg.getFileInfo() == null) {</span>
<span class="nc" id="L1314">        arg.setFileInfo(NO_INFO_ARGS);</span>
      }
<span class="pc bpc" id="L1316" title="1 of 2 branches missed.">      if (arg.getName() == null) {</span>
<span class="nc" id="L1317">        arg.setName(Configuration.configuration.getHostId() + &quot; : &quot; +</span>
<span class="nc" id="L1318">                    arg.getLocalDirectory());</span>
      }
<span class="pc bpc" id="L1320" title="2 of 4 branches missed.">      if (!arg.getRemoteHosts().isEmpty() &amp;&amp; arg.getRule() != null &amp;&amp;</span>
<span class="pc bpc" id="L1321" title="2 of 4 branches missed.">          !arg.getLocalDirectory().isEmpty() &amp;&amp; arg.getStatusFile() != null &amp;&amp;</span>
<span class="pc bpc" id="L1322" title="1 of 2 branches missed.">          arg.getStopFile() != null) {</span>
<span class="fc" id="L1323">        arguments.add(arg);</span>
<span class="fc" id="L1324">        return true;</span>
      }
<span class="nc" id="L1326">      logger.error(Messages.getString(&quot;SpooledDirectoryTransfer.56&quot;) +</span>
                   //$NON-NLS-1$
                   infoArgs);
<span class="nc" id="L1329">      return false;</span>
    }
<span class="nc bnc" id="L1331" title="All 2 branches missed.">    return !arguments.isEmpty();</span>
  }

  public static void main(final String[] args) {
<span class="nc" id="L1335">    WaarpLoggerFactory</span>
<span class="nc" id="L1336">        .setDefaultFactoryIfNotSame(new WaarpSlf4JLoggerFactory(null));</span>
<span class="nc bnc" id="L1337" title="All 2 branches missed.">    if (logger == null) {</span>
<span class="nc" id="L1338">      logger = WaarpLoggerFactory.getLogger(SpooledDirectoryTransfer.class);</span>
    }
<span class="nc" id="L1340">    initialize(args, true);</span>
<span class="nc" id="L1341">  }</span>

<span class="fc" id="L1343">  public static final List&lt;SpooledDirectoryTransfer&gt; list =</span>
      new ArrayList&lt;SpooledDirectoryTransfer&gt;();
  public static NetworkTransaction networkTransactionStatic;
  public static ExecutorService executorService;

  /**
   * @param args
   * @param normalStart if True, will exit JVM when all daemons are
   *     stopped;
   *     else False let the caller do (used
   *     by SpooledEngine)
   */
  public static boolean initialize(final String[] args,
                                   final boolean normalStart) {
<span class="nc bnc" id="L1357" title="All 2 branches missed.">    if (logger == null) {</span>
<span class="nc" id="L1358">      logger = WaarpLoggerFactory.getLogger(SpooledDirectoryTransfer.class);</span>
    }
<span class="nc" id="L1360">    arguments.clear();</span>
<span class="nc bnc" id="L1361" title="All 2 branches missed.">    if (!getParams(args)) {</span>
<span class="nc" id="L1362">      logger.error(Messages.getString(&quot;Configuration.WrongInit&quot;)); //$NON-NLS-1$</span>
<span class="nc bnc" id="L1363" title="All 2 branches missed.">      if (admin != null) {</span>
<span class="nc" id="L1364">        admin.close();</span>
      }
<span class="nc bnc" id="L1366" title="All 2 branches missed.">      if (normalStart) {</span>
<span class="nc" id="L1367">        ChannelUtils.stopLogger();</span>
<span class="nc" id="L1368">        System.exit(2);//NOSONAR</span>
      }
<span class="nc" id="L1370">      return false;</span>
    }

<span class="nc" id="L1373">    Configuration.configuration.pipelineInit();</span>
<span class="nc" id="L1374">    networkTransactionStatic = new NetworkTransaction();</span>
    try {
<span class="nc" id="L1376">      executorService = Executors.newCachedThreadPool(</span>
          new WaarpThreadFactory(&quot;SpooledDirectoryDaemon&quot;));
<span class="nc bnc" id="L1378" title="All 2 branches missed.">      for (final Arguments arg : arguments) {</span>
<span class="nc" id="L1379">        final R66Future future = new R66Future(true);</span>
<span class="nc" id="L1380">        final SpooledDirectoryTransfer spooled =</span>
            new SpooledDirectoryTransfer(future, arg, networkTransactionStatic);
<span class="nc" id="L1382">        executorService.submit(spooled);</span>
<span class="nc" id="L1383">        list.add(spooled);</span>
<span class="nc" id="L1384">      }</span>
<span class="nc" id="L1385">      arguments.clear();</span>
<span class="nc" id="L1386">      Thread.sleep(1000);</span>
<span class="nc" id="L1387">      executorService.shutdown();</span>
<span class="nc" id="L1388">      Configuration.configuration.launchStatistics();</span>
<span class="nc bnc" id="L1389" title="All 2 branches missed.">      if (normalStart) {</span>
<span class="nc" id="L1390">        while (!executorService</span>
<span class="nc bnc" id="L1391" title="All 2 branches missed.">            .awaitTermination(Configuration.configuration.getTimeoutCon(),</span>
                              TimeUnit.MILLISECONDS)) {
<span class="nc" id="L1393">          Thread.sleep(Configuration.configuration.getTimeoutCon());</span>
        }
<span class="nc bnc" id="L1395" title="All 2 branches missed.">        for (final SpooledDirectoryTransfer spooledDirectoryTransfer : list) {</span>
<span class="nc" id="L1396">          logger.warn(Messages.getString(&quot;SpooledDirectoryTransfer.58&quot;) +</span>
                      spooledDirectoryTransfer.name + &quot;: &quot; +
<span class="nc" id="L1398">                      spooledDirectoryTransfer.getSent() + &quot; success, &quot; +</span>
<span class="nc" id="L1399">                      spooledDirectoryTransfer.getError() + Messages.getString(</span>
              &quot;SpooledDirectoryTransfer.60&quot;)); //$NON-NLS-1$
<span class="nc" id="L1401">        }</span>
<span class="nc" id="L1402">        list.clear();</span>
      }
<span class="nc" id="L1404">      return true;</span>
<span class="nc" id="L1405">    } catch (final Throwable e) {</span>
<span class="nc" id="L1406">      logger.error(&quot;Exception&quot;, e);</span>
<span class="nc" id="L1407">      return false;</span>
    } finally {
<span class="nc bnc" id="L1409" title="All 2 branches missed.">      if (normalStart) {</span>
<span class="nc" id="L1410">        WaarpShutdownHook.shutdownWillStart();</span>
<span class="nc" id="L1411">        networkTransactionStatic.closeAll();</span>
<span class="nc" id="L1412">        System.exit(0);//NOSONAR</span>
      }
    }
  }

  /**
   * @return the sent
   */
  public long getSent() {
<span class="fc" id="L1421">    return sent;</span>
  }

  /**
   * @param sent the sent to set
   */
  private void setSent(final long sent) {
<span class="fc" id="L1428">    this.sent = sent;</span>
<span class="fc" id="L1429">  }</span>

  /**
   * @return the error
   */
  public long getError() {
<span class="fc" id="L1435">    return error;</span>
  }

  /**
   * @param error the error to set
   */
  private void setError(final long error) {
<span class="fc" id="L1442">    this.error = error;</span>
<span class="fc" id="L1443">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>