<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RestHandlerHook.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Packaging RPM, DEB, ZIP and TGZ</a> &gt; <a href="../index.html" class="el_bundle">WaarpR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.protocol.http.restv2.resthandlers</a> &gt; <span class="el_source">RestHandlerHook.java</span></div><h1>RestHandlerHook.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package org.waarp.openr66.protocol.http.restv2.resthandlers;

import io.cdap.http.HandlerHook;
import io.cdap.http.HttpResponder;
import io.cdap.http.internal.HandlerInfo;
import io.netty.handler.codec.http.DefaultHttpHeaders;
import io.netty.handler.codec.http.HttpRequest;
import io.netty.handler.codec.http.HttpResponseStatus;
import org.joda.time.DateTime;
import org.waarp.common.crypto.HmacSha256;
import org.waarp.common.database.exception.WaarpDatabaseException;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.role.RoleDefault;
import org.waarp.common.role.RoleDefault.ROLE;
import org.waarp.common.utility.BaseXx;
import org.waarp.common.utility.ParametersChecker;
import org.waarp.common.utility.WaarpStringUtils;
import org.waarp.openr66.dao.DAOFactory;
import org.waarp.openr66.dao.HostDAO;
import org.waarp.openr66.dao.exception.DAOConnectionException;
import org.waarp.openr66.dao.exception.DAONoDataException;
import org.waarp.openr66.database.data.DbHostAuth;
import org.waarp.openr66.pojo.Host;
import org.waarp.openr66.protocol.http.restv2.RestServiceInitializer;
import org.waarp.openr66.protocol.http.restv2.converters.HostConfigConverter;
import org.waarp.openr66.protocol.http.restv2.dbhandlers.AbstractRestDbHandler;
import org.waarp.openr66.protocol.http.restv2.dbhandlers.RequiredRole;

import javax.ws.rs.Consumes;
import javax.ws.rs.InternalServerErrorException;
import javax.ws.rs.NotAllowedException;
import javax.ws.rs.core.MediaType;
import java.lang.reflect.Method;
import java.text.ParseException;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static io.netty.handler.codec.http.HttpMethod.*;
import static io.netty.handler.codec.http.HttpResponseStatus.*;
import static javax.ws.rs.core.HttpHeaders.*;
import static javax.ws.rs.core.MediaType.*;
import static org.glassfish.jersey.message.internal.HttpHeaderReader.*;
import static org.glassfish.jersey.message.internal.MediaTypes.*;
import static org.waarp.common.role.RoleDefault.ROLE.*;
import static org.waarp.openr66.protocol.configuration.Configuration.*;
import static org.waarp.openr66.protocol.http.restv2.RestConstants.*;

/**
 * This class defines hooks called before and after the corresponding {@link
 * AbstractRestDbHandler} when a
 * request is made. These hooks check the user authentication and privileges, as
 * well as the request content
 * type.
 */
public class RestHandlerHook implements HandlerHook {

  /**
   * Tells if the REST request authentication is activated.
   */
  private final boolean authenticated;

  /**
   * Stores the key used for HMAC authentication.
   */
  private final HmacSha256 hmac;

  /**
   * The time (in ms) for which a HMAC signed request is valid.
   */
  private final long delay;

  /**
   * The logger for all events.
   */
<span class="fc" id="L98">  private static final WaarpLogger logger =</span>
<span class="fc" id="L99">      WaarpLoggerFactory.getLogger(RestHandlerHook.class);</span>

  /**
   * Hook called before a request handler is called. Checks if the REST method
   * is active in the CRUD
   * configuration, checks the request's content type, and finally checks the
   * user authentication (if
   * activated).
   *
   * @param request the HttpRequest currently being processed
   * @param responder the HttpResponder sending the response
   * @param handlerInfo the information about the handler to which the
   *     request will be sent for processing
   *
   * @return {@code true} if the request can be handed to the handler, or
   *     {@code false} if an error occurred and
   *     a response must be sent immediately.
   */
  @Override
  public final boolean preCall(final HttpRequest request,
                               final HttpResponder responder,
                               final HandlerInfo handlerInfo) {

    try {
<span class="fc" id="L123">      final AbstractRestDbHandler handler = getHandler(handlerInfo);</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">      if (!handler.checkCRUD(request)) {</span>
<span class="nc" id="L125">        responder.sendStatus(METHOD_NOT_ALLOWED);</span>
<span class="nc" id="L126">        return false;</span>
      }

<span class="fc" id="L129">      final Method handleMethod = getMethod(handler, handlerInfo);</span>
<span class="pc bpc" id="L130" title="1 of 4 branches missed.">      if (authenticated &amp;&amp; !request.method().equals(OPTIONS)) {</span>
<span class="fc" id="L131">        final String user = checkCredentials(request);</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if (!checkAuthorization(user, handleMethod)) {</span>
<span class="nc" id="L133">          responder.sendStatus(FORBIDDEN);</span>
<span class="nc" id="L134">          return false;</span>
        }
      }

<span class="fc" id="L138">      final List&lt;MediaType&gt; expectedTypes = getExpectedMediaTypes(handleMethod);</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">      if (!checkContentType(request, expectedTypes)) {</span>
<span class="nc" id="L140">        final DefaultHttpHeaders headers = new DefaultHttpHeaders();</span>
<span class="nc" id="L141">        headers.add(ACCEPT, convertToString(expectedTypes));</span>
<span class="nc" id="L142">        responder.sendStatus(UNSUPPORTED_MEDIA_TYPE, headers);</span>
<span class="nc" id="L143">        return false;</span>
      }

<span class="fc" id="L146">      return true;</span>
<span class="fc" id="L147">    } catch (final NotAllowedException e) {</span>
<span class="fc" id="L148">      logger.info(e.getMessage());</span>
<span class="fc" id="L149">      final DefaultHttpHeaders headers = new DefaultHttpHeaders();</span>
<span class="fc" id="L150">      headers.add(WWW_AUTHENTICATE, &quot;Basic, HMAC&quot;);</span>
<span class="fc" id="L151">      responder.sendStatus(UNAUTHORIZED, headers);</span>
<span class="nc" id="L152">    } catch (final InternalServerErrorException e) {</span>
<span class="nc" id="L153">      logger.error(e);</span>
<span class="nc" id="L154">      responder.sendStatus(INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L155">    } catch (final Throwable t) {</span>
<span class="nc" id="L156">      logger.error(&quot;RESTv2 Unexpected exception caught -&gt;&quot;, t);</span>
<span class="nc" id="L157">      responder.sendStatus(INTERNAL_SERVER_ERROR);</span>
<span class="pc" id="L158">    }</span>
<span class="fc" id="L159">    return false;</span>
  }

  /**
   * Returns the {@link AbstractRestDbHandler} instance corresponding to the
   * info given as parameter.
   *
   * @param handlerInfo the information about the handler
   *
   * @return the corresponding AbstractRestDbHandler
   *
   * @throws IllegalArgumentException if the given handler does not
   *     exist.
   */
  private AbstractRestDbHandler getHandler(final HandlerInfo handlerInfo) {
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">    for (final AbstractRestDbHandler h : RestServiceInitializer.handlers) {</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">      if (h.getClass().getName().equals(handlerInfo.getHandlerName())) {</span>
<span class="fc" id="L176">        return h;</span>
      }
<span class="fc" id="L178">    }</span>
<span class="nc" id="L179">    throw new IllegalArgumentException(</span>
<span class="nc" id="L180">        &quot;The handler &quot; + handlerInfo.getHandlerName() + &quot; does not exist.&quot;);</span>
  }

  /**
   * Returns the {@link Method} object corresponding to the handler method
   * chosen to process the request. This
   * is needed to check for the annotations present on the method.
   *
   * @param handler the handler chosen to process the request
   * @param handlerInfo the information about the handler
   *
   * @return the corresponding Method object
   *
   * @throws IllegalArgumentException if the given method name does
   *     not exist
   */
  private Method getMethod(final AbstractRestDbHandler handler,
                           final HandlerInfo handlerInfo) {
<span class="fc" id="L198">    Method method = null;</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">    for (final Method m : handler.getClass().getMethods()) {//NOSONAR</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">      if (m.getName().equals(handlerInfo.getMethodName()) &amp;&amp;</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">          m.getParameterTypes()[0] == HttpRequest.class &amp;&amp;</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">          m.getParameterTypes()[1] == HttpResponder.class) {</span>
<span class="fc" id="L203">        method = m;</span>
<span class="fc" id="L204">        break;</span>
      }
    }
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">    if (method == null) {</span>
<span class="nc" id="L208">      throw new IllegalArgumentException(</span>
<span class="nc" id="L209">          &quot;The handler &quot; + handlerInfo.getHandlerName() +</span>
<span class="nc" id="L210">          &quot; does not have a method &quot; + handlerInfo.getMethodName());</span>
    }
<span class="fc" id="L212">    return method;</span>
  }

  /**
   * Return a List of all the {@link MediaType} accepted by the given {@link
   * Method}. This list is based on the
   * types indicated by the method's {@link Consumes} annotation. If the
   * annotation is absent, the method will
   * be assumed to accept any type.
   *
   * @param method the Method to inspect
   *
   * @return the list of all acceptable MediaType
   */
  private List&lt;MediaType&gt; getExpectedMediaTypes(final Method method) {
<span class="fc" id="L227">    List&lt;MediaType&gt; consumedTypes = WILDCARD_TYPE_SINGLETON_LIST;</span>

<span class="pc bpc" id="L229" title="1 of 2 branches missed.">    if (method.isAnnotationPresent(Consumes.class)) {</span>
<span class="fc" id="L230">      consumedTypes = createFrom(method.getAnnotation(Consumes.class));</span>
    } else {
<span class="nc" id="L232">      logger.warn(String.format(</span>
          &quot;[RESTv2] The method %s of handler %s is missing &quot; +
          &quot;a '%s' annotation for the expected request content type, &quot; +
<span class="nc" id="L235">          &quot;the default value '%s' was given instead.&quot;, method.getName(),</span>
<span class="nc" id="L236">          method.getDeclaringClass().getSimpleName(),</span>
<span class="nc" id="L237">          Consumes.class.getSimpleName(), WILDCARD));</span>
    }

<span class="fc" id="L240">    return consumedTypes;</span>
  }

  /**
   * Checks if the content type of the request is compatible with the expected
   * content type of the method
   * called. If no content type header can be found, the request will be
   * assumed to have a correct content type.
   *
   * @param request the HttpRequest sent by the user
   * @param consumedTypes a list of the acceptable MediaType for the
   *     request
   *
   * @return {@code true} if the request content type is acceptable, {@code
   *     false} otherwise.
   */
  private boolean checkContentType(final HttpRequest request,
                                   final List&lt;MediaType&gt; consumedTypes) {

<span class="fc" id="L259">    final String contentTypeHeader = request.headers().get(CONTENT_TYPE);</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">    if (ParametersChecker.isEmpty(contentTypeHeader)) {</span>
<span class="fc" id="L261">      return true;</span>
    }

    final MediaType requestType;
    try {
<span class="nc" id="L266">      requestType = readAcceptMediaType(contentTypeHeader).get(0);</span>
<span class="nc" id="L267">    } catch (final ParseException e) {</span>
<span class="nc" id="L268">      return false;</span>
<span class="nc" id="L269">    }</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">    for (final MediaType consumedType : consumedTypes) {</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">      if (requestType.isCompatible(consumedType)) {</span>
<span class="nc" id="L272">        return true;</span>
      }
<span class="nc" id="L274">    }</span>
<span class="nc" id="L275">    return false;</span>
  }

  /**
   * Checks if the user making the request does exist. If the user does exist,
   * this method returns the user's
   * name, otherwise throws a {@link NotAllowedException}.
   *
   * @param request the request currently being processed
   *
   * @return the user's name
   *
   * @throws InternalServerErrorException if an unexpected error
   *     occurred
   * @throws NotAllowedException if the user making the request does
   *     not exist
   */
  protected final String checkCredentials(final HttpRequest request) {

<span class="fc" id="L294">    final String authorization = request.headers().get(AUTHORIZATION);</span>

<span class="fc bfc" id="L296" title="All 2 branches covered.">    if (authorization == null) {</span>
<span class="fc" id="L297">      throw new NotAllowedException(&quot;Missing header for authentication.&quot;);</span>
    }

<span class="fc" id="L300">    final Pattern basicPattern = Pattern.compile(&quot;(Basic) (\\w+=*)&quot;);</span>
<span class="fc" id="L301">    final Matcher basicMatcher = basicPattern.matcher(authorization);</span>

<span class="pc bpc" id="L303" title="1 of 2 branches missed.">    if (basicMatcher.find()) {</span>

      final String[] credentials;
<span class="fc" id="L306">      credentials = new String(BaseXx.getFromBase64(basicMatcher.group(2)),</span>
<span class="fc" id="L307">                               WaarpStringUtils.UTF8).split(&quot;:&quot;, 2);</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">      if (credentials.length != 2) {</span>
<span class="nc" id="L309">        throw new NotAllowedException(</span>
            &quot;Invalid header for Basic authentication.&quot;);
      }
<span class="fc" id="L312">      final String user = credentials[0];</span>
<span class="fc" id="L313">      final String pswd = credentials[1];</span>

<span class="fc" id="L315">      HostDAO hostDAO = null;</span>
      Host host;
      try {
<span class="fc" id="L318">        hostDAO = DAO_FACTORY.getHostDAO(true);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">        if (!hostDAO.exist(user)) {</span>
<span class="fc" id="L320">          throw new NotAllowedException(&quot;User does not exist.&quot;);</span>
        }
<span class="fc" id="L322">        host = hostDAO.select(user);</span>
<span class="nc" id="L323">      } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L324">        throw new InternalServerErrorException(e);</span>
<span class="nc" id="L325">      } catch (final DAONoDataException e) {</span>
<span class="nc" id="L326">        throw new InternalServerErrorException(e);</span>
      } finally {
<span class="fc" id="L328">        DAOFactory.closeDAO(hostDAO);</span>
      }

      final String key;
      try {
<span class="fc" id="L333">        key = configuration.getCryptoKey().cryptToHex(pswd);</span>
<span class="nc" id="L334">      } catch (final Exception e) {</span>
<span class="nc" id="L335">        throw new InternalServerErrorException(</span>
            &quot;An error occurred when encrypting the password&quot;, e);
<span class="fc" id="L337">      }</span>
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">      if (!Arrays.equals(host.getHostkey(),</span>
<span class="fc" id="L339">                         key.getBytes(WaarpStringUtils.UTF8))) {</span>
<span class="nc" id="L340">        throw new NotAllowedException(&quot;Invalid password.&quot;);</span>
      }

<span class="fc" id="L343">      return user;</span>
    }

<span class="nc" id="L346">    final String authUser = request.headers().get(AUTH_USER);</span>
<span class="nc" id="L347">    final String authDate = request.headers().get(AUTH_TIMESTAMP);</span>

<span class="nc" id="L349">    final Pattern hmacPattern = Pattern.compile(&quot;(HMAC) (\\w+)&quot;);</span>
<span class="nc" id="L350">    final Matcher hmacMatcher = hmacPattern.matcher(authorization);</span>

<span class="nc bnc" id="L352" title="All 6 branches missed.">    if (hmacMatcher.find() &amp;&amp; authUser != null &amp;&amp; authDate != null) {</span>

<span class="nc" id="L354">      final String authKey = hmacMatcher.group(2);</span>
      final DateTime requestDate;
      try {
<span class="nc" id="L357">        requestDate = DateTime.parse(authDate);</span>
<span class="nc" id="L358">      } catch (final IllegalArgumentException e) {</span>
<span class="nc" id="L359">        throw new NotAllowedException(&quot;Invalid authentication timestamp.&quot;);</span>
<span class="nc" id="L360">      }</span>
<span class="nc" id="L361">      final DateTime limitTime = requestDate.plus(delay);</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">      if (DateTime.now().isAfter(limitTime)) {</span>
<span class="nc" id="L363">        throw new NotAllowedException(&quot;Authentication expired.&quot;);</span>
      }

<span class="nc" id="L366">      HostDAO hostDAO = null;</span>
      Host host;
      try {
<span class="nc" id="L369">        hostDAO = DAO_FACTORY.getHostDAO(true);</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">        if (!hostDAO.exist(authUser)) {</span>
<span class="nc" id="L371">          throw new NotAllowedException(&quot;User does not exist.&quot;);</span>
        }
<span class="nc" id="L373">        host = hostDAO.select(authUser);</span>
<span class="nc" id="L374">      } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L375">        throw new InternalServerErrorException(e);</span>
<span class="nc" id="L376">      } catch (final DAONoDataException e) {</span>
<span class="nc" id="L377">        throw new InternalServerErrorException(e);</span>
      } finally {
<span class="nc" id="L379">        DAOFactory.closeDAO(hostDAO);</span>
      }

<span class="nc" id="L382">      validateHMACCredentials(host, authDate, authUser, authKey);</span>

<span class="nc" id="L384">      return authUser;</span>
    }

<span class="nc" id="L387">    throw new NotAllowedException(&quot;Missing credentials.&quot;);</span>
  }

  protected final void validateHMACCredentials(final Host host,
                                               final String authDate,
                                               final String authUser,
                                               final String authKey)
      throws InternalServerErrorException {
    final String pswd;
    try {
<span class="fc" id="L397">      pswd = configuration.getCryptoKey().decryptHexInString(host.getHostkey());</span>
<span class="nc" id="L398">    } catch (final Exception e) {</span>
<span class="nc" id="L399">      throw new InternalServerErrorException(</span>
          &quot;An error occurred when decrypting the password&quot;, e);
<span class="fc" id="L401">    }</span>

    final String key;
    try {
<span class="fc" id="L405">      key = hmac.cryptToHex(authDate + authUser + pswd);</span>
<span class="nc" id="L406">    } catch (final Exception e) {</span>
<span class="nc" id="L407">      throw new InternalServerErrorException(</span>
          &quot;An error occurred when hashing the key&quot;, e);
<span class="fc" id="L409">    }</span>

<span class="pc bpc" id="L411" title="1 of 2 branches missed.">    if (!key.equals(authKey)) {</span>
<span class="nc" id="L412">      throw new NotAllowedException(&quot;Invalid password.&quot;);</span>
    }
<span class="fc" id="L414">  }</span>

  /**
   * Checks if the user given as argument is authorized to call the given
   * method.
   *
   * @param user the name of the user making the request
   * @param method the method called by the request
   *
   * @return {@code true} if the user is authorized to make the request,
   *     {@code false} otherwise.
   */
  protected final boolean checkAuthorization(final String user,
                                             final Method method) {
    try {
<span class="fc" id="L429">      final DbHostAuth hostAuth = new DbHostAuth(user);</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">      if (hostAuth.isAdminrole()) {</span>
<span class="fc" id="L431">        return true;</span>
      }
<span class="nc" id="L433">    } catch (final WaarpDatabaseException e) {</span>
      // ignore and continue
<span class="fc" id="L435">    }</span>

<span class="fc" id="L437">    ROLE requiredRole = NOACCESS;</span>
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">    if (method.isAnnotationPresent(RequiredRole.class)) {</span>
<span class="fc" id="L439">      requiredRole = method.getAnnotation(RequiredRole.class).value();</span>
    } else {
<span class="nc" id="L441">      logger.warn(String.format(&quot;[RESTv2] The method %s of handler %s is &quot; +</span>
                                &quot;missing a '%s' annotation for the minimum required role, &quot; +
                                &quot;the default value '%s' was given instead.&quot;,
<span class="nc" id="L444">                                method.getName(),</span>
<span class="nc" id="L445">                                method.getDeclaringClass().getSimpleName(),</span>
<span class="nc" id="L446">                                RequiredRole.class.getSimpleName(), NOACCESS));</span>
    }
<span class="fc bfc" id="L448" title="All 2 branches covered.">    if (requiredRole == NOACCESS) {</span>
<span class="fc" id="L449">      return true;</span>
    }

<span class="fc" id="L452">    final List&lt;ROLE&gt; roles = HostConfigConverter.getRoles(user);</span>
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">    if (roles != null) {</span>
<span class="fc" id="L454">      final RoleDefault roleDefault = new RoleDefault();</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">      for (final ROLE roleType : roles) {</span>
<span class="fc" id="L456">        roleDefault.addRole(roleType);</span>
<span class="fc" id="L457">      }</span>
<span class="fc" id="L458">      return roleDefault.isContaining(requiredRole);</span>
    }
<span class="nc" id="L460">    return false;</span>
  }

  /**
   * Hook called after a request handler is called.
   *
   * @param httpRequest the request currently being processed
   * @param httpResponseStatus the status of the http response
   *     generated by the request handler
   * @param handlerInfo information about the handler to which the
   *     request was sent
   */
  @Override
  public final void postCall(final HttpRequest httpRequest,
                             final HttpResponseStatus httpResponseStatus,
                             final HandlerInfo handlerInfo) {
    // ignore
<span class="fc" id="L477">  }</span>

  /**
   * Creates a HandlerHook which will check for authentication and signature
   * on incoming request depending on
   * the parameters.
   *
   * @param authenticated specifies if the HandlerHook will check
   *     authentication
   * @param hmac the key used for HMAC authentication
   * @param delay the delay for which a HMAC signed request is valid
   */
  public RestHandlerHook(final boolean authenticated, final HmacSha256 hmac,
<span class="fc" id="L490">                         final long delay) {</span>
<span class="fc" id="L491">    this.authenticated = authenticated;</span>
<span class="fc" id="L492">    this.hmac = hmac;</span>
<span class="fc" id="L493">    this.delay = delay;</span>
<span class="fc" id="L494">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>