<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XmlUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Waarp Common</a> &gt; <a href="index.source.html" class="el_package">org.waarp.common.xml</a> &gt; <span class="el_source">XmlUtil.java</span></div><h1>XmlUtil.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.common.xml;

import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.DocumentHelper;
import org.dom4j.Element;
import org.dom4j.Node;
import org.dom4j.io.OutputFormat;
import org.dom4j.io.SAXReader;
import org.dom4j.io.XMLWriter;
import org.waarp.common.exception.InvalidArgumentException;
import org.waarp.common.utility.WaarpStringUtils;
import org.xml.sax.SAXException;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InvalidObjectException;
import java.io.Writer;
import java.util.List;

/**
 * XML utility that handles simple cases as:&lt;br&gt;
 * &lt;ul&gt;
 * &lt;li&gt;XPath as /x/y/z for a node and referring to root of Document&lt;/li&gt;
 * &lt;li&gt;XPath as x/y/z for a node and referring to current referenced node&lt;/li&gt;
 * &lt;li&gt;Any XPath can be a singleton (unique node referenced by the XPath) or
 * multiple nodes (same XPath)&lt;/li&gt;
 * &lt;li&gt;Only Element as Node: no Attribute or any other type within XML&lt;/li&gt;
 * &lt;li&gt;Any other path is not supported: //x /x@y ./ ../&lt;/li&gt;
 * &lt;li&gt;Supports special SubXml tree as element (singleton or multiple)&lt;/li&gt;
 * &lt;/ul&gt;
 */
public final class XmlUtil {

  private static final String NODE_NOT_FOUND = &quot;Node not found: &quot;;

  private XmlUtil() {
  }

  /**
   * @return the newly created SAXReader
   */
  public static SAXReader getNewSaxReader() {
<span class="fc" id="L64">    final SAXReader saxReader = new SAXReader();</span>
    try {
<span class="fc" id="L66">      saxReader.setFeature(</span>
          &quot;http://apache.org/xml/features/nonvalidating/load-dtd-grammar&quot;,
          false);
<span class="fc" id="L69">      saxReader.setFeature(</span>
          &quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;,
          false);
<span class="fc" id="L72">      saxReader</span>
<span class="fc" id="L73">          .setFeature(&quot;http://xml.org/sax/features/resolve-dtd-uris&quot;, false);</span>
<span class="fc" id="L74">      saxReader</span>
<span class="fc" id="L75">          .setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;,</span>
                      false);
<span class="fc" id="L77">      saxReader</span>
<span class="fc" id="L78">          .setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;,</span>
                      false);
<span class="fc" id="L80">      saxReader.setFeature(</span>
          &quot;http://apache.org/xml/features/validation/id-idref-checking&quot;, false);
<span class="nc" id="L82">    } catch (final SAXException e) {</span>
      //Parse with external resources downloading allowed.
<span class="fc" id="L84">    }</span>
<span class="fc" id="L85">    return saxReader;</span>
  }

  /**
   * @param filename
   *
   * @return Existing Document from filename
   *
   * @throws IOException
   * @throws DocumentException
   */
  public static Document getDocument(final String filename)
      throws IOException, DocumentException {
<span class="fc" id="L98">    final File file = new File(filename);</span>
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">    if (!file.canRead()) {</span>
<span class="nc" id="L100">      throw new IOException(&quot;File is not readable: &quot; + filename);</span>
    }
<span class="fc" id="L102">    return getDocument(file);</span>
  }

  /**
   * @param file
   *
   * @return Existing Document from file
   *
   * @throws IOException
   * @throws DocumentException
   */
  public static Document getDocument(final File file)
      throws IOException, DocumentException {
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">    if (!file.canRead()) {</span>
<span class="nc" id="L116">      throw new IOException(&quot;File is not readable: &quot; + file.getPath());</span>
    }
<span class="fc" id="L118">    final SAXReader reader = getNewSaxReader();</span>
<span class="fc" id="L119">    return reader.read(file);</span>
  }

  /**
   * Read the document from the string
   *
   * @param document as String
   *
   * @return the Document
   *
   * @throws DocumentException
   */
  public static Document readDocument(final String document)
      throws DocumentException {
<span class="fc" id="L133">    return DocumentHelper.parseText(document);</span>
  }

  /**
   * @param document
   *
   * @return the document as an XML string
   */
  public static String writeToString(final Document document) {
<span class="fc" id="L142">    return document.asXML();</span>
  }

  /**
   * @param element
   *
   * @return the element as an XML string
   */
  public static String writeToString(final Element element) {
<span class="nc" id="L151">    return element.asXML();</span>
  }

  /**
   * @return an empty new Document
   */
  public static Document createEmptyDocument() {
<span class="fc" id="L158">    return DocumentHelper.createDocument();</span>
  }

  /**
   * Save the document into the file
   *
   * @param filename
   * @param document
   *
   * @throws IOException
   */
  public static void saveDocument(final String filename,
                                  final Document document) throws IOException {
<span class="fc" id="L171">    final File file = new File(filename);</span>
<span class="fc" id="L172">    saveDocument(file, document);</span>
<span class="fc" id="L173">  }</span>

  /**
   * Save the document into the file
   *
   * @param file
   * @param document
   *
   * @throws IOException
   */
  public static void saveDocument(final File file, final Document document)
      throws IOException {
<span class="pc bpc" id="L185" title="2 of 4 branches missed.">    if (file.exists() &amp;&amp; !file.canWrite()) {</span>
<span class="nc" id="L186">      throw new IOException(&quot;File is not writable: &quot; + file.getPath());</span>
    }

<span class="fc" id="L189">    saveDocument(new FileWriter(file), document);</span>
<span class="fc" id="L190">  }</span>

  /**
   * Save the document into the Writer outWriter
   *
   * @param outWriter
   * @param document
   *
   * @throws IOException
   */
  public static void saveDocument(final Writer outWriter,
                                  final Document document) throws IOException {
<span class="fc" id="L202">    final OutputFormat format = OutputFormat.createPrettyPrint();</span>
<span class="fc" id="L203">    format.setEncoding(WaarpStringUtils.UTF8.name());</span>
<span class="fc" id="L204">    final XMLWriter writer = new XMLWriter(outWriter, format);</span>
<span class="fc" id="L205">    writer.write(document);</span>
<span class="fc" id="L206">    writer.flush();</span>
<span class="fc" id="L207">    writer.close();</span>
<span class="fc" id="L208">  }</span>

  /**
   * Save the branch from element into the file
   *
   * @param filename
   * @param element
   *
   * @throws IOException
   */
  public static void saveElement(final String filename, final Element element)
      throws IOException {
<span class="fc" id="L220">    final File file = new File(filename);</span>
<span class="fc" id="L221">    saveElement(file, element);</span>
<span class="fc" id="L222">  }</span>

  /**
   * Save the branch from element into the file
   *
   * @param file
   * @param element
   *
   * @throws IOException
   */
  public static void saveElement(final File file, final Element element)
      throws IOException {
<span class="pc bpc" id="L234" title="2 of 4 branches missed.">    if (file.exists() &amp;&amp; !file.canWrite()) {</span>
<span class="nc" id="L235">      throw new IOException(&quot;File is not writable: &quot; + file.getPath());</span>
    }
<span class="fc" id="L237">    final OutputFormat format = OutputFormat.createPrettyPrint();</span>
<span class="fc" id="L238">    format.setEncoding(WaarpStringUtils.UTF8.name());</span>
<span class="fc" id="L239">    final XMLWriter writer = new XMLWriter(new FileWriter(file), format);</span>
<span class="fc" id="L240">    writer.write(element);</span>
<span class="fc" id="L241">    writer.flush();</span>
<span class="fc" id="L242">    writer.close();</span>
<span class="fc" id="L243">  }</span>

  /**
   * @param document
   *
   * @return the root Element from the document
   */
  public static Element getRootElement(final Document document) {
<span class="nc" id="L251">    return document.getRootElement();</span>
  }

  /**
   * Add or Get (if already existing) an element given by the path relative to
   * the referent element and set the
   * value
   *
   * @param ref
   * @param path
   * @param value
   *
   * @return the new added or already existing element with new value
   */
  public static Element addOrSetElement(final Element ref, final String path,
                                        final String value) {
<span class="fc" id="L267">    final Element current = addOrGetElement(ref, path);</span>
<span class="fc" id="L268">    current.setText(value);</span>
<span class="fc" id="L269">    return current;</span>
  }

  /**
   * Add or Get (if already existing) an element given by the path relative to
   * the referent element
   *
   * @param ref
   * @param path
   *
   * @return the new added or already existing element
   */
  public static Element addOrGetElement(final Element ref, final String path) {
<span class="fc" id="L282">    final String[] pathes = path.split(&quot;/&quot;);</span>
<span class="fc" id="L283">    Element current = ref;</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">    for (final String nodename : pathes) {</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">      if (!nodename.isEmpty()) {</span>
<span class="fc" id="L286">        final Element exist = current.element(nodename);</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">        if (exist == null) {</span>
<span class="fc" id="L288">          current = current.addElement(nodename);</span>
        } else {
<span class="fc" id="L290">          current = exist;</span>
        }
      }
    }
<span class="fc" id="L294">    return current;</span>
  }

  /**
   * Add an element given by the path relative to the referent element and set
   * the value
   *
   * @param ref
   * @param path
   * @param value
   *
   * @return the new added element with value
   */
  public static Element addAndSetElementMultiple(final Element ref,
                                                 final String path,
                                                 final String value) {
<span class="fc" id="L310">    final Element current = addAndGetElementMultiple(ref, path);</span>
<span class="fc" id="L311">    current.setText(value);</span>
<span class="fc" id="L312">    return current;</span>
  }

  /**
   * Add an element given by the path relative to the referent element
   *
   * @param ref
   * @param path
   *
   * @return the new added element
   */
  public static Element addAndGetElementMultiple(final Element ref,
                                                 final String path) {
<span class="fc" id="L325">    final String[] pathes = path.split(&quot;/&quot;);</span>
<span class="fc" id="L326">    Element current = ref;</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">    for (int i = 0; i &lt; pathes.length - 1; i++) {</span>
<span class="fc" id="L328">      final String nodename = pathes[i];</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">      if (!nodename.isEmpty()) {</span>
<span class="fc" id="L330">        final Element exist = current.element(nodename);</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">        if (exist == null) {</span>
<span class="fc" id="L332">          current = current.addElement(nodename);</span>
        } else {
<span class="fc" id="L334">          current = exist;</span>
        }
      }
    }
<span class="fc" id="L338">    final String nodename = pathes[pathes.length - 1];</span>
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">    if (!nodename.isEmpty()) {</span>
<span class="fc" id="L340">      current = current.addElement(nodename);</span>
    }
<span class="fc" id="L342">    return current;</span>
  }

  /**
   * @param ref
   * @param path
   *
   * @return the parent element associated with the path relatively to the
   *     referent element
   *
   * @throws DocumentException
   */
  public static Element getParentElement(final Element ref, final String path)
      throws DocumentException {
<span class="nc" id="L356">    String npath = path;</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">    while (npath.charAt(0) == '/') {</span>
<span class="nc" id="L358">      npath = npath.substring(1);</span>
    }
<span class="nc" id="L360">    final Element current = (Element) ref.selectSingleNode(npath);</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">    if (current == null) {</span>
<span class="nc" id="L362">      throw new DocumentException(NODE_NOT_FOUND + path);</span>
    }
<span class="nc" id="L364">    return current.getParent();</span>
  }

  /**
   * @param ref
   * @param path
   *
   * @return the element associated with the path relatively to the referent
   *     element
   *
   * @throws DocumentException
   */
  public static Element getElement(final Element ref, final String path)
      throws DocumentException {
<span class="fc" id="L378">    String npath = path;</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">    while (npath.charAt(0) == '/') {</span>
<span class="fc" id="L380">      npath = npath.substring(1);</span>
    }
<span class="fc" id="L382">    final Element current = (Element) ref.selectSingleNode(npath);</span>
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">    if (current == null) {</span>
<span class="nc" id="L384">      throw new DocumentException(NODE_NOT_FOUND + path);</span>
    }
<span class="fc" id="L386">    return current;</span>
  }

  /**
   * @param ref
   * @param path
   *
   * @return the element associated with the path relatively to the referent
   *     element
   *
   * @throws DocumentException
   */
  public static List&lt;Node&gt; getElementMultiple(final Element ref,
                                              final String path)
      throws DocumentException {
<span class="fc" id="L401">    String npath = path;</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">    while (npath.charAt(0) == '/') {</span>
<span class="fc" id="L403">      npath = npath.substring(1);</span>
    }
<span class="fc" id="L405">    final List&lt;Node&gt; list = ref.selectNodes(npath);</span>
<span class="pc bpc" id="L406" title="2 of 4 branches missed.">    if (list == null || list.isEmpty()) {</span>
<span class="nc" id="L407">      throw new DocumentException(&quot;Nodes not found: &quot; + path);</span>
    }
<span class="fc" id="L409">    return list;</span>
  }

  /**
   * Add or Get (if already existing) an element given by the path relative to
   * the document and set the value
   *
   * @param doc
   * @param path
   * @param value
   *
   * @return the new added or already existing element with new value
   */
  public static Element addOrSetElement(final Document doc, final String path,
                                        final String value) {
<span class="fc" id="L424">    final Element current = addOrGetElement(doc, path);</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">    if (current != null) {</span>
<span class="fc" id="L426">      current.setText(value);</span>
    }
<span class="fc" id="L428">    return current;</span>
  }

  /**
   * Add or Get (if already existing) an element given by the path relative to
   * the document
   *
   * @param doc
   * @param path
   *
   * @return the new added or already existing element
   */
  public static Element addOrGetElement(final Document doc, final String path) {
<span class="fc" id="L441">    final String[] pathes = path.split(&quot;/&quot;);</span>
    int rank;
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">    for (rank = 0; rank &lt; pathes.length; rank++) {</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">      if (!pathes[rank].isEmpty()) {</span>
<span class="fc" id="L445">        break; // found</span>
      }
    }
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">    if (rank &gt;= pathes.length) {</span>
<span class="nc" id="L449">      return null; // Should not be !</span>
    }
<span class="fc" id="L451">    Element current = (Element) doc.selectSingleNode(pathes[rank]);</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">    if (current == null) {</span>
<span class="fc" id="L453">      current = doc.addElement(pathes[rank]);</span>
    }
<span class="fc bfc" id="L455" title="All 2 branches covered.">    for (int i = rank + 1; i &lt; pathes.length; i++) {</span>
<span class="fc" id="L456">      final String nodename = pathes[i];</span>
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">      if (!nodename.isEmpty()) {</span>
<span class="fc" id="L458">        final Element exist = current.element(nodename);</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">        if (exist == null) {</span>
<span class="fc" id="L460">          current = current.addElement(nodename);</span>
        } else {
<span class="fc" id="L462">          current = exist;</span>
        }
      }
    }
<span class="fc" id="L466">    return current;</span>
  }

  /**
   * Add an element given by the path relative to the document and set the
   * value
   *
   * @param doc
   * @param path
   * @param value
   *
   * @return the new added element with value
   */
  public static Element addAndSetElementMultiple(final Document doc,
                                                 final String path,
                                                 final String value) {
<span class="fc" id="L482">    final Element current = addAndGetElementMultiple(doc, path);</span>
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">    if (current != null) {</span>
<span class="fc" id="L484">      current.setText(value);</span>
    }
<span class="fc" id="L486">    return current;</span>
  }

  /**
   * Add an element given by the path relative to the document
   *
   * @param doc
   * @param path
   *
   * @return the new added element
   */
  public static Element addAndGetElementMultiple(final Document doc,
                                                 final String path) {
<span class="fc" id="L499">    final String[] pathes = path.split(&quot;/&quot;);</span>
    int rank;
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">    for (rank = 0; rank &lt; pathes.length; rank++) {</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">      if (!pathes[rank].isEmpty()) {</span>
<span class="fc" id="L503">        break; // found</span>
      }
    }
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">    if (rank &gt;= pathes.length) {</span>
<span class="nc" id="L507">      return null; // Should not be !</span>
    }
<span class="fc" id="L509">    Element current = (Element) doc.selectSingleNode(pathes[rank]);</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">    if (current == null) {</span>
<span class="nc" id="L511">      current = doc.addElement(pathes[rank]);</span>
    }
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">    if (rank == pathes.length - 1) {</span>
      // Last level is the root !!! No multiple root is allowed !!!
      // So just give back the root if it exists
<span class="nc" id="L516">      return current;</span>
    }
<span class="fc bfc" id="L518" title="All 2 branches covered.">    for (int i = rank + 1; i &lt; pathes.length - 1; i++) {</span>
<span class="fc" id="L519">      final String nodename = pathes[i];</span>
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">      if (!nodename.isEmpty()) {</span>
<span class="fc" id="L521">        final Element exist = current.element(nodename);</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">        if (exist == null) {</span>
<span class="fc" id="L523">          current = current.addElement(nodename);</span>
        } else {
<span class="fc" id="L525">          current = exist;</span>
        }
      }
    }
<span class="fc" id="L529">    final String nodename = pathes[pathes.length - 1];</span>
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">    if (!nodename.isEmpty()) {</span>
<span class="fc" id="L531">      current = current.addElement(nodename);</span>
    }
<span class="fc" id="L533">    return current;</span>
  }

  /**
   * @param doc
   * @param path
   *
   * @return the Parent element associated with the path relatively to the
   *     document
   *
   * @throws DocumentException
   */
  public static Element getParentElement(final Document doc, final String path)
      throws DocumentException {
<span class="nc" id="L547">    final Element current = (Element) doc.selectSingleNode(path);</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">    if (current == null) {</span>
<span class="nc" id="L549">      throw new DocumentException(NODE_NOT_FOUND + path);</span>
    }
<span class="nc" id="L551">    return current.getParent();</span>
  }

  /**
   * @param doc
   * @param path
   *
   * @return the element associated with the path relatively to the document
   *
   * @throws DocumentException
   */
  public static Element getElement(final Document doc, final String path)
      throws DocumentException {
<span class="fc" id="L564">    final Element current = (Element) doc.selectSingleNode(path);</span>
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">    if (current == null) {</span>
<span class="nc" id="L566">      throw new DocumentException(NODE_NOT_FOUND + path);</span>
    }
<span class="fc" id="L568">    return current;</span>
  }

  /**
   * @param doc
   * @param path
   *
   * @return the element associated with the path relatively to the document
   *
   * @throws DocumentException
   */
  public static List&lt;Node&gt; getElementMultiple(final Document doc,
                                              final String path)
      throws DocumentException {
<span class="fc" id="L582">    final List&lt;Node&gt; list = doc.selectNodes(path);</span>
<span class="pc bpc" id="L583" title="1 of 4 branches missed.">    if (list == null || list.isEmpty()) {</span>
<span class="fc" id="L584">      throw new DocumentException(&quot;Nodes not found: &quot; + path);</span>
    }
<span class="fc" id="L586">    return list;</span>
  }

  /**
   * Remove extra space and tab, newline from beginning and end of String
   *
   * @param string
   *
   * @return the trimed string
   */
  public static String getExtraTrimed(final String string) {
<span class="fc" id="L597">    return string.replaceAll(&quot;^[\\s]*|[\\s]*$&quot;, &quot;&quot;);</span>
  }

  /**
   * Create the XmlValues from the XmlDevls and the Document
   *
   * @param doc
   * @param decls
   *
   * @return XmlValues
   */
  public static XmlValue[] read(final Document doc, final XmlDecl[] decls) {
    final XmlValue[] values;
<span class="fc" id="L610">    final int len = decls.length;</span>
<span class="fc" id="L611">    values = new XmlValue[len];</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">    for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L613">      final XmlValue value = new XmlValue(decls[i]);</span>
<span class="fc" id="L614">      values[i] = value;</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">      if (decls[i].isSubXml()) {</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">        if (decls[i].isMultiple()) {</span>
          final List&lt;Node&gt; elts;
          try {
<span class="fc" id="L619">            elts = getElementMultiple(doc, decls[i].getXmlPath());</span>
<span class="nc" id="L620">          } catch (final DocumentException e) {</span>
<span class="nc" id="L621">            continue;</span>
<span class="fc" id="L622">          }</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">          for (final Node element : elts) {</span>
<span class="fc" id="L624">            final XmlValue[] newValue =</span>
<span class="fc" id="L625">                read((Element) element, decls[i].getSubXml());</span>
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">            if (newValue == null) {</span>
<span class="nc" id="L627">              continue;</span>
            }
            try {
<span class="fc" id="L630">              value.addValue(newValue);</span>
<span class="nc" id="L631">            } catch (final InvalidObjectException e) {</span>
              // nothing
<span class="fc" id="L633">            }</span>
<span class="fc" id="L634">          }</span>
<span class="fc" id="L635">        } else {</span>
          final Element element;
          try {
<span class="fc" id="L638">            element = getElement(doc, decls[i].getXmlPath());</span>
<span class="nc" id="L639">          } catch (final DocumentException e) {</span>
<span class="nc" id="L640">            continue;</span>
<span class="fc" id="L641">          }</span>
<span class="fc" id="L642">          final XmlValue[] newValue = read(element, decls[i].getSubXml());</span>
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">          if (newValue == null) {</span>
<span class="nc" id="L644">            continue;</span>
          }
          try {
<span class="fc" id="L647">            value.setValue(newValue);</span>
<span class="nc" id="L648">          } catch (final InvalidObjectException e) {</span>
            // nothing
<span class="fc" id="L650">          }</span>
<span class="fc" id="L651">        }</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">      } else if (decls[i].isMultiple()) {</span>
        final List&lt;Node&gt; elts;
        try {
<span class="fc" id="L655">          elts = getElementMultiple(doc, decls[i].getXmlPath());</span>
<span class="fc" id="L656">        } catch (final DocumentException e) {</span>
<span class="fc" id="L657">          continue;</span>
<span class="fc" id="L658">        }</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">        for (final Node element : elts) {</span>
<span class="fc" id="L660">          final String svalue = element.getText();</span>
          try {
<span class="fc" id="L662">            value.addFromString(getExtraTrimed(svalue));</span>
<span class="fc" id="L663">          } catch (final InvalidObjectException e) {</span>
            // nothing
<span class="fc" id="L665">          } catch (final InvalidArgumentException e) {</span>
            // nothing
<span class="fc" id="L667">          }</span>
<span class="fc" id="L668">        }</span>
<span class="fc" id="L669">      } else {</span>
        final Element element;
        try {
<span class="fc" id="L672">          element = getElement(doc, decls[i].getXmlPath());</span>
<span class="nc" id="L673">        } catch (final DocumentException e) {</span>
<span class="nc" id="L674">          continue;</span>
<span class="fc" id="L675">        }</span>
<span class="fc" id="L676">        final String svalue = element.getText();</span>
        try {
<span class="fc" id="L678">          value.setFromString(getExtraTrimed(svalue));</span>
<span class="nc" id="L679">        } catch (final InvalidArgumentException e) {</span>
          // nothing
<span class="fc" id="L681">        }</span>
      }
    }
<span class="fc" id="L684">    return values;</span>
  }

  /**
   * Create the XmlValues from the XmlDevls and the reference Element
   *
   * @param ref
   * @param decls
   *
   * @return XmlValues
   */
  public static XmlValue[] read(final Element ref, final XmlDecl[] decls) {
    final XmlValue[] values;
<span class="fc" id="L697">    final int len = decls.length;</span>
<span class="fc" id="L698">    values = new XmlValue[len];</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">    for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L700">      final XmlValue value = new XmlValue(decls[i]);</span>
<span class="fc" id="L701">      values[i] = value;</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">      if (decls[i].isSubXml()) {</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">        if (decls[i].isMultiple()) {</span>
          final List&lt;Node&gt; elts;
          try {
<span class="fc" id="L706">            elts = getElementMultiple(ref, decls[i].getXmlPath());</span>
<span class="nc" id="L707">          } catch (final DocumentException e) {</span>
<span class="nc" id="L708">            continue;</span>
<span class="fc" id="L709">          }</span>
<span class="fc bfc" id="L710" title="All 2 branches covered.">          for (final Node element : elts) {</span>
<span class="fc" id="L711">            final XmlValue[] newValue =</span>
<span class="fc" id="L712">                read((Element) element, decls[i].getSubXml());</span>
<span class="pc bpc" id="L713" title="1 of 2 branches missed.">            if (newValue == null) {</span>
<span class="nc" id="L714">              continue;</span>
            }
            try {
<span class="fc" id="L717">              value.addValue(newValue);</span>
<span class="nc" id="L718">            } catch (final InvalidObjectException e) {</span>
              // nothing
<span class="fc" id="L720">            }</span>
<span class="fc" id="L721">          }</span>
<span class="fc" id="L722">        } else {</span>
          final Element element;
          try {
<span class="fc" id="L725">            element = getElement(ref, decls[i].getXmlPath());</span>
<span class="nc" id="L726">          } catch (final DocumentException e) {</span>
<span class="nc" id="L727">            continue;</span>
<span class="fc" id="L728">          }</span>
<span class="fc" id="L729">          final XmlValue[] newValue = read(element, decls[i].getSubXml());</span>
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">          if (newValue == null) {</span>
<span class="nc" id="L731">            continue;</span>
          }
          try {
<span class="fc" id="L734">            value.setValue(newValue);</span>
<span class="nc" id="L735">          } catch (final InvalidObjectException e) {</span>
            // nothing
<span class="fc" id="L737">          }</span>
<span class="fc" id="L738">        }</span>
<span class="fc bfc" id="L739" title="All 2 branches covered.">      } else if (decls[i].isMultiple()) {</span>
        final List&lt;Node&gt; elts;
        try {
<span class="fc" id="L742">          elts = getElementMultiple(ref, decls[i].getXmlPath());</span>
<span class="nc" id="L743">        } catch (final DocumentException e) {</span>
<span class="nc" id="L744">          continue;</span>
<span class="fc" id="L745">        }</span>
<span class="fc bfc" id="L746" title="All 2 branches covered.">        for (final Node element : elts) {</span>
<span class="fc" id="L747">          final String svalue = element.getText();</span>
          try {
<span class="fc" id="L749">            value.addFromString(getExtraTrimed(svalue));</span>
<span class="nc" id="L750">          } catch (final InvalidObjectException e) {</span>
            // nothing
<span class="nc" id="L752">          } catch (final InvalidArgumentException e) {</span>
            // nothing
<span class="pc" id="L754">          }</span>
<span class="fc" id="L755">        }</span>
<span class="fc" id="L756">      } else {</span>
        final Element element;
        try {
<span class="fc" id="L759">          element = getElement(ref, decls[i].getXmlPath());</span>
<span class="nc" id="L760">        } catch (final DocumentException e) {</span>
<span class="nc" id="L761">          continue;</span>
<span class="fc" id="L762">        }</span>
<span class="fc" id="L763">        final String svalue = element.getText();</span>
        try {
<span class="fc" id="L765">          value.setFromString(getExtraTrimed(svalue));</span>
<span class="fc" id="L766">        } catch (final InvalidArgumentException e) {</span>
          // nothing
<span class="fc" id="L768">        }</span>
      }
    }
<span class="fc" id="L771">    return values;</span>
  }

  /**
   * Add all nodes from XmlValues into Document
   *
   * @param doc
   * @param values
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static void write(final Document doc, final XmlValue[] values) {
<span class="fc bfc" id="L782" title="All 2 branches covered.">    for (final XmlValue value : values) {</span>
<span class="pc bpc" id="L783" title="1 of 2 branches missed.">      if (value != null) {</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">        if (value.isSubXml()) {</span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">          if (value.isMultiple()) {</span>
<span class="fc" id="L786">            final List&lt;XmlValue[]&gt; list = (List&lt;XmlValue[]&gt;) value.getList();</span>
<span class="fc bfc" id="L787" title="All 2 branches covered.">            for (final XmlValue[] object : list) {</span>
<span class="fc" id="L788">              final Element ref =</span>
<span class="fc" id="L789">                  addAndGetElementMultiple(doc, value.getXmlPath());</span>
<span class="fc" id="L790">              write(ref, object);</span>
<span class="fc" id="L791">            }</span>
<span class="fc" id="L792">          } else {</span>
<span class="fc" id="L793">            final Element ref = addOrGetElement(doc, value.getXmlPath());</span>
<span class="fc" id="L794">            write(ref, value.getSubXml());</span>
<span class="fc" id="L795">          }</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">        } else if (value.isMultiple()) {</span>
<span class="fc" id="L797">          final List&lt;?&gt; list = value.getList();</span>
<span class="fc bfc" id="L798" title="All 2 branches covered.">          for (final Object object : list) {</span>
<span class="fc" id="L799">            addAndSetElementMultiple(doc, value.getXmlPath(),</span>
<span class="fc" id="L800">                                     object.toString());</span>
<span class="fc" id="L801">          }</span>
<span class="fc" id="L802">        } else {</span>
<span class="fc" id="L803">          addOrSetElement(doc, value.getXmlPath(), value.getIntoString());</span>
        }
      }
    }
<span class="fc" id="L807">  }</span>

  /**
   * Add all nodes from XmlValues from the referenced Element
   *
   * @param ref
   * @param values
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static void write(final Element ref, final XmlValue[] values) {
<span class="fc bfc" id="L817" title="All 2 branches covered.">    for (final XmlValue value : values) {</span>
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">      if (value != null) {</span>
<span class="pc bpc" id="L819" title="1 of 2 branches missed.">        if (value.isSubXml()) {</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">          if (value.isMultiple()) {</span>
<span class="nc" id="L821">            final List&lt;XmlValue[]&gt; list = (List&lt;XmlValue[]&gt;) value.getList();</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">            for (final XmlValue[] object : list) {</span>
<span class="nc" id="L823">              final Element newref =</span>
<span class="nc" id="L824">                  addAndGetElementMultiple(ref, value.getXmlPath());</span>
<span class="nc" id="L825">              write(newref, object);</span>
<span class="nc" id="L826">            }</span>
<span class="nc" id="L827">          } else {</span>
<span class="nc" id="L828">            final Element newref = addOrGetElement(ref, value.getXmlPath());</span>
<span class="nc" id="L829">            write(newref, value.getSubXml());</span>
<span class="nc" id="L830">          }</span>
<span class="fc bfc" id="L831" title="All 2 branches covered.">        } else if (value.isMultiple()) {</span>
<span class="fc" id="L832">          final List&lt;?&gt; list = value.getList();</span>
<span class="fc bfc" id="L833" title="All 2 branches covered.">          for (final Object object : list) {</span>
<span class="fc" id="L834">            addAndSetElementMultiple(ref, value.getXmlPath(),</span>
<span class="fc" id="L835">                                     object.toString());</span>
<span class="fc" id="L836">          }</span>
<span class="fc" id="L837">        } else {</span>
<span class="fc" id="L838">          addOrSetElement(ref, value.getXmlPath(), value.getIntoString());</span>
        }
      }
    }
<span class="fc" id="L842">  }</span>

  /**
   * Write the given XML document to filename using the encoding
   *
   * @param filename
   * @param encoding if null, default encoding UTF-8 will be used
   * @param document
   *
   * @throws IOException
   */
  public static void writeXML(final String filename, final String encoding,
                              final Document document) throws IOException {
<span class="fc" id="L855">    final OutputFormat format = OutputFormat.createPrettyPrint();</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">    if (encoding != null) {</span>
<span class="fc" id="L857">      format.setEncoding(encoding);</span>
    } else {
<span class="fc" id="L859">      format.setEncoding(WaarpStringUtils.UTF8.name());</span>
    }
    final XMLWriter writer;
<span class="fc" id="L862">    writer = new XMLWriter(new FileWriter(filename), format);</span>
<span class="fc" id="L863">    writer.write(document);</span>
    try {
<span class="fc" id="L865">      writer.close();</span>
<span class="nc" id="L866">    } catch (final IOException ignored) {</span>
      // nothing
<span class="fc" id="L868">    }</span>
<span class="fc" id="L869">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>