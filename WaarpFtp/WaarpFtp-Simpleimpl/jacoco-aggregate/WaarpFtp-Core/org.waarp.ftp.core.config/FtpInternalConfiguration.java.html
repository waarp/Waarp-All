<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FtpInternalConfiguration.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Ftp SimpleServer</a> &gt; <a href="../index.html" class="el_bundle">WaarpFtp-Core</a> &gt; <a href="index.source.html" class="el_package">org.waarp.ftp.core.config</a> &gt; <span class="el_source">FtpInternalConfiguration.java</span></div><h1>FtpInternalConfiguration.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.ftp.core.config;

import io.netty.bootstrap.Bootstrap;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.Channel;
import io.netty.channel.ChannelException;
import io.netty.channel.ChannelFuture;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.group.ChannelGroup;
import io.netty.channel.group.DefaultChannelGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.handler.traffic.ChannelTrafficShapingHandler;
import io.netty.handler.traffic.GlobalChannelTrafficShapingHandler;
import io.netty.util.concurrent.EventExecutorGroup;
import org.waarp.common.command.exception.Reply425Exception;
import org.waarp.common.crypto.ssl.WaarpSslUtility;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.DetectionUtils;
import org.waarp.common.utility.WaarpNettyUtil;
import org.waarp.common.utility.WaarpShutdownHook;
import org.waarp.common.utility.WaarpThreadFactory;
import org.waarp.ftp.core.control.FtpInitializer;
import org.waarp.ftp.core.control.ftps.FtpsInitializer;
import org.waarp.ftp.core.data.handler.FtpDataInitializer;
import org.waarp.ftp.core.data.handler.ftps.FtpsDataInitializer;
import org.waarp.ftp.core.exception.FtpNoConnectionException;
import org.waarp.ftp.core.session.FtpSession;
import org.waarp.ftp.core.session.FtpSessionReference;
import org.waarp.ftp.core.utils.FtpChannelUtils;
import org.waarp.ftp.core.utils.FtpShutdownHook;

import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Internal configuration of the FTP server, related to Netty
 */
public class FtpInternalConfiguration {
  // Static values
  /**
   * Internal Logger
   */
<span class="fc" id="L68">  private static final WaarpLogger logger =</span>
<span class="fc" id="L69">      WaarpLoggerFactory.getLogger(FtpInternalConfiguration.class);</span>

  // Network Internals
  /**
   * Time elapse for retry in ms
   */
  public static final long RETRYINMS = 10;

  /**
   * Number of retry before error
   */
  public static final int RETRYNB = 3;

  /**
   * Time elapse for WRITE OR CLOSE WAIT elaps in ms
   */
  public static final long WAITFORNETOP = 1000;
  /**
   * Hack to say Windows or Unix (USR1 not OK on Windows)
   */
  static Boolean isUnix;

  /**
   * Default size for buffers (NIO)
   */
  public static final int BUFFERSIZEDEFAULT = 0x10000; // 64K

  // Dynamic values
  /**
   * List of all Command Channels to enable the close call on them using Netty
   * ChannelGroup
   */
  private ChannelGroup commandChannelGroup;

  /**
   * ExecutorService Worker
   */
  private final EventLoopGroup execWorker;

  /**
   * List of all Data Channels to enable the close call on them using Netty
   * ChannelGroup
   */
  private ChannelGroup dataChannelGroup;

  /**
   * ExecutorService Command Event Loop
   */
  private final EventLoopGroup execCommandEvent;

  /**
   * ExecutorService Data Event Loop
   */
  private final EventLoopGroup execDataEvent;

  /**
   * ExecutorService Data Active Worker
   */
  private final EventLoopGroup execDataWorker;

  /**
   * FtpSession references used by Data Connection process
   */
<span class="fc" id="L132">  private final FtpSessionReference ftpSessionReference =</span>
      new FtpSessionReference();

  /**
   * Bootstrap for Active connections
   */
  private Bootstrap activeBootstrap;

  /**
   * ServerBootStrap for Passive connections
   */
  private ServerBootstrap passiveBootstrap;

  /**
   * Scheduler for TrafficCounter
   */
<span class="fc" id="L148">  private final ScheduledExecutorService executorService = Executors</span>
<span class="fc" id="L149">      .newScheduledThreadPool(2,</span>
                              new WaarpThreadFactory(&quot;TimerTrafficFtp&quot;, false));

  /**
   * Global TrafficCounter (set from global configuration)
   */
  private FtpGlobalTrafficShapingHandler globalTrafficShapingHandler;

  /**
   * Does the FTP will be SSL native based (990 989 port)
   */
  private boolean usingNativeSsl;

  /**
   * Does the FTP accept AUTH and PROT
   */
  private boolean acceptAuthProt;
  /**
   * Bootstrap for Active Ssl connections
   */
  private Bootstrap activeSslBootstrap;

  /**
   * ServerBootStrap for Passive Ssl connections
   */
  private ServerBootstrap passiveSslBootstrap;

  /**
   * org.waarp.ftp.core.config BindAddress
   */
  public static class BindAddress {
    /**
     * Parent passive channel
     */
    public final Channel parent;

    /**
     * Number of binded Data connections
     */
<span class="fc" id="L188">    public final AtomicInteger nbBind = new AtomicInteger();</span>

    /**
     * Constructor
     *
     * @param channel
     */
<span class="fc" id="L195">    public BindAddress(final Channel channel) {</span>
<span class="fc" id="L196">      parent = channel;</span>
<span class="fc" id="L197">      nbBind.set(0);</span>
<span class="fc" id="L198">    }</span>
  }

  /**
   * List of already bind local addresses for Passive connections
   */
<span class="fc" id="L204">  private final ConcurrentHashMap&lt;InetSocketAddress, BindAddress&gt;</span>
      hashBindPassiveDataConn =
      new ConcurrentHashMap&lt;InetSocketAddress, BindAddress&gt;();

  /**
   * Global Configuration
   */
  private final FtpConfiguration configuration;

  /**
   * Constructor
   *
   * @param configuration
   */
<span class="fc" id="L218">  public FtpInternalConfiguration(final FtpConfiguration configuration) {</span>
<span class="fc" id="L219">    this.configuration = configuration;</span>
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">    isUnix = !DetectionUtils.isWindows();</span>
<span class="fc" id="L221">    configuration.getShutdownConfiguration().timeout =</span>
<span class="fc" id="L222">        configuration.getTimeoutCon();</span>
<span class="fc" id="L223">    new FtpShutdownHook(configuration.getShutdownConfiguration(),</span>
                        configuration);
<span class="fc" id="L225">    execCommandEvent = new NioEventLoopGroup(configuration.getClientThread(),</span>
                                             new WaarpThreadFactory(&quot;Command&quot;));
<span class="fc" id="L227">    execDataEvent = new NioEventLoopGroup(configuration.getClientThread(),</span>
                                          new WaarpThreadFactory(&quot;Data&quot;));
<span class="fc" id="L229">    execWorker = new NioEventLoopGroup(configuration.getClientThread(),</span>
                                       new WaarpThreadFactory(&quot;CommandWorker&quot;));
<span class="fc" id="L231">    execDataWorker = new NioEventLoopGroup(configuration.getClientThread() * 2,</span>
                                           new WaarpThreadFactory(
                                               &quot;DataWorker&quot;));
<span class="fc" id="L234">  }</span>

  /**
   * Startup the server
   *
   * @throws FtpNoConnectionException
   */
  public void serverStartup() throws FtpNoConnectionException {
<span class="fc" id="L242">    logger.debug(&quot;Start groups&quot;);</span>
    // Command
<span class="fc" id="L244">    commandChannelGroup =</span>
<span class="fc" id="L245">        new DefaultChannelGroup(configuration.fromClass.getName(),</span>
<span class="fc" id="L246">                                execWorker.next());</span>
    // Data
<span class="fc" id="L248">    dataChannelGroup =</span>
<span class="fc" id="L249">        new DefaultChannelGroup(configuration.fromClass.getName() + &quot;.data&quot;,</span>
<span class="fc" id="L250">                                execWorker.next());</span>

<span class="fc" id="L252">    logger.debug(&quot;Start data connections&quot;);</span>
    // Passive Data Connections
<span class="fc" id="L254">    passiveBootstrap = new ServerBootstrap();</span>
<span class="fc" id="L255">    WaarpNettyUtil.setServerBootstrap(passiveBootstrap, execDataWorker,</span>
<span class="fc" id="L256">                                      (int) configuration.getTimeoutCon(),</span>
<span class="fc" id="L257">                                      configuration.getBlocksize() + 1024,</span>
                                      true);
<span class="fc bfc" id="L259" title="All 2 branches covered.">    if (usingNativeSsl) {</span>
<span class="fc" id="L260">      passiveBootstrap.childHandler(</span>
          new FtpsDataInitializer(configuration.dataBusinessHandler,
                                  configuration, false));
    } else {
<span class="fc" id="L264">      passiveBootstrap.childHandler(</span>
          new FtpDataInitializer(configuration.dataBusinessHandler,
                                 configuration, false));
    }
<span class="fc bfc" id="L268" title="All 2 branches covered.">    if (acceptAuthProt) {</span>
<span class="fc" id="L269">      passiveSslBootstrap = new ServerBootstrap();</span>
<span class="fc" id="L270">      WaarpNettyUtil.setServerBootstrap(passiveSslBootstrap, execDataWorker,</span>
<span class="fc" id="L271">                                        (int) configuration.getTimeoutCon(),</span>
<span class="fc" id="L272">                                        configuration.getBlocksize() + 1024,</span>
                                        true);
<span class="fc" id="L274">      passiveSslBootstrap.childHandler(</span>
          new FtpsDataInitializer(configuration.dataBusinessHandler,
                                  configuration, false));
    } else {
<span class="fc" id="L278">      passiveSslBootstrap = passiveBootstrap;</span>
    }

    // Active Data Connections
<span class="fc" id="L282">    activeBootstrap = new Bootstrap();</span>
<span class="fc" id="L283">    WaarpNettyUtil.setBootstrap(activeBootstrap, execDataWorker,</span>
<span class="fc" id="L284">                                (int) configuration.getTimeoutCon(),</span>
<span class="fc" id="L285">                                configuration.getBlocksize() + 1024, true);</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">    if (usingNativeSsl) {</span>
<span class="fc" id="L287">      activeBootstrap.handler(</span>
          new FtpsDataInitializer(configuration.dataBusinessHandler,
                                  configuration, true));
    } else {
<span class="fc" id="L291">      activeBootstrap.handler(</span>
          new FtpDataInitializer(configuration.dataBusinessHandler,
                                 configuration, true));
    }
<span class="fc bfc" id="L295" title="All 2 branches covered.">    if (acceptAuthProt) {</span>
<span class="fc" id="L296">      activeSslBootstrap = new Bootstrap();</span>
<span class="fc" id="L297">      WaarpNettyUtil.setBootstrap(activeSslBootstrap, execDataWorker,</span>
<span class="fc" id="L298">                                  (int) configuration.getTimeoutCon(),</span>
<span class="fc" id="L299">                                  configuration.getBlocksize() + 1024, true);</span>
<span class="fc" id="L300">      activeSslBootstrap.handler(</span>
          new FtpsDataInitializer(configuration.dataBusinessHandler,
                                  configuration, true));
    } else {
<span class="fc" id="L304">      activeSslBootstrap = activeBootstrap;</span>
    }

<span class="fc" id="L307">    logger.debug(&quot;Start command connections {}&quot;, configuration.getServerPort());</span>
    // Main Command server
    /**
     * Bootstrap for Command server
     */
<span class="fc" id="L312">    final ServerBootstrap serverBootstrap = new ServerBootstrap();</span>
<span class="fc" id="L313">    WaarpNettyUtil.setServerBootstrap(serverBootstrap, execWorker,</span>
<span class="fc" id="L314">                                      (int) configuration.getTimeoutCon(),</span>
<span class="fc" id="L315">                                      configuration.getBlocksize(), true);</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">    if (usingNativeSsl) {</span>
<span class="fc" id="L317">      serverBootstrap.childHandler(</span>
          new FtpsInitializer(configuration.businessHandler, configuration));
    } else {
<span class="fc" id="L320">      serverBootstrap.childHandler(</span>
          new FtpInitializer(configuration.businessHandler, configuration));
    }
<span class="fc" id="L323">    final InetSocketAddress socketAddress =</span>
<span class="fc" id="L324">        new InetSocketAddress(configuration.getServerPort());</span>
<span class="fc" id="L325">    ChannelFuture future = serverBootstrap.bind(socketAddress);</span>
    try {
<span class="fc" id="L327">      future = future.sync();</span>
<span class="nc" id="L328">    } catch (final InterruptedException e) {//NOSONAR</span>
<span class="nc" id="L329">      logger.error(&quot;Cannot start command conections&quot;, e);</span>
<span class="nc" id="L330">      throw new FtpNoConnectionException(&quot;Can't initiate the FTP server&quot;, e);</span>
<span class="fc" id="L331">    }</span>
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">    if (!future.isSuccess()) {</span>
<span class="nc" id="L333">      logger.error(&quot;Cannot start command conections&quot;);</span>
<span class="nc" id="L334">      throw new FtpNoConnectionException(&quot;Can't initiate the FTP server&quot;);</span>
    }
<span class="fc" id="L336">    FtpChannelUtils.addCommandChannel(future.channel(), configuration);</span>

    // Init Shutdown Hook handler
<span class="fc" id="L339">    configuration.getShutdownConfiguration().timeout =</span>
<span class="fc" id="L340">        configuration.getTimeoutCon();</span>
<span class="fc" id="L341">    WaarpShutdownHook.addShutdownHook();</span>
    // Factory for TrafficShapingHandler
<span class="fc" id="L343">    globalTrafficShapingHandler =</span>
        new FtpGlobalTrafficShapingHandler(executorService, configuration
<span class="fc" id="L345">            .getServerGlobalWriteLimit(), configuration</span>
<span class="fc" id="L346">                                               .getServerGlobalReadLimit(),</span>
                                           configuration
<span class="fc" id="L348">                                               .getServerChannelWriteLimit(),</span>
                                           configuration
<span class="fc" id="L350">                                               .getServerChannelReadLimit(),</span>
<span class="fc" id="L351">                                           configuration.getDelayLimit());</span>
<span class="fc" id="L352">  }</span>

  /**
   * @return an ExecutorService
   */
  public ExecutorService getWorker() {
<span class="nc" id="L358">    return execWorker;</span>
  }

  /**
   * Add a session from a couple of addresses
   *
   * @param ipOnly
   * @param fullIp
   * @param session
   */
  public void setNewFtpSession(final InetAddress ipOnly,
                               final InetSocketAddress fullIp,
                               final FtpSession session) {
<span class="fc" id="L371">    ftpSessionReference.setNewFtpSession(ipOnly, fullIp, session);</span>
<span class="fc" id="L372">  }</span>

  /**
   * Return and remove the FtpSession
   *
   * @param channel
   * @param active
   *
   * @return the FtpSession if it exists associated to this channel
   */
  public FtpSession getFtpSession(final Channel channel, final boolean active,
                                  final boolean remove) {
<span class="fc bfc" id="L384" title="All 2 branches covered.">    if (active) {</span>
<span class="fc" id="L385">      return ftpSessionReference.getActiveFtpSession(channel, remove);</span>
    } else {
<span class="fc" id="L387">      return ftpSessionReference.getPassiveFtpSession(channel, remove);</span>
    }
  }

  /**
   * Remove the FtpSession
   *
   * @param ipOnly
   * @param fullIp
   */
  public void delFtpSession(final InetAddress ipOnly,
                            final InetSocketAddress fullIp) {
<span class="fc" id="L399">    ftpSessionReference.delFtpSession(ipOnly, fullIp);</span>
<span class="fc" id="L400">  }</span>

  /**
   * Test if the couple of addresses is already in the context
   *
   * @param ipOnly
   * @param fullIp
   *
   * @return True if the couple is present
   */
  public boolean hasFtpSession(final InetAddress ipOnly,
                               final InetSocketAddress fullIp) {
<span class="fc" id="L412">    return ftpSessionReference.contains(ipOnly, fullIp);</span>
  }

  /**
   * @return the number of Active Sessions
   */
  public int getNumberSessions() {
<span class="nc" id="L419">    return ftpSessionReference.sessionsNumber();</span>
  }

  /**
   * Try to add a Passive Channel listening to the specified local address
   *
   * @param address
   * @param ssl
   *
   * @throws Reply425Exception in case the channel cannot be opened
   */
  public void bindPassive(final InetSocketAddress address, final boolean ssl)
      throws Reply425Exception {
<span class="fc" id="L432">    configuration.bindLock();</span>
    try {
<span class="fc" id="L434">      BindAddress bindAddress = hashBindPassiveDataConn.get(address);</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">      if (bindAddress == null) {</span>
<span class="fc" id="L436">        logger.debug(&quot;Bind really to {}&quot;, address);</span>
        final Channel parentChannel;
        try {
          final ChannelFuture future;
<span class="fc bfc" id="L440" title="All 2 branches covered.">          if (ssl) {</span>
<span class="fc" id="L441">            future = passiveSslBootstrap.bind(address);</span>
          } else {
<span class="fc" id="L443">            future = passiveBootstrap.bind(address);</span>
          }
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">          if (future.await(configuration.getTimeoutCon())) {</span>
<span class="fc" id="L446">            parentChannel = future.sync().channel();</span>
          } else {
<span class="nc" id="L448">            logger.warn(&quot;Cannot open passive connection due to Timeout&quot;);</span>
<span class="nc" id="L449">            throw new Reply425Exception(</span>
                &quot;Cannot open a Passive Connection due to Timeout&quot;);
          }
<span class="nc" id="L452">        } catch (final ChannelException e) {</span>
<span class="nc" id="L453">          logger.warn(&quot;Cannot open passive connection {}&quot;, e.getMessage());</span>
<span class="nc" id="L454">          throw new Reply425Exception(&quot;Cannot open a Passive Connection&quot;);</span>
<span class="nc" id="L455">        } catch (final InterruptedException e) {//NOSONAR</span>
<span class="nc" id="L456">          logger.warn(&quot;Cannot open passive connection {}&quot;, e.getMessage());</span>
<span class="nc" id="L457">          throw new Reply425Exception(&quot;Cannot open a Passive Connection&quot;);</span>
<span class="fc" id="L458">        }</span>
<span class="fc" id="L459">        bindAddress = new BindAddress(parentChannel);</span>
<span class="fc" id="L460">        FtpChannelUtils.addDataChannel(parentChannel, configuration);</span>
<span class="fc" id="L461">        hashBindPassiveDataConn.put(address, bindAddress);</span>
      }
<span class="fc" id="L463">      bindAddress.nbBind.getAndIncrement();</span>
<span class="fc" id="L464">      logger.debug(&quot;Bind number to {} is {}&quot;, address, bindAddress.nbBind);</span>
    } finally {
<span class="fc" id="L466">      configuration.bindUnlock();</span>
    }
<span class="fc" id="L468">  }</span>

  /**
   * Try to unbind (closing the parent channel) the Passive Channel listening
   * to
   * the specified local address if
   * the last one. It returns only when the underlying parent channel is
   * closed
   * if this was the last session
   * that wants to open on this local address.
   *
   * @param address
   */
  public void unbindPassive(final InetSocketAddress address) {
<span class="fc" id="L482">    configuration.bindLock();</span>
    try {
<span class="fc" id="L484">      final BindAddress bindAddress = hashBindPassiveDataConn.get(address);</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">      if (bindAddress != null) {</span>
<span class="fc" id="L486">        bindAddress.nbBind.getAndDecrement();</span>
<span class="fc" id="L487">        logger</span>
<span class="fc" id="L488">            .debug(&quot;Bind number to {} left is {}&quot;, address, bindAddress.nbBind);</span>
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">        if (bindAddress.nbBind.get() == 0) {</span>
<span class="fc" id="L490">          WaarpSslUtility.closingSslChannel(bindAddress.parent);</span>
<span class="fc" id="L491">          hashBindPassiveDataConn.remove(address);</span>
        }
      } else {
<span class="nc" id="L494">        logger.warn(&quot;No Bind to {}&quot;, address);</span>
      }
    } finally {
<span class="fc" id="L497">      configuration.bindUnlock();</span>
    }
<span class="fc" id="L499">  }</span>

  /**
   * @return the number of Binded Passive Connections
   */
  public int getNbBindedPassive() {
<span class="fc" id="L505">    return hashBindPassiveDataConn.size();</span>
  }

  /**
   * Return the associated Executor for Command Event
   *
   * @return the Command Event Executor
   */
  public EventExecutorGroup getExecutor() {
<span class="fc" id="L514">    return execCommandEvent;</span>
  }

  /**
   * Return the associated Executor for Data Event
   *
   * @return the Data Event Executor
   */
  public EventExecutorGroup getDataExecutor() {
<span class="fc" id="L523">    return execDataEvent;</span>
  }

  /**
   * @param ssl
   *
   * @return the ActiveBootstrap
   */
  public Bootstrap getActiveBootstrap(final boolean ssl) {
<span class="fc bfc" id="L532" title="All 2 branches covered.">    if (ssl) {</span>
<span class="fc" id="L533">      return activeSslBootstrap;</span>
    } else {
<span class="fc" id="L535">      return activeBootstrap;</span>
    }
  }

  /**
   * @return the commandChannelGroup
   */
  public ChannelGroup getCommandChannelGroup() {
<span class="fc" id="L543">    return commandChannelGroup;</span>
  }

  /**
   * @return the dataChannelGroup
   */
  public ChannelGroup getDataChannelGroup() {
<span class="fc" id="L550">    return dataChannelGroup;</span>
  }

  /**
   * @return The TrafficCounterFactory
   */
  public FtpGlobalTrafficShapingHandler getGlobalTrafficShapingHandler() {
<span class="fc" id="L557">    return globalTrafficShapingHandler;</span>
  }

  /**
   * @return a new ChannelTrafficShapingHandler
   */
  public ChannelTrafficShapingHandler newChannelTrafficShapingHandler() {
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">    if (configuration.getServerChannelWriteLimit() == 0 &amp;&amp;</span>
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">        configuration.getServerChannelReadLimit() == 0) {</span>
<span class="fc" id="L566">      return null;</span>
    }
<span class="nc bnc" id="L568" title="All 2 branches missed.">    if (globalTrafficShapingHandler instanceof GlobalChannelTrafficShapingHandler) {</span>
<span class="nc" id="L569">      return null;</span>
    }
<span class="nc" id="L571">    return new FtpChannelTrafficShapingHandler(</span>
<span class="nc" id="L572">        configuration.getServerChannelWriteLimit(),</span>
<span class="nc" id="L573">        configuration.getServerChannelReadLimit(),</span>
<span class="nc" id="L574">        configuration.getDelayLimit());</span>
  }

  public void releaseResources() {
<span class="fc" id="L578">    WaarpSslUtility.forceCloseAllSslChannels();</span>
<span class="fc" id="L579">    execWorker.shutdownGracefully();</span>
<span class="fc" id="L580">    execDataWorker.shutdownGracefully();</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">    if (globalTrafficShapingHandler != null) {</span>
<span class="fc" id="L582">      globalTrafficShapingHandler.release();</span>
    }
<span class="fc" id="L584">    executorService.shutdown();</span>
<span class="fc" id="L585">  }</span>

  public boolean isAcceptAuthProt() {
<span class="fc" id="L588">    return acceptAuthProt;</span>
  }

  /**
   * @return the usingNativeSsl
   */
  public boolean isUsingNativeSsl() {
<span class="nc" id="L595">    return usingNativeSsl;</span>
  }

  /**
   * @param usingNativeSsl the usingNativeSsl to set
   */
  public void setUsingNativeSsl(final boolean usingNativeSsl) {
<span class="fc" id="L602">    this.usingNativeSsl = usingNativeSsl;</span>
<span class="fc" id="L603">  }</span>

  /**
   * @param acceptAuthProt the acceptAuthProt to set
   */
  public void setAcceptAuthProt(final boolean acceptAuthProt) {
<span class="fc" id="L609">    this.acceptAuthProt = acceptAuthProt;</span>
<span class="fc" id="L610">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>