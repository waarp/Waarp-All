<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FilesystemBasedDirImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Ftp SimpleServer</a> &gt; <a href="../index.html" class="el_bundle">WaarpCommon</a> &gt; <a href="index.source.html" class="el_package">org.waarp.common.file.filesystembased</a> &gt; <span class="el_source">FilesystemBasedDirImpl.java</span></div><h1>FilesystemBasedDirImpl.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.common.file.filesystembased;

import org.waarp.common.command.exception.CommandAbstractException;
import org.waarp.common.command.exception.Reply550Exception;
import org.waarp.common.command.exception.Reply553Exception;
import org.waarp.common.digest.FilesystemBasedDigest;
import org.waarp.common.digest.FilesystemBasedDigest.DigestAlgo;
import org.waarp.common.file.AbstractDir;
import org.waarp.common.file.FileInterface;
import org.waarp.common.file.FileUtils;
import org.waarp.common.file.OptsMLSxInterface;
import org.waarp.common.file.SessionInterface;
import org.waarp.common.file.filesystembased.specific.FilesystemBasedCommonsIo;
import org.waarp.common.file.filesystembased.specific.FilesystemBasedDirJdk5;
import org.waarp.common.file.filesystembased.specific.FilesystemBasedDirJdk6;
import org.waarp.common.file.filesystembased.specific.FilesystemBasedDirJdkAbstract;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.DetectionUtils;
import org.waarp.common.utility.ParametersChecker;

import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.zip.CRC32;
import java.util.zip.CheckedInputStream;

import static org.waarp.common.file.FileUtils.*;

/**
 * Directory implementation for Filesystem Based
 */
public abstract class FilesystemBasedDirImpl extends AbstractDir {
  private static final String ERROR_WHILE_READING_FILE =
      &quot;Error while reading file: &quot;;

  private static final String DIRECTORY_NOT_FOUND = &quot;Directory not found: &quot;;

  /**
   * Internal Logger
   */
<span class="fc" id="L71">  private static final WaarpLogger logger =</span>
<span class="fc" id="L72">      WaarpLoggerFactory.getLogger(FilesystemBasedDirImpl.class);</span>

  /**
   * Class that handles specifity of one Jdk or another
   */
  protected static FilesystemBasedDirJdkAbstract filesystemBasedFtpDirJdk;

  /*
   * Initialize the filesystem
   */
  static {
<span class="fc" id="L83">    initJdkDependent();</span>
<span class="fc" id="L84">  }</span>

  /**
   * Init according to internals of JDK
   */
  private static void initJdkDependent() {
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">    if (DetectionUtils.javaVersion() &gt;= 6) {</span>
<span class="fc" id="L91">      filesystemBasedFtpDirJdk = new FilesystemBasedDirJdk6();</span>
    } else {
<span class="nc" id="L93">      filesystemBasedFtpDirJdk = new FilesystemBasedDirJdk5();</span>
    }
<span class="fc" id="L95">  }</span>

  /**
   * Init the dependant object according to internals of JDK
   *
   * @param filesystemBasedFtpDirJdkChoice
   *
   * @deprecated replaced by initJdkDependent()
   */
  @Deprecated
  public static void initJdkDependent(
      final FilesystemBasedDirJdkAbstract filesystemBasedFtpDirJdkChoice) {
<span class="nc" id="L107">    filesystemBasedFtpDirJdk = filesystemBasedFtpDirJdkChoice;</span>
<span class="nc" id="L108">  }</span>

  /**
   * @param session
   * @param optsMLSx
   */
  protected FilesystemBasedDirImpl(final SessionInterface session,
<span class="fc" id="L115">                                   final OptsMLSxInterface optsMLSx) {</span>
<span class="fc" id="L116">    this.session = session;</span>
<span class="fc" id="L117">    this.optsMLSx = optsMLSx;</span>
<span class="fc" id="L118">    this.optsMLSx.setOptsModify((byte) 1);</span>
<span class="fc" id="L119">    this.optsMLSx.setOptsPerm((byte) 1);</span>
<span class="fc" id="L120">    this.optsMLSx.setOptsSize((byte) 1);</span>
<span class="fc" id="L121">    this.optsMLSx.setOptsType((byte) 1);</span>
<span class="fc" id="L122">  }</span>

  /**
   * Finds all files matching a wildcard expression (based on '?', '~' or
   * '*').
   *
   * @param pathWithWildcard The wildcard expression with a business
   *     path.
   *
   * @return List of String as relative paths matching the wildcard
   *     expression.
   *     Those files are tested as valid
   *     from business point of view. If Wildcard support is not active,
   *     if the
   *     path contains any wildcards,
   *     it will throw an error.
   *
   * @throws CommandAbstractException
   */
  @Override
  protected final List&lt;String&gt; wildcardFiles(final String pathWithWildcard)
      throws CommandAbstractException {
<span class="fc" id="L144">    final List&lt;String&gt; resultPaths = new ArrayList&lt;String&gt;();</span>
    // First check if pathWithWildcard contains wildcards
<span class="pc bpc" id="L146" title="2 of 4 branches missed.">    if (!(pathWithWildcard.contains(&quot;*&quot;) || pathWithWildcard.contains(&quot;?&quot;) ||</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">          pathWithWildcard.contains(&quot;~&quot;))) {</span>
      // No so simply return the list containing this path after
      // validating it
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">      if (getSession().getAuth().isBusinessPathValid(pathWithWildcard)) {</span>
<span class="fc" id="L151">        resultPaths.add(pathWithWildcard);</span>
      }
<span class="fc" id="L153">      return resultPaths;</span>
    }
    // Do we support Wildcard path
<span class="nc bnc" id="L156" title="All 2 branches missed.">    if (!FilesystemBasedDirJdkAbstract.ueApacheCommonsIo) {</span>
<span class="nc" id="L157">      throw new Reply553Exception(&quot;Wildcards in pathname is not allowed&quot;);</span>
    }
    File wildcardFile;
    final File rootFile;
<span class="nc bnc" id="L161" title="All 4 branches missed.">    if (!ISUNIX &amp;&amp; isAbsolute(pathWithWildcard)) {</span>
<span class="nc" id="L162">      wildcardFile = new File(pathWithWildcard);</span>
<span class="nc" id="L163">      rootFile = getCorrespondingRoot(wildcardFile);</span>
    } else {
<span class="nc bnc" id="L165" title="All 2 branches missed.">      if (isAbsolute(pathWithWildcard)) {</span>
<span class="nc" id="L166">        rootFile = new File(&quot;/&quot;);</span>
      } else {
<span class="nc" id="L168">        rootFile = new File(getSession().getAuth().getBaseDirectory());</span>
      }
<span class="nc" id="L170">      wildcardFile = new File(rootFile, pathWithWildcard);</span>
    }
    // Split wildcard path into subdirectories.
<span class="nc" id="L173">    final List&lt;String&gt; subdirs = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">    while (wildcardFile != null) {</span>
<span class="nc" id="L175">      final File parent = wildcardFile.getParentFile();</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">      if (parent == null) {</span>
<span class="nc" id="L177">        subdirs.add(0, wildcardFile.getPath());</span>
<span class="nc" id="L178">        break;</span>
      }
<span class="nc" id="L180">      subdirs.add(0, wildcardFile.getName());</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">      if (parent.equals(rootFile)) {</span>
        // End of wildcard path
<span class="nc" id="L183">        subdirs.add(0, parent.getPath());</span>
<span class="nc" id="L184">        break;</span>
      }
<span class="nc" id="L186">      wildcardFile = parent;</span>
<span class="nc" id="L187">    }</span>
<span class="nc" id="L188">    List&lt;File&gt; basedPaths = new ArrayList&lt;File&gt;();</span>
    // First set root
<span class="nc" id="L190">    basedPaths.add(new File(subdirs.get(0)));</span>
<span class="nc" id="L191">    int i = 1;</span>
    // For each wilcard subdirectory
<span class="nc bnc" id="L193" title="All 2 branches missed.">    while (i &lt; subdirs.size()) {</span>
      // Set current filter
<span class="nc" id="L195">      final FileFilter fileFilter =</span>
<span class="nc" id="L196">          FilesystemBasedCommonsIo.getWildcardFileFilter(subdirs.get(i));</span>
<span class="nc" id="L197">      final List&lt;File&gt; newBasedPaths = new ArrayList&lt;File&gt;();</span>
      // Look for matches in all the current search paths
<span class="nc bnc" id="L199" title="All 2 branches missed.">      for (final File dir : basedPaths) {</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">        if (dir.isDirectory()) {</span>
<span class="nc" id="L201">          newBasedPaths.addAll(Arrays.asList(dir.listFiles(fileFilter)));</span>
        }
<span class="nc" id="L203">      }</span>
      // base Search Path changes now
<span class="nc" id="L205">      basedPaths = newBasedPaths;</span>
<span class="nc" id="L206">      i++;</span>
<span class="nc" id="L207">    }</span>
    // Valid each file first
<span class="nc bnc" id="L209" title="All 2 branches missed.">    for (final File file : basedPaths) {</span>
<span class="nc" id="L210">      final String relativePath = getSession().getAuth().getRelativePath(</span>
<span class="nc" id="L211">          normalizePath(file.getAbsolutePath()));</span>
<span class="nc" id="L212">      final String newpath = validatePath(relativePath);</span>
<span class="nc" id="L213">      resultPaths.add(newpath);</span>
<span class="nc" id="L214">    }</span>
<span class="nc" id="L215">    return resultPaths;</span>
  }

  /**
   * Get the FileInterface from this path, checking first its validity
   *
   * @param path
   *
   * @return the FileInterface
   *
   * @throws CommandAbstractException
   */
  protected final File getFileFromPath(final String path)
      throws CommandAbstractException {
<span class="fc" id="L229">    final String newdir = validatePath(path);</span>
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">    if (isAbsolute(newdir)) {</span>
<span class="nc" id="L231">      return new File(newdir);</span>
    }
<span class="fc" id="L233">    final String truedir =</span>
<span class="fc" id="L234">        ((FilesystemBasedAuthImpl) getSession().getAuth()).getAbsolutePath(</span>
            newdir);
<span class="fc" id="L236">    return new File(truedir);</span>
  }

  /**
   * Get the true file from the path
   *
   * @param path
   *
   * @return the true File from the path
   *
   * @throws CommandAbstractException
   */
  protected final File getTrueFile(final String path)
      throws CommandAbstractException {
<span class="fc" id="L250">    checkIdentify();</span>
<span class="fc" id="L251">    final String newpath = consolidatePath(path);</span>
<span class="fc" id="L252">    final List&lt;String&gt; paths = wildcardFiles(normalizePath(newpath));</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">    if (paths.size() != 1) {</span>
<span class="nc" id="L254">      throw new Reply550Exception(</span>
<span class="nc" id="L255">          &quot;File not found: &quot; + paths.size() + &quot; founds&quot;);</span>
    }
<span class="fc" id="L257">    String extDir = paths.get(0);</span>
<span class="fc" id="L258">    extDir = validatePath(extDir);</span>
<span class="fc" id="L259">    final File file = getFileFromPath(extDir);</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">    if (!file.isFile()) {</span>
<span class="nc" id="L261">      throw new Reply550Exception(&quot;Path is not a file: &quot; + path);</span>
    }
<span class="fc" id="L263">    return file;</span>
  }

  /**
   * Get the relative path (without mount point)
   *
   * @param file
   *
   * @return the relative path
   */
  protected final String getRelativePath(final File file) {
<span class="nc" id="L274">    return getSession().getAuth()</span>
<span class="nc" id="L275">                       .getRelativePath(normalizePath(file.getAbsolutePath()));</span>
  }

  @Override
  public final boolean changeDirectory(final String path)
      throws CommandAbstractException {
<span class="fc" id="L281">    checkIdentify();</span>
<span class="fc" id="L282">    final String newpath = consolidatePath(path);</span>
<span class="fc" id="L283">    final List&lt;String&gt; paths = wildcardFiles(newpath);</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">    if (paths.size() != 1) {</span>
<span class="nc" id="L285">      logger.warn(&quot;CD error: {}&quot;, newpath);</span>
<span class="nc" id="L286">      throw new Reply550Exception(</span>
<span class="nc" id="L287">          DIRECTORY_NOT_FOUND + paths.size() + &quot; founds&quot;);</span>
    }
<span class="fc" id="L289">    String extDir = paths.get(0);</span>
<span class="fc" id="L290">    extDir = validatePath(extDir);</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">    if (isDirectory(extDir)) {</span>
<span class="fc" id="L292">      currentDir = extDir;</span>
<span class="fc" id="L293">      return true;</span>
    }
<span class="nc" id="L295">    throw new Reply550Exception(DIRECTORY_NOT_FOUND + extDir);</span>
  }

  @Override
  public final boolean changeDirectoryNotChecked(final String path)
      throws CommandAbstractException {
<span class="nc" id="L301">    checkIdentify();</span>
<span class="nc" id="L302">    final String newpath = consolidatePath(path);</span>
<span class="nc" id="L303">    final List&lt;String&gt; paths = wildcardFiles(newpath);</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">    if (paths.size() != 1) {</span>
<span class="nc" id="L305">      logger.warn(&quot;CD error: {}&quot;, newpath);</span>
<span class="nc" id="L306">      throw new Reply550Exception(</span>
<span class="nc" id="L307">          DIRECTORY_NOT_FOUND + paths.size() + &quot; founds&quot;);</span>
    }
<span class="nc" id="L309">    String extDir = paths.get(0);</span>
<span class="nc" id="L310">    extDir = validatePath(extDir);</span>
<span class="nc" id="L311">    currentDir = extDir;</span>
<span class="nc" id="L312">    return true;</span>
  }

  @Override
  public final String mkdir(final String directory)
      throws CommandAbstractException {
<span class="fc" id="L318">    checkIdentify();</span>
<span class="fc" id="L319">    final String newdirectory = consolidatePath(directory);</span>
<span class="fc" id="L320">    final File dir = new File(newdirectory);</span>
<span class="fc" id="L321">    final String parent = dir.getParentFile().getPath();</span>
<span class="fc" id="L322">    final List&lt;String&gt; paths = wildcardFiles(normalizePath(parent));</span>
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">    if (paths.size() != 1) {</span>
<span class="nc" id="L324">      throw new Reply550Exception(</span>
<span class="nc" id="L325">          &quot;Base Directory not found: &quot; + paths.size() + &quot; founds&quot;);</span>
    }
<span class="fc" id="L327">    String newDir = paths.get(0) + SEPARATOR + dir.getName();</span>
<span class="fc" id="L328">    newDir = validatePath(newDir);</span>
<span class="fc" id="L329">    final File newdir = getFileFromPath(newDir);</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">    if (newdir.mkdir()) {</span>
<span class="fc" id="L331">      return newDir;</span>
    }
<span class="fc" id="L333">    throw new Reply550Exception(&quot;Cannot create directory &quot; + newDir);</span>
  }

  @Override
  public final String rmdir(final String directory)
      throws CommandAbstractException {
<span class="fc" id="L339">    checkIdentify();</span>
<span class="fc" id="L340">    final String newdirectory = consolidatePath(directory);</span>
<span class="fc" id="L341">    final List&lt;String&gt; paths = wildcardFiles(normalizePath(newdirectory));</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">    if (paths.size() != 1) {</span>
<span class="nc" id="L343">      throw new Reply550Exception(</span>
<span class="nc" id="L344">          DIRECTORY_NOT_FOUND + paths.size() + &quot; founds&quot;);</span>
    }
<span class="fc" id="L346">    String extDir = paths.get(0);</span>
<span class="fc" id="L347">    extDir = validatePath(extDir);</span>
<span class="fc" id="L348">    final File dir = getFileFromPath(extDir);</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">    if (dir.delete()) {</span>
<span class="fc" id="L350">      return extDir;</span>
    }
<span class="nc" id="L352">    throw new Reply550Exception(&quot;Cannot delete directory &quot; + extDir);</span>
  }

  @Override
  public final boolean isDirectory(final String path)
      throws CommandAbstractException {
<span class="fc" id="L358">    checkIdentify();</span>
<span class="fc" id="L359">    final File dir = getFileFromPath(path);</span>
<span class="fc" id="L360">    return dir.isDirectory();</span>
  }

  @Override
  public final boolean isFile(final String path)
      throws CommandAbstractException {
<span class="fc" id="L366">    checkIdentify();</span>
<span class="fc" id="L367">    return getFileFromPath(path).isFile();</span>
  }

  @Override
  public final String getModificationTime(final String path)
      throws CommandAbstractException {
<span class="fc" id="L373">    checkIdentify();</span>
<span class="fc" id="L374">    final File file = getFileFromPath(path);</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">    if (file.exists()) {</span>
<span class="fc" id="L376">      return getModificationTime(file);</span>
    }
<span class="nc" id="L378">    throw new Reply550Exception('&quot;' + path + &quot;\&quot; does not exist&quot;);</span>
  }

  /**
   * Return the Modification time for the File
   *
   * @param file
   *
   * @return the Modification time as a String YYYYMMDDHHMMSS.sss
   */
  protected final String getModificationTime(final File file) {
<span class="fc" id="L389">    final long mstime = file.lastModified();</span>
<span class="fc" id="L390">    final Calendar calendar = Calendar.getInstance();</span>
<span class="fc" id="L391">    calendar.setTimeInMillis(mstime);</span>
<span class="fc" id="L392">    final int year = calendar.get(Calendar.YEAR);</span>
<span class="fc" id="L393">    final int month = calendar.get(Calendar.MONTH) + 1;</span>
<span class="fc" id="L394">    final int day = calendar.get(Calendar.DAY_OF_MONTH);</span>
<span class="fc" id="L395">    final int hour = calendar.get(Calendar.HOUR_OF_DAY);</span>
<span class="fc" id="L396">    final int minute = calendar.get(Calendar.MINUTE);</span>
<span class="fc" id="L397">    final int second = calendar.get(Calendar.SECOND);</span>
<span class="fc" id="L398">    final int ms = calendar.get(Calendar.MILLISECOND);</span>
<span class="fc" id="L399">    final StringBuilder sb = new StringBuilder(18);</span>
<span class="fc" id="L400">    sb.append(year);</span>
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">    if (month &lt; 10) {</span>
<span class="fc" id="L402">      sb.append(0);</span>
    }
<span class="fc" id="L404">    sb.append(month);</span>
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">    if (day &lt; 10) {</span>
<span class="nc" id="L406">      sb.append(0);</span>
    }
<span class="fc" id="L408">    sb.append(day);</span>
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">    if (hour &lt; 10) {</span>
<span class="nc" id="L410">      sb.append(0);</span>
    }
<span class="fc" id="L412">    sb.append(hour);</span>
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">    if (minute &lt; 10) {</span>
<span class="nc" id="L414">      sb.append(0);</span>
    }
<span class="fc" id="L416">    sb.append(minute);</span>
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">    if (second &lt; 10) {</span>
<span class="nc" id="L418">      sb.append(0);</span>
    }
<span class="fc" id="L420">    sb.append(second).append('.');</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">    if (ms &lt; 10) {</span>
<span class="nc" id="L422">      sb.append(0);</span>
    }
<span class="fc bfc" id="L424" title="All 2 branches covered.">    if (ms &lt; 100) {</span>
<span class="fc" id="L425">      sb.append(0);</span>
    }
<span class="fc" id="L427">    sb.append(ms);</span>
<span class="fc" id="L428">    return sb.toString();</span>
  }

  @Override
  public final List&lt;String&gt; list(final String path)
      throws CommandAbstractException {
<span class="nc" id="L434">    checkIdentify();</span>
    // First get all base directories
<span class="nc" id="L436">    String newpath = path;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">    if (ParametersChecker.isEmpty(newpath)) {</span>
<span class="nc" id="L438">      newpath = currentDir;</span>
    }
<span class="nc bnc" id="L440" title="All 4 branches missed.">    if (newpath.startsWith(&quot;-a&quot;) || newpath.startsWith(&quot;-A&quot;)) {</span>
<span class="nc" id="L441">      final String[] args = newpath.split(&quot; &quot;);</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">      if (args.length &gt; 1) {</span>
<span class="nc" id="L443">        newpath = args[1];</span>
      } else {
<span class="nc" id="L445">        newpath = currentDir;</span>
      }
    }
<span class="nc" id="L448">    newpath = consolidatePath(newpath);</span>
<span class="nc" id="L449">    logger.debug(&quot;debug: {}&quot;, newpath);</span>
<span class="nc" id="L450">    final List&lt;String&gt; paths = wildcardFiles(newpath);</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">    if (paths.isEmpty()) {</span>
<span class="nc" id="L452">      throw new Reply550Exception(&quot;No files found&quot;);</span>
    }
    // Now if they are directories, list inside them
<span class="nc" id="L455">    final List&lt;String&gt; newPaths = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">    for (final String file : paths) {</span>
<span class="nc" id="L457">      final File dir = getFileFromPath(file);</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">      if (dir.exists()) {</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">        if (dir.isDirectory()) {</span>
<span class="nc" id="L460">          final String[] files = dir.list();</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">          for (final String finalFile : files) {</span>
<span class="nc" id="L462">            final String relativePath =</span>
<span class="nc" id="L463">                getSession().getAuth().getRelativePath(finalFile);</span>
<span class="nc" id="L464">            newPaths.add(relativePath);</span>
          }
<span class="nc" id="L466">        } else {</span>
<span class="nc" id="L467">          newPaths.add(file);</span>
        }
      }
<span class="nc" id="L470">    }</span>
<span class="nc" id="L471">    return newPaths;</span>
  }

  @Override
  public final List&lt;String&gt; listFull(final String path, final boolean lsFormat)
      throws CommandAbstractException {
<span class="fc" id="L477">    checkIdentify();</span>
<span class="fc" id="L478">    boolean listAllFiles = false;</span>
<span class="fc" id="L479">    String newpath = path;</span>
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">    if (ParametersChecker.isEmpty(newpath)) {</span>
<span class="nc" id="L481">      newpath = currentDir;</span>
    }
<span class="pc bpc" id="L483" title="2 of 4 branches missed.">    if (newpath.startsWith(&quot;-a&quot;) || newpath.startsWith(&quot;-A&quot;)) {</span>
<span class="nc" id="L484">      final String[] args = newpath.split(&quot; &quot;);</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">      if (args.length &gt; 1) {</span>
<span class="nc" id="L486">        newpath = args[1];</span>
      } else {
<span class="nc" id="L488">        newpath = currentDir;</span>
      }
<span class="nc" id="L490">      listAllFiles = true;</span>
    }
<span class="fc" id="L492">    newpath = consolidatePath(newpath);</span>
    // First get all base directories
<span class="fc" id="L494">    final List&lt;String&gt; paths = wildcardFiles(newpath);</span>
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">    if (paths.isEmpty()) {</span>
<span class="nc" id="L496">      throw new Reply550Exception(&quot;No files found&quot;);</span>
    }
    // Now if they are directories, list inside them
<span class="fc" id="L499">    final List&lt;String&gt; newPaths = new ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">    for (final String file : paths) {</span>
<span class="fc" id="L501">      final File dir = getFileFromPath(file);</span>
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">      if (dir.exists()) {</span>
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">        if (dir.isDirectory()) {</span>
<span class="fc" id="L504">          final File[] files = dir.listFiles();</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">          for (final File finalFile : files) {</span>
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">            if (lsFormat) {</span>
<span class="fc" id="L507">              newPaths.add(lsInfo(finalFile));</span>
            } else {
<span class="nc" id="L509">              newPaths.add(mlsxInfo(finalFile));</span>
            }
          }
<span class="fc" id="L512">        } else {</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">          if (lsFormat) {</span>
<span class="nc" id="L514">            newPaths.add(lsInfo(dir));</span>
          } else {
<span class="nc" id="L516">            newPaths.add(mlsxInfo(dir));</span>
          }
        }
      }
<span class="fc" id="L520">    }</span>
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">    if (listAllFiles) {</span>
<span class="nc" id="L522">      final File dir = new File(getFileFromPath(newpath), SEPARATOR + &quot;..&quot;);</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">      if (lsFormat) {</span>
<span class="nc" id="L524">        newPaths.add(lsInfo(dir));</span>
      } else {
<span class="nc" id="L526">        newPaths.add(mlsxInfo(dir));</span>
      }
    }
<span class="fc" id="L529">    return newPaths;</span>
  }

  @Override
  public final String fileFull(final String path, final boolean lsFormat)
      throws CommandAbstractException {
<span class="nc" id="L535">    checkIdentify();</span>
<span class="nc" id="L536">    final String newpath = consolidatePath(path);</span>
<span class="nc" id="L537">    final List&lt;String&gt; paths = wildcardFiles(normalizePath(newpath));</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">    if (paths.size() != 1) {</span>
<span class="nc" id="L539">      throw new Reply550Exception(&quot;No files found &quot; + paths.size() + &quot; founds&quot;);</span>
    }
<span class="nc" id="L541">    final File file = getFileFromPath(paths.get(0));</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">    if (file.exists()) {</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">      if (lsFormat) {</span>
<span class="nc" id="L544">        return &quot;Listing of \&quot;&quot; + paths.get(0) + &quot;\&quot;\n&quot; + lsInfo(file) +</span>
               &quot;\nEnd of listing&quot;;
      }
<span class="nc" id="L547">      return &quot;Listing of \&quot;&quot; + paths.get(0) + &quot;\&quot;\n&quot; + mlsxInfo(file) +</span>
             &quot;\nEnd of listing&quot;;
    }
<span class="nc" id="L550">    return &quot;No file with name \&quot;&quot; + path + '&quot;';</span>
  }

  /**
   * Decide if Full time or partial time as in 'ls' command
   *
   * @return True if Full Time, False is Default (as in 'ls' command)
   */
  protected final boolean isFullTime() {
<span class="nc" id="L559">    return false;</span>
  }

  /**
   * @param file
   *
   * @return the ls format information
   */
  protected final String lsInfo(final File file) {
    // Unix FileInterface type,permissions,hard
    // link(?),owner(?),group(?),size,date
    // and filename
<span class="fc" id="L571">    final StringBuilder builder =</span>
<span class="pc bpc" id="L572" title="1 of 2 branches missed.">        new StringBuilder().append(file.isDirectory()? 'd' : '-')</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">                           .append(file.canRead()? 'r' : '-')</span>
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">                           .append(file.canWrite()? 'w' : '-');</span>
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">    if (filesystemBasedFtpDirJdk != null) {</span>
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">      builder.append(filesystemBasedFtpDirJdk.canExecute(file)? 'x' : '-');</span>
    } else {
<span class="nc" id="L578">      builder.append('-');</span>
    }
    // Group and others not supported
<span class="fc" id="L581">    builder.append(&quot;---&quot;).append(&quot;---&quot;).append(' ').append(&quot;1 &quot;)// hard link ?</span>
<span class="fc" id="L582">           .append(&quot;anybody\t&quot;)// owner ?</span>
<span class="fc" id="L583">           .append(&quot;anygroup\t&quot;)// group ?</span>
<span class="fc" id="L584">           .append(file.length())// size</span>
<span class="fc" id="L585">           .append('\t');</span>
<span class="fc" id="L586">    final long lastmod = file.lastModified();</span>
    final String fmt;
    // It seems Full Time is not recognized by some FTP client
<span class="fc" id="L589">    final long currentTime = System.currentTimeMillis();</span>
<span class="pc bpc" id="L590" title="2 of 4 branches missed.">    if (currentTime &gt; lastmod + 6L * 30L * 24L * 60L * 60L * 1000L // Old.</span>
        || currentTime &lt; lastmod - 60L * 60L * 1000L) { // In the
      // future.
      // The file is fairly old or in the future.
      // POSIX says the cutoff is 6 months old.
      // approximate this by 6*30 days.
      // Allow a 1 hour slop factor for what is considered &quot;the future&quot;,
      // to allow for NFS server/client clock disagreement.
      // Show the year instead of the time of day.
<span class="nc" id="L599">      fmt = &quot;MMM dd  yyyy&quot;;</span>
    } else {
<span class="fc" id="L601">      fmt = &quot;MMM dd HH:mm&quot;;</span>
    }
<span class="fc" id="L603">    final SimpleDateFormat dateFormat =</span>
<span class="fc" id="L604">        (SimpleDateFormat) DateFormat.getDateTimeInstance(DateFormat.LONG,</span>
                                                          DateFormat.LONG,
                                                          Locale.ENGLISH);
<span class="fc" id="L607">    dateFormat.applyPattern(fmt);</span>
<span class="fc" id="L608">    builder.append(dateFormat.format(new Date(lastmod)))// date</span>
<span class="fc" id="L609">           .append('\t').append(file.getName());</span>
<span class="fc" id="L610">    return builder.toString();</span>
  }

  /**
   * @param file
   *
   * @return the MLSx information: ' Fact=facts;...; filename'
   */
  protected final String mlsxInfo(final File file) {
    // don't have create, unique, lang, media-type, charset
<span class="nc" id="L620">    final StringBuilder builder = new StringBuilder(&quot; &quot;);</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">    if (getOptsMLSx().getOptsSize() == 1) {</span>
<span class="nc" id="L622">      builder.append(&quot;Size=&quot;).append(file.length()).append(';');</span>
    }
<span class="nc bnc" id="L624" title="All 2 branches missed.">    if (getOptsMLSx().getOptsModify() == 1) {</span>
<span class="nc" id="L625">      builder.append(&quot;Modify=&quot;).append(getModificationTime(file)).append(';');</span>
    }
<span class="nc bnc" id="L627" title="All 2 branches missed.">    if (getOptsMLSx().getOptsType() == 1) {</span>
<span class="nc" id="L628">      builder.append(&quot;Type=&quot;);</span>
      try {
<span class="nc bnc" id="L630" title="All 2 branches missed.">        if (getFileFromPath(currentDir).equals(file)) {</span>
<span class="nc" id="L631">          builder.append(&quot;cdir&quot;);</span>
        } else {
<span class="nc bnc" id="L633" title="All 2 branches missed.">          if (file.isDirectory()) {</span>
<span class="nc" id="L634">            builder.append(&quot;dir&quot;);</span>
          } else {
<span class="nc" id="L636">            builder.append(&quot;file&quot;);</span>
          }
        }
<span class="nc" id="L639">      } catch (final CommandAbstractException e) {</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">        if (file.isDirectory()) {</span>
<span class="nc" id="L641">          builder.append(&quot;dir&quot;);</span>
        } else {
<span class="nc" id="L643">          builder.append(&quot;file&quot;);</span>
        }
<span class="nc" id="L645">      }</span>
<span class="nc" id="L646">      builder.append(';');</span>
    }
<span class="nc bnc" id="L648" title="All 2 branches missed.">    if (getOptsMLSx().getOptsPerm() == 1) {</span>
<span class="nc" id="L649">      builder.append(&quot;Perm=&quot;);</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">      if (file.isFile()) {</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">        if (file.canWrite()) {</span>
<span class="nc" id="L652">          builder.append('a').append('d').append('f').append('w');</span>
        }
<span class="nc bnc" id="L654" title="All 2 branches missed.">        if (file.canRead()) {</span>
<span class="nc" id="L655">          builder.append('r');</span>
        }
      } else {
        // Directory
<span class="nc bnc" id="L659" title="All 2 branches missed.">        if (file.canWrite()) {</span>
<span class="nc" id="L660">          builder.append('c');</span>
          try {
<span class="nc bnc" id="L662" title="All 2 branches missed.">            if (validatePath(file) != null) {</span>
<span class="nc" id="L663">              builder.append('d').append('m').append('p');</span>
            }
<span class="nc" id="L665">          } catch (final CommandAbstractException ignored) {</span>
            // nothing
<span class="nc" id="L667">          }</span>
        }
<span class="nc bnc" id="L669" title="All 2 branches missed.">        if (file.canRead()) {</span>
<span class="nc" id="L670">          builder.append('l').append('e');</span>
        }
      }
<span class="nc" id="L673">      builder.append(';');</span>
    }

<span class="nc" id="L676">    builder.append(' ').append(file.getName());</span>
<span class="nc" id="L677">    return builder.toString();</span>
  }

  @Override
  public final long getFreeSpace() throws CommandAbstractException {
<span class="fc" id="L682">    checkIdentify();</span>
<span class="fc" id="L683">    final File directory = getFileFromPath(currentDir);</span>
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">    if (filesystemBasedFtpDirJdk != null) {</span>
<span class="fc" id="L685">      return filesystemBasedFtpDirJdk.getFreeSpace(directory);</span>
    } else {
<span class="nc" id="L687">      return Integer.MAX_VALUE;</span>
    }
  }

  @Override
  public FileInterface setUniqueFile() throws CommandAbstractException {
<span class="nc" id="L693">    checkIdentify();</span>
    final File file;
    try {
<span class="nc" id="L696">      file = File.createTempFile(getSession().getAuth().getUser(),</span>
<span class="nc" id="L697">                                 session.getUniqueExtension(),</span>
<span class="nc" id="L698">                                 getFileFromPath(currentDir));</span>
<span class="nc" id="L699">    } catch (final IOException e) {</span>
<span class="nc" id="L700">      throw new Reply550Exception(&quot;Cannot create unique file&quot;);</span>
<span class="nc" id="L701">    }</span>
<span class="nc" id="L702">    final String currentFile = getRelativePath(file);</span>
<span class="nc" id="L703">    return newFile(normalizePath(currentFile), false);</span>
  }

  @Override
  public final boolean canRead() throws CommandAbstractException {
<span class="nc" id="L708">    checkIdentify();</span>
<span class="nc" id="L709">    return getFileFromPath(currentDir).canRead();</span>
  }

  @Override
  public final boolean canWrite() throws CommandAbstractException {
<span class="nc" id="L714">    checkIdentify();</span>
<span class="nc" id="L715">    final File file = getFileFromPath(currentDir);</span>
<span class="nc" id="L716">    return file.canWrite();</span>
  }

  @Override
  public final boolean exists() throws CommandAbstractException {
<span class="nc" id="L721">    checkIdentify();</span>
<span class="nc" id="L722">    return getFileFromPath(currentDir).exists();</span>
  }

  @Override
  public final long getCRC(final String path) throws CommandAbstractException {
<span class="fc" id="L727">    final File file = getTrueFile(path);</span>
<span class="fc" id="L728">    FileInputStream fis = null;</span>
<span class="fc" id="L729">    CheckedInputStream cis = null;</span>
    try {
      try {
        // Computer CRC32 checksum
<span class="fc" id="L733">        fis = new FileInputStream(file);</span>
<span class="fc" id="L734">        cis = new CheckedInputStream(fis, new CRC32());</span>
<span class="nc" id="L735">      } catch (final FileNotFoundException e) {</span>
<span class="nc" id="L736">        throw new Reply550Exception(&quot;File not found: &quot; + path);</span>
<span class="fc" id="L737">      }</span>
<span class="fc" id="L738">      final byte[] buf = new byte[ZERO_COPY_CHUNK_SIZE];</span>
<span class="fc bfc" id="L739" title="All 2 branches covered.">      while (cis.read(buf) &gt;= 0) {</span>
        // nothing
      }
<span class="fc" id="L742">      return cis.getChecksum().getValue();</span>
<span class="nc" id="L743">    } catch (final IOException e) {</span>
<span class="nc" id="L744">      throw new Reply550Exception(ERROR_WHILE_READING_FILE + path);</span>
    } finally {
<span class="fc" id="L746">      FileUtils.close(cis);</span>
<span class="fc" id="L747">      FileUtils.close(fis);</span>
    }
  }

  @Override
  public final byte[] getMD5(final String path)
      throws CommandAbstractException {
<span class="fc" id="L754">    return getDigest(path, DigestAlgo.MD5.name());</span>
  }

  @Override
  public final byte[] getSHA1(final String path)
      throws CommandAbstractException {
<span class="fc" id="L760">    return getDigest(path, DigestAlgo.SHA1.name());</span>
  }

  @Override
  public final byte[] getDigest(final String path, final String algo)
      throws CommandAbstractException {
    final DigestAlgo digestAlgo;
    try {
<span class="fc" id="L768">      digestAlgo = DigestAlgo.getFromName(algo);</span>
<span class="nc" id="L769">    } catch (final IllegalArgumentException e) {</span>
<span class="nc" id="L770">      throw new Reply553Exception(&quot;Algorithme unknown: &quot; + algo);</span>
<span class="fc" id="L771">    }</span>
<span class="fc" id="L772">    final File file = getTrueFile(path);</span>
    try {
<span class="fc" id="L774">      return FilesystemBasedDigest.getHash(file,</span>
                                           FilesystemBasedFileParameterImpl.useNio,
                                           digestAlgo);
<span class="nc" id="L777">    } catch (final IOException e1) {</span>
<span class="nc" id="L778">      throw new Reply550Exception(ERROR_WHILE_READING_FILE + path);</span>
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>