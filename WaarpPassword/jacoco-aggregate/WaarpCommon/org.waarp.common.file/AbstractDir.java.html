<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractDir.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Password Management GUI and Console</a> &gt; <a href="../index.html" class="el_bundle">WaarpCommon</a> &gt; <a href="index.source.html" class="el_package">org.waarp.common.file</a> &gt; <span class="el_source">AbstractDir.java</span></div><h1>AbstractDir.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.common.file;

import org.waarp.common.command.exception.CommandAbstractException;
import org.waarp.common.command.exception.Reply501Exception;
import org.waarp.common.command.exception.Reply530Exception;
import org.waarp.common.command.exception.Reply550Exception;
import org.waarp.common.command.exception.Reply553Exception;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.DetectionUtils;
import org.waarp.common.utility.WaarpStringUtils;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.List;

/**
 * Abstract Main Implementation of Directory
 */
<span class="nc" id="L42">public abstract class AbstractDir implements DirInterface {</span>
  /**
   * Internal Logger
   */
<span class="fc" id="L46">  private static final WaarpLogger logger =</span>
<span class="fc" id="L47">      WaarpLoggerFactory.getLogger(AbstractDir.class);</span>
  /**
   * Current Directory
   */
  protected String currentDir;
  /**
   * SessionInterface
   */
  protected SessionInterface session;

  /**
   * Opts command for MLSx. (-1) means not supported, 0 supported but not
   * active, 1 supported and active
   */
  protected OptsMLSxInterface optsMLSx;
  /**
   * Hack to say Windows or Unix (root like X:\ or /)
   */
  protected static final boolean ISUNIX;
  /**
   * Roots for Windows system
   */
  protected static final File[] roots;

  /**
   * Init Windows Support
   */
  static {
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">    ISUNIX = !DetectionUtils.isWindows();</span>
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">    if (!ISUNIX) {</span>
<span class="nc" id="L77">      roots = File.listRoots();</span>
    } else {
<span class="fc" id="L79">      roots = new File[] { new File(&quot;/&quot;) };</span>
    }
<span class="fc" id="L81">  }</span>

  /**
   * @param file
   *
   * @return The corresponding Root file
   */
  protected File getCorrespondingRoot(final File file) {
<span class="nc bnc" id="L89" title="All 2 branches missed.">    if (ISUNIX) {</span>
<span class="nc" id="L90">      return new File(&quot;/&quot;);</span>
    }
<span class="nc" id="L92">    final String path = file.getAbsolutePath();</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">    for (final File root : roots) {</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">      if (path.startsWith(root.getAbsolutePath())) {</span>
<span class="nc" id="L95">        return root;</span>
      }
    }
    // hack !
<span class="nc" id="L99">    logger.warn(&quot;No root found for &quot; + file.getAbsolutePath());</span>
<span class="nc" id="L100">    return roots[0];</span>
  }

  /**
   * Normalize Path to Internal unique representation
   *
   * @param path
   *
   * @return the normalized path
   */
  public static String normalizePath(final String path) {
<span class="fc" id="L111">    return path.replace('\\', SEPARATORCHAR);</span>
  }

  /**
   * Convert the URI representation of a file path to a simple path.
   * &lt;p&gt;
   * If the path is not an URI, this method does nothing.
   *
   * @param path
   *
   * @return the normalized path
   */
  public static String pathFromURI(String path) {

<span class="fc bfc" id="L125" title="All 2 branches covered.">    if (path.startsWith(&quot;file://&quot;)) {</span>
<span class="fc" id="L126">      int charToRemove = 7;</span>

<span class="fc bfc" id="L128" title="All 4 branches covered.">      if (path.charAt(7) == '/' &amp;&amp; path.charAt(9) == ':') {</span>
<span class="fc" id="L129">        charToRemove++;</span>
      }

<span class="fc" id="L132">      path = path.substring(charToRemove);</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">      if (path.contains(&quot;%&quot;)) {</span>
        try {
<span class="fc" id="L135">          path = URLDecoder.decode(path, WaarpStringUtils.UTF8.name());</span>
<span class="nc" id="L136">        } catch (final UnsupportedEncodingException e) {</span>
<span class="nc" id="L137">          logger.warn(&quot;Cannot convert filename to UTF-8: &quot; + path);</span>
<span class="fc" id="L138">        } catch (final IllegalArgumentException e) {</span>
          // ignore: it was propably not url-encoded!
<span class="pc" id="L140">        }</span>
      }
    }
<span class="fc" id="L143">    return path;</span>
  }

  /**
   * @return the SessionInterface
   */
  @Override
  public SessionInterface getSession() {
<span class="nc" id="L151">    return session;</span>
  }

  @Override
  public String validatePath(final String path)
      throws CommandAbstractException {
    String extDir;
<span class="nc bnc" id="L158" title="All 2 branches missed.">    if (isAbsolute(path)) {</span>
<span class="nc" id="L159">      extDir = path;</span>
<span class="nc" id="L160">      final File newDir = new File(extDir);</span>
      try {
<span class="nc" id="L162">        return validatePath(newDir);</span>
<span class="nc" id="L163">      } catch (final Reply553Exception e) {</span>
        // ignore and continue as it could be not absolute
      }
    }
<span class="nc bnc" id="L167" title="All 2 branches missed.">    if (path.charAt(0) == SEPARATORCHAR) {</span>
<span class="nc" id="L168">      extDir = path;</span>
    } else {
<span class="nc" id="L170">      extDir = currentDir + SEPARATOR + path;</span>
    }
    // Get the baseDir (mount point)
<span class="nc" id="L173">    final String baseDir = getSession().getAuth().getBaseDirectory();</span>
    // Get the translated real file path (removing '..')
<span class="nc" id="L175">    final File newDir = new File(baseDir, extDir);</span>
<span class="nc" id="L176">    return validatePath(newDir);</span>
  }

  /**
   * @param path
   *
   * @return True if the given Path is an absolute one under Windows System or
   *     should be an absolute one on Unix
   */
  public boolean isAbsolute(final String path) {
<span class="nc" id="L186">    File file = new File(path);</span>
<span class="nc" id="L187">    logger.trace(</span>
<span class="nc" id="L188">        &quot;isAbsolute: &quot; + file + ':' + ISUNIX + ':' + file.isAbsolute() + ':' +</span>
<span class="nc" id="L189">        file.getParentFile());</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">    if (!ISUNIX) {</span>
<span class="nc" id="L191">      return file.isAbsolute();</span>
    } else {
<span class="nc" id="L193">      file = file.getParentFile();</span>
<span class="nc bnc" id="L194" title="All 6 branches missed.">      return file != null &amp;&amp; file.isAbsolute() &amp;&amp; file.isDirectory() &amp;&amp;</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">             !file.getAbsolutePath().equals(File.separator);</span>
    }
  }

  /**
   * Consolidate Path as relative or absolute path to an absolute path
   *
   * @param path
   *
   * @return the consolidated path
   *
   * @throws CommandAbstractException
   */
  protected String consolidatePath(final String path)
      throws CommandAbstractException {
<span class="nc bnc" id="L210" title="All 4 branches missed.">    if (path == null || path.isEmpty()) {</span>
<span class="nc" id="L211">      throw new Reply501Exception(&quot;Path must not be empty&quot;);</span>
    }
    // First check if the path is relative or absolute
<span class="nc bnc" id="L214" title="All 2 branches missed.">    if (isAbsolute(path)) {</span>
<span class="nc" id="L215">      return normalizePath(path);</span>
    }
<span class="nc" id="L217">    String extDir = normalizePath(path);</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">    if (extDir.charAt(0) != SEPARATORCHAR) {</span>
<span class="nc" id="L219">      extDir = currentDir + SEPARATOR + extDir;</span>
    }
<span class="nc" id="L221">    return extDir;</span>
  }

  /**
   * Construct the CanonicalPath without taking into account symbolic link
   *
   * @param dir
   *
   * @return the canonicalPath
   */
  protected String getCanonicalPath(final File dir) {
<span class="nc bnc" id="L232" title="All 2 branches missed.">    if (ISUNIX) {</span>
      // resolve it without getting symbolic links
<span class="nc" id="L234">      final StringBuilder builder = new StringBuilder();</span>
      // Get the path in reverse order from end to start
<span class="nc" id="L236">      final List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L237">      File newdir = dir;</span>
<span class="nc" id="L238">      String lastdir = newdir.getName();</span>
<span class="nc" id="L239">      list.add(lastdir);</span>
<span class="nc" id="L240">      File parent = newdir.getParentFile();</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">      while (parent != null) {</span>
<span class="nc" id="L242">        newdir = parent;</span>
<span class="nc" id="L243">        lastdir = newdir.getName();</span>
<span class="nc" id="L244">        list.add(lastdir);</span>
<span class="nc" id="L245">        parent = newdir.getParentFile();</span>
      }
      // Now filter on '..' or '.'
<span class="nc bnc" id="L248" title="All 2 branches missed.">      for (int i = list.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L249">        final String curdir = list.get(i);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (&quot;.&quot;.equals(curdir)) {</span>
<span class="nc" id="L251">          list.remove(i);// removes '.'</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">        } else if (&quot;..&quot;.equals(curdir)) {</span>
<span class="nc" id="L253">          list.remove(i);// removes '..'</span>
<span class="nc" id="L254">          final int len = list.size();</span>
<span class="nc bnc" id="L255" title="All 4 branches missed.">          if (len &gt; 0 &amp;&amp; i &lt; len) {</span>
<span class="nc" id="L256">            list.remove(i);// and removes parent dir</span>
          }
        }
      }
<span class="nc bnc" id="L260" title="All 2 branches missed.">      if (list.isEmpty()) {</span>
<span class="nc" id="L261">        return &quot;/&quot;;</span>
      }

<span class="nc bnc" id="L264" title="All 2 branches missed.">      for (int i = list.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L265">        builder.append('/').append(list.get(i));</span>
      }
<span class="nc" id="L267">      return builder.toString();</span>
    }
    // Windows version
    // no link so just use the default version of canonical Path
    try {
<span class="nc" id="L272">      return dir.getCanonicalPath();</span>
<span class="nc" id="L273">    } catch (final IOException e) {</span>
<span class="nc" id="L274">      return dir.getAbsolutePath();</span>
    }
  }

  /**
   * Same as validatePath but from a FileInterface
   *
   * @param dir
   *
   * @return the construct and validated path (could be different than the one
   *     given as argument, example: '..'
   *     are removed)
   *
   * @throws CommandAbstractException
   */
  protected String validatePath(final File dir)
      throws CommandAbstractException {
    String extDir;
<span class="nc" id="L292">    extDir = normalizePath(getCanonicalPath(dir));</span>
    // Get the relative business path
<span class="nc" id="L294">    extDir = getSession().getAuth().getRelativePath(extDir);</span>
    // Check if this business path is valid
<span class="nc bnc" id="L296" title="All 2 branches missed.">    if (getSession().getAuth().isBusinessPathValid(extDir)) {</span>
<span class="nc" id="L297">      logger.trace(&quot;final path: &quot; + extDir);</span>
<span class="nc" id="L298">      return extDir;</span>
    }
<span class="nc" id="L300">    throw new Reply553Exception(&quot;Pathname not allowed&quot;);</span>
  }

  @Override
  public boolean isPathInCurrentDir(final String path) {
    final String extDir;
<span class="nc bnc" id="L306" title="All 2 branches missed.">    if (isAbsolute(path)) {</span>
<span class="nc" id="L307">      extDir = path;</span>
<span class="nc" id="L308">      final File newDir = new File(extDir);</span>
<span class="nc" id="L309">      return isPathInCurrentDir(newDir);</span>
    }
<span class="nc bnc" id="L311" title="All 2 branches missed.">    if (path.charAt(0) == SEPARATORCHAR) {</span>
<span class="nc" id="L312">      extDir = path;</span>
    } else {
<span class="nc" id="L314">      extDir = currentDir + SEPARATOR + path;</span>
    }
    // Get the baseDir (mount point)
<span class="nc" id="L317">    final String baseDir = getSession().getAuth().getBaseDirectory();</span>
    // Get the translated real file path (removing '..')
<span class="nc" id="L319">    final File newDir = new File(baseDir, extDir);</span>
<span class="nc" id="L320">    return isPathInCurrentDir(newDir);</span>
  }

  /**
   * Validate a file according to the current Directory
   *
   * @param dir
   *
   * @return True if validated
   *
   * @throws CommandAbstractException
   */
  protected boolean isPathInCurrentDir(final File dir) {
    String extDir;
<span class="nc" id="L334">    extDir = normalizePath(getCanonicalPath(dir));</span>
    // Get the relative business path
<span class="nc" id="L336">    extDir = getSession().getAuth().getRelativePath(extDir);</span>
    // Check if this business path is valid
<span class="nc bnc" id="L338" title="All 2 branches missed.">    if (extDir.startsWith(currentDir)) {</span>
<span class="nc" id="L339">      return true;</span>
    }
<span class="nc" id="L341">    logger.warn(&quot;File not OK: {} not in {}&quot;, extDir, currentDir);</span>
<span class="nc" id="L342">    return false;</span>
  }

  /**
   * Finds all files matching a wildcard expression (based on '?', '~' or
   * '*').
   *
   * @param pathWithWildcard The wildcard expression with a business
   *     path.
   *
   * @return List of String as relative paths matching the wildcard
   *     expression.
   *     Those files are tested as valid
   *     from business point of view. If Wildcard support is not active,
   *     if the
   *     path contains any wildcards,
   *     it will throw an error.
   *
   * @throws CommandAbstractException
   */
  protected abstract List&lt;String&gt; wildcardFiles(String pathWithWildcard)
      throws CommandAbstractException;

  @Override
  public String getPwd() throws CommandAbstractException {
<span class="nc" id="L367">    return currentDir;</span>
  }

  @Override
  public boolean changeParentDirectory() throws CommandAbstractException {
<span class="nc" id="L372">    return changeDirectory(&quot;..&quot;);</span>
  }

  @Override
  public FileInterface setFile(final String path, final boolean append)
      throws CommandAbstractException {
<span class="nc" id="L378">    checkIdentify();</span>
<span class="nc" id="L379">    final String newpath = consolidatePath(path);</span>
<span class="nc" id="L380">    final List&lt;String&gt; paths = wildcardFiles(newpath);</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">    if (paths.size() != 1) {</span>
<span class="nc" id="L382">      throw new Reply550Exception(</span>
<span class="nc" id="L383">          &quot;File not found: &quot; + paths.size() + &quot; founds&quot;);</span>
    }
<span class="nc" id="L385">    final String extDir = paths.get(0);</span>
<span class="nc" id="L386">    return newFile(extDir, append);</span>
  }

  @Override
  public void checkIdentify() throws Reply530Exception {
<span class="nc bnc" id="L391" title="All 2 branches missed.">    if (!getSession().getAuth().isIdentified()) {</span>
<span class="nc" id="L392">      throw new Reply530Exception(&quot;User not authentified&quot;);</span>
    }
<span class="nc" id="L394">  }</span>

  @Override
  public void clear() {
<span class="nc" id="L398">    currentDir = null;</span>
<span class="nc" id="L399">  }</span>

  @Override
  public void initAfterIdentification() {
<span class="nc" id="L403">    currentDir = getSession().getAuth().getBusinessPath();</span>
<span class="nc" id="L404">  }</span>

  @Override
  public OptsMLSxInterface getOptsMLSx() {
<span class="nc" id="L408">    return optsMLSx;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>