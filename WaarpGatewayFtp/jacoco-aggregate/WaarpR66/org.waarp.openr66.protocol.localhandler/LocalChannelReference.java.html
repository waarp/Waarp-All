<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>LocalChannelReference.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Gateway Ftp</a> &gt; <a href="../index.html" class="el_bundle">WaarpR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.protocol.localhandler</a> &gt; <span class="el_source">LocalChannelReference.java</span></div><h1>LocalChannelReference.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.openr66.protocol.localhandler;

import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.traffic.ChannelTrafficShapingHandler;
import org.waarp.common.database.DbSession;
import org.waarp.common.guid.IntegerUuid;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.openr66.client.RecvThroughHandler;
import org.waarp.openr66.commander.ClientRunner;
import org.waarp.openr66.context.ErrorCode;
import org.waarp.openr66.context.R66FiniteDualStates;
import org.waarp.openr66.context.R66Result;
import org.waarp.openr66.context.R66Session;
import org.waarp.openr66.context.task.exception.OpenR66RunnerErrorException;
import org.waarp.openr66.database.data.DbTaskRunner;
import org.waarp.openr66.protocol.configuration.Configuration;
import org.waarp.openr66.protocol.configuration.PartnerConfiguration;
import org.waarp.openr66.protocol.exception.OpenR66Exception;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNoConnectionException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolRemoteShutdownException;
import org.waarp.openr66.protocol.networkhandler.NetworkChannelReference;
import org.waarp.openr66.protocol.networkhandler.NetworkServerHandler;
import org.waarp.openr66.protocol.networkhandler.NetworkServerInitializer;
import org.waarp.openr66.protocol.networkhandler.NetworkTransaction;
import org.waarp.openr66.protocol.utils.R66Future;
import org.waarp.openr66.protocol.utils.R66Versions;

import static org.waarp.common.database.DbConstant.*;

/**
 * Reference of one object using Local Channel localId and containing local
 * channel and network channel.
 */
public class LocalChannelReference {
  /**
   * Internal Logger
   */
<span class="fc" id="L59">  private static final WaarpLogger logger =</span>
<span class="fc" id="L60">      WaarpLoggerFactory.getLogger(LocalChannelReference.class);</span>

  /**
   * Network Channel Ref
   */
  private final NetworkChannelReference networkChannelRef;
  /**
   * Traffic handler associated if any
   */
  private final ChannelTrafficShapingHandler cts;

  /**
   * Network Server Handler
   */
  private final NetworkServerHandler networkServerHandler;

  /**
   * Server Actions handler
   */
<span class="fc" id="L79">  private final TransferActions serverHandler = new TransferActions();</span>

  /**
   * Local Id
   */
  private final Integer localId;

  /**
   * Remote Id
   */
  private Integer remoteId;

  /**
   * Requested_requester_specialId
   */
  private String requestId;
  /**
   * Future on Global Request
   */
  private final R66Future futureRequest;

  /**
   * Future on Valid Starting Request
   */
<span class="fc" id="L103">  private final R66Future futureValidRequest = new R66Future(true);</span>

  /**
   * Future on Transfer if any
   */
<span class="fc" id="L108">  private R66Future futureEndTransfer = new R66Future(true);</span>

  /**
   * Future on Connection
   */
<span class="fc" id="L113">  private final R66Future futureConnection = new R66Future(true);</span>

  /**
   * Future on Startup
   */
<span class="fc" id="L118">  private final R66Future futureStartup = new R66Future(true);</span>

  /**
   * Session
   */
  private R66Session session;

  /**
   * Last error message
   */
<span class="fc" id="L128">  private String errorMessage = &quot;NoError&quot;;</span>

  /**
   * Last error code
   */
<span class="fc" id="L133">  private ErrorCode code = ErrorCode.Unknown;</span>

  /**
   * RecvThroughHandler
   */
  private RecvThroughHandler recvThroughHandler;

  private boolean isSendThroughMode;
  /**
   * Thread for ClientRunner if any
   */
  private ClientRunner clientRunner;

  /**
   * To be able to check hash once all transfer is over once again
   */
  private String hashComputeDuringTransfer;
  /**
   * If partial hash, no global hash validation can be done
   */
  private boolean partialHash;

  /**
   * PartnerConfiguration
   */
  private volatile PartnerConfiguration partner;

  /**
   * @param networkChannelRef
   * @param remoteId
   * @param futureRequest
   *
   * @throws OpenR66ProtocolRemoteShutdownException
   */
  public LocalChannelReference(final NetworkChannelReference networkChannelRef,
                               final Integer remoteId,
                               final R66Future futureRequest)
<span class="fc" id="L170">      throws OpenR66ProtocolRemoteShutdownException {</span>
<span class="fc" id="L171">    this.networkChannelRef = networkChannelRef;</span>
<span class="fc" id="L172">    networkServerHandler =</span>
<span class="fc" id="L173">        (NetworkServerHandler) this.networkChannelRef.channel().pipeline().get(</span>
            NetworkServerInitializer.NETWORK_HANDLER);
<span class="fc" id="L175">    localId = new IntegerUuid().getInt();</span>
<span class="fc" id="L176">    this.remoteId = remoteId;</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">    if (futureRequest == null) {</span>
<span class="fc" id="L178">      this.futureRequest = new R66Future(true);</span>
    } else {
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">      if (futureRequest.isDone()) {</span>
<span class="nc" id="L181">        futureRequest.reset();</span>
      }
<span class="fc" id="L183">      this.futureRequest = futureRequest;</span>
    }
<span class="fc" id="L185">    cts = (ChannelTrafficShapingHandler) networkChannelRef.channel().pipeline()</span>
<span class="fc" id="L186">                                                          .get(</span>
                                                              NetworkServerInitializer.LIMITCHANNEL);
<span class="fc" id="L188">    LocalServerHandler.channelActive(serverHandler);</span>
<span class="fc" id="L189">    serverHandler.setLocalChannelReference(this);</span>
<span class="fc" id="L190">    networkChannelRef.add(this);</span>
<span class="fc" id="L191">  }</span>

  /**
   * Special empty LCR constructor
   */
<span class="fc" id="L196">  public LocalChannelReference() {</span>
<span class="fc" id="L197">    networkChannelRef = null;</span>
<span class="fc" id="L198">    networkServerHandler = null;</span>
<span class="fc" id="L199">    localId = 0;</span>
<span class="fc" id="L200">    futureRequest = new R66Future(true);</span>
<span class="fc" id="L201">    cts = null;</span>
<span class="fc" id="L202">    serverHandler.localChannelReference = this;</span>
<span class="fc" id="L203">  }</span>

  /**
   * Close the localChannelReference
   */
  public void close() {
<span class="fc" id="L209">    LocalServerHandler.channelInactive(serverHandler);</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">    if (networkChannelRef != null) {</span>
<span class="fc" id="L211">      networkChannelRef.remove(this);</span>
    }
<span class="fc" id="L213">    final LocalTransaction lt =</span>
<span class="fc" id="L214">        Configuration.configuration.getLocalTransaction();</span>
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">    if (lt != null) {</span>
<span class="fc" id="L216">      lt.remove(this);</span>
    }
<span class="fc" id="L218">  }</span>

  /**
   * @return the networkChannelRef
   */
  public Channel getNetworkChannel() {
<span class="fc" id="L224">    return networkChannelRef.channel();</span>
  }

  /**
   * @return the id
   */
  public Integer getLocalId() {
<span class="fc" id="L231">    return localId;</span>
  }

  /**
   * @return the remoteId
   */
  public Integer getRemoteId() {
<span class="fc" id="L238">    return remoteId;</span>
  }

  /**
   * @return the ChannelTrafficShapingHandler
   */
  public ChannelTrafficShapingHandler getChannelTrafficShapingHandler() {
<span class="nc" id="L245">    return cts;</span>
  }

  /**
   * @return the networkChannelObject
   */
  public NetworkChannelReference getNetworkChannelObject() {
<span class="fc" id="L252">    return networkChannelRef;</span>
  }

  /**
   * @return the networkServerHandler
   */
  public NetworkServerHandler getNetworkServerHandler() {
<span class="fc" id="L259">    return networkServerHandler;</span>
  }

  /**
   * @return the serverHandler
   */
  public TransferActions getServerHandler() {
<span class="fc" id="L266">    return serverHandler;</span>
  }

  /**
   * @return the channelHandlerContextNetwork
   */
  public ChannelHandlerContext getChannelHandlerContextNetwork() {
<span class="nc" id="L273">    return networkChannelRef.channel().pipeline()</span>
<span class="nc" id="L274">                            .context(NetworkServerInitializer.NETWORK_HANDLER);</span>
  }

  /**
   * @return the actual dbSession
   */
  public DbSession getDbSession() {
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">    if (networkServerHandler != null) {</span>
<span class="fc" id="L282">      return networkServerHandler.getDbSession();</span>
    }
<span class="nc" id="L284">    logger.info(&quot;SHOULD NOT BE&quot;);</span>
<span class="nc" id="L285">    return admin.getSession();</span>
  }

  /**
   * @param remoteId the remoteId to set
   */
  public void setRemoteId(final Integer remoteId) {
<span class="fc" id="L292">    this.remoteId = remoteId;</span>
<span class="fc" id="L293">  }</span>

  /**
   * @return the session
   */
  public R66Session getSession() {
<span class="fc" id="L299">    return session;</span>
  }

  /**
   * @param session the session to set
   */
  public void setSession(final R66Session session) {
<span class="fc" id="L306">    this.session = session;</span>
<span class="fc" id="L307">  }</span>

  /**
   * @return the current errorMessage
   */
  public String getErrorMessage() {
<span class="fc" id="L313">    return errorMessage;</span>
  }

  /**
   * @param errorMessage the errorMessage to set
   */
  public void setErrorMessage(final String errorMessage, final ErrorCode code) {
<span class="fc" id="L320">    this.errorMessage = errorMessage;</span>
<span class="fc" id="L321">    this.code = code;</span>
<span class="fc" id="L322">  }</span>

  /**
   * @return the code
   */
  public ErrorCode getCurrentCode() {
<span class="fc" id="L328">    return code;</span>
  }

  /**
   * Validate or not the Startup (before connection)
   *
   * @param validate
   */
  public void validateStartup(final boolean validate) {
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">    if (futureStartup.isDone()) {</span>
<span class="nc" id="L338">      return;</span>
    }
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">    if (validate) {</span>
<span class="fc" id="L341">      futureStartup.setSuccess();</span>
    } else {
<span class="nc" id="L343">      futureStartup.cancel();</span>
    }
<span class="fc" id="L345">  }</span>

  /**
   * @return the futureValidateStartup
   */
  public R66Future getFutureValidateStartup() {
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">    if (!futureStartup.awaitOrInterruptible()) {</span>
<span class="nc" id="L352">      validateStartup(false);</span>
<span class="nc" id="L353">      return futureStartup;</span>
    }
<span class="fc" id="L355">    return futureStartup;</span>
  }

  /**
   * @return True if the connection is validated (in OK or KO status)
   */
  public boolean isConnectionValidate() {
<span class="nc" id="L362">    return futureConnection.isDone();</span>
  }

  /**
   * Validate or Invalidate the connection (authentication)
   *
   * @param validate
   */
  public void validateConnection(final boolean validate,
                                 final R66Result result) {
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">    if (futureConnection.isDone()) {</span>
<span class="nc" id="L373">      logger.debug(&quot;LocalChannelReference already validated: &quot; +</span>
<span class="nc" id="L374">                   futureConnection.isSuccess());</span>
<span class="nc" id="L375">      return;</span>
    }
<span class="fc" id="L377">    logger.debug(&quot;Validation of connection {}&quot;, validate);</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">    if (validate) {</span>
<span class="fc" id="L379">      futureConnection.setResult(result);</span>
<span class="fc" id="L380">      futureConnection.setSuccess();</span>
    } else {
<span class="nc" id="L382">      futureConnection.setResult(result);</span>
<span class="nc" id="L383">      setErrorMessage(result.getMessage(), result.getCode());</span>
<span class="nc" id="L384">      futureConnection.cancel();</span>
    }
<span class="fc" id="L386">  }</span>

  /**
   * @return the futureValidateConnection
   */
  public R66Future getFutureValidateConnection() {
    final R66Result result;
<span class="fc" id="L393">    final Channel channel = networkChannelRef.channel();</span>
<span class="pc bpc" id="L394" title="2 of 4 branches missed.">    if (channel != null &amp;&amp; channel.isActive()) {</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">      if (!futureConnection.awaitOrInterruptible()) {</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">        if (futureConnection.isDone()) {</span>
<span class="nc" id="L397">          return futureConnection;</span>
        } else {
<span class="nc" id="L399">          logger.warn(&quot;Cannot get Connection due to out of Time: {}&quot;, this);</span>
<span class="nc" id="L400">          result = new R66Result(</span>
              new OpenR66ProtocolNoConnectionException(&quot;Out of time&quot;), session,
              false, ErrorCode.ConnectionImpossible, null);
<span class="nc" id="L403">          validateConnection(false, result);</span>
<span class="nc" id="L404">          return futureConnection;</span>
        }
      } else {
<span class="fc" id="L407">        return futureConnection;</span>
      }
    }
<span class="nc bnc" id="L410" title="All 2 branches missed.">    if (futureConnection.isDone()) {</span>
<span class="nc" id="L411">      return futureConnection;</span>
    }

<span class="nc" id="L414">    logger.info(&quot;Cannot get Connection due to out of Time: {}&quot;, this);</span>
<span class="nc" id="L415">    result =</span>
        new R66Result(new OpenR66ProtocolNoConnectionException(&quot;Out of time&quot;),
                      session, false, ErrorCode.ConnectionImpossible, null);
<span class="nc" id="L418">    validateConnection(false, result);</span>
<span class="nc" id="L419">    return futureConnection;</span>
  }

  /**
   * Validate the End of a Transfer
   *
   * @param finalValue
   */
  public void validateEndTransfer(final R66Result finalValue) {
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">    if (!futureEndTransfer.isDone()) {</span>
<span class="fc" id="L429">      futureEndTransfer.setResult(finalValue);</span>
<span class="fc" id="L430">      futureEndTransfer.setSuccess();</span>
    } else {
<span class="nc" id="L432">      logger.debug(&quot;Could not validate since Already validated: &quot; +</span>
<span class="nc" id="L433">                   futureEndTransfer.isSuccess() + ' ' + finalValue);</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">      if (!futureEndTransfer.getResult().isAnswered()) {</span>
<span class="nc" id="L435">        futureEndTransfer.getResult().setAnswered(finalValue.isAnswered());</span>
      }
    }
<span class="fc" id="L438">  }</span>

  /**
   * @return the futureEndTransfer
   */
  public R66Future getFutureEndTransfer() {
<span class="fc" id="L444">    return futureEndTransfer;</span>
  }

  /**
   * Special waiter for Send Through method. It reset the EndTransfer future.
   *
   * @throws OpenR66Exception
   */
  public void waitReadyForSendThrough() throws OpenR66Exception {
<span class="fc" id="L453">    logger.debug(&quot;Wait for End of Prepare Transfer&quot;);</span>
<span class="fc" id="L454">    futureEndTransfer.awaitOrInterruptible();</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">    if (futureEndTransfer.isSuccess()) {</span>
      // reset since transfer will start now
<span class="fc" id="L457">      futureEndTransfer = new R66Future(true);</span>
    } else {
<span class="nc bnc" id="L459" title="All 2 branches missed.">      if (futureEndTransfer.getResult() != null &amp;&amp;</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">          futureEndTransfer.getResult().getException() != null) {</span>
<span class="nc" id="L461">        throw futureEndTransfer.getResult().getException();</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">      } else if (futureEndTransfer.getCause() != null) {</span>
<span class="nc" id="L463">        throw new OpenR66RunnerErrorException(futureEndTransfer.getCause());</span>
      } else {
<span class="nc" id="L465">        throw new OpenR66RunnerErrorException(&quot;Unknown reason&quot;);</span>
      }
    }
<span class="fc" id="L468">  }</span>

  /**
   * @return the futureValidRequest
   */
  public R66Future getFutureValidRequest() {
<span class="fc" id="L474">    return futureValidRequest;</span>
  }

  /**
   * @return the futureRequest
   */
  public R66Future getFutureRequest() {
<span class="fc" id="L481">    return futureRequest;</span>
  }

  /**
   * Invalidate the current request
   *
   * @param finalvalue
   */
  public void invalidateRequest(final R66Result finalvalue) {
<span class="fc" id="L490">    R66Result finalValue = finalvalue;</span>
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">    if (finalValue == null) {</span>
<span class="nc" id="L492">      finalValue =</span>
<span class="nc" id="L493">          new R66Result(session, false, ErrorCode.Unknown, session.getRunner());</span>
    }
<span class="fc" id="L495">    logger.debug(</span>
<span class="fc" id="L496">        &quot;FST: &quot; + futureStartup.isDone() + &quot;:&quot; + futureStartup.isSuccess() +</span>
<span class="fc" id="L497">        &quot; FCT: &quot; + futureConnection.isDone() + ':' +</span>
<span class="fc" id="L498">        futureConnection.isSuccess() + &quot; FET: &quot; + futureEndTransfer.isDone() +</span>
<span class="fc" id="L499">        ':' + futureEndTransfer.isSuccess() + &quot; FVR: &quot; +</span>
<span class="fc" id="L500">        futureValidRequest.isDone() + ':' + futureValidRequest.isSuccess() +</span>
<span class="fc" id="L501">        &quot; FR: &quot; + futureRequest.isDone() + ':' + futureRequest.isSuccess() +</span>
<span class="fc" id="L502">        ' ' + finalValue.getMessage());</span>
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">    if (!futureStartup.isDone()) {</span>
<span class="nc" id="L504">      futureStartup.setResult(finalValue);</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">      if (finalValue.getException() != null) {</span>
<span class="nc" id="L506">        futureStartup.setFailure(finalValue.getException());</span>
      } else {
<span class="nc" id="L508">        futureStartup.cancel();</span>
      }
    }
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">    if (!futureConnection.isDone()) {</span>
<span class="nc" id="L512">      futureConnection.setResult(finalValue);</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">      if (finalValue.getException() != null) {</span>
<span class="nc" id="L514">        futureConnection.setFailure(finalValue.getException());</span>
      } else {
<span class="nc" id="L516">        futureConnection.cancel();</span>
      }
    }
<span class="fc bfc" id="L519" title="All 2 branches covered.">    if (!futureEndTransfer.isDone()) {</span>
<span class="fc" id="L520">      futureEndTransfer.setResult(finalValue);</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">      if (finalValue.getException() != null) {</span>
<span class="fc" id="L522">        futureEndTransfer.setFailure(finalValue.getException());</span>
      } else {
<span class="fc" id="L524">        futureEndTransfer.cancel();</span>
      }
    }
<span class="fc bfc" id="L527" title="All 2 branches covered.">    if (!futureValidRequest.isDone()) {</span>
<span class="fc" id="L528">      futureValidRequest.setResult(finalValue);</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">      if (finalValue.getException() != null) {</span>
<span class="fc" id="L530">        futureValidRequest.setFailure(finalValue.getException());</span>
      } else {
<span class="fc" id="L532">        futureValidRequest.cancel();</span>
      }
    }
<span class="fc" id="L535">    logger.trace(&quot;Invalidate Request&quot;,</span>
                 new Exception(&quot;DEBUG Trace for &quot; + &quot;Invalidation&quot;));
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">    if (finalValue.getCode() != ErrorCode.ServerOverloaded) {</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">      if (!futureRequest.isDone()) {</span>
<span class="fc" id="L539">        setErrorMessage(finalValue.getMessage(), finalValue.getCode());</span>
<span class="fc" id="L540">        futureRequest.setResult(finalValue);</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">        if (finalValue.getException() != null) {</span>
<span class="fc" id="L542">          futureRequest.setFailure(finalValue.getException());</span>
        } else {
<span class="fc" id="L544">          futureRequest.cancel();</span>
        }
      } else {
<span class="fc" id="L547">        logger.debug(&quot;Could not invalidate since Already finished: &quot; +</span>
<span class="fc" id="L548">                     futureEndTransfer.getResult());</span>
      }
    } else {
<span class="nc" id="L551">      setErrorMessage(finalValue.getMessage(), finalValue.getCode());</span>
<span class="nc" id="L552">      logger.debug(&quot;Overloaded&quot;);</span>
    }
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">    if (session != null) {</span>
<span class="fc" id="L555">      final DbTaskRunner runner = session.getRunner();</span>
<span class="fc bfc" id="L556" title="All 4 branches covered.">      if (runner != null &amp;&amp; runner.isSender()) {</span>
<span class="fc" id="L557">        NetworkTransaction.stopRetrieve(this);</span>
      }
    }
<span class="fc" id="L560">  }</span>

  /**
   * Validate the current Request
   *
   * @param finalValue
   */
  public void validateRequest(final R66Result finalValue) {
<span class="fc" id="L568">    setErrorMessage(&quot;NoError&quot;, null);</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">    if (!futureEndTransfer.isDone()) {</span>
<span class="fc" id="L570">      logger.debug(&quot;Will validate EndTransfer&quot;);</span>
<span class="fc" id="L571">      validateEndTransfer(finalValue);</span>
    }
<span class="fc bfc" id="L573" title="All 2 branches covered.">    if (!futureValidRequest.isDone()) {</span>
<span class="fc" id="L574">      futureValidRequest.setResult(finalValue);</span>
<span class="fc" id="L575">      futureValidRequest.setSuccess();</span>
    }
<span class="fc" id="L577">    logger.debug(&quot;Validate Request&quot;);</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">    if (!futureRequest.isDone()) {</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">      if (finalValue.getOther() == null &amp;&amp;</span>
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">          session.getBusinessObject() != null &amp;&amp;</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">          session.getBusinessObject().getInfo(session) != null) {</span>
<span class="nc" id="L582">        finalValue.setOther(session.getBusinessObject().getInfo(session));</span>
      }
<span class="fc" id="L584">      futureRequest.setResult(finalValue);</span>
<span class="fc" id="L585">      futureRequest.setSuccess();</span>
    } else {
<span class="fc" id="L587">      logger.info(</span>
<span class="fc" id="L588">          &quot;Already validated: &quot; + futureRequest.isSuccess() + ' ' + finalValue);</span>
<span class="pc bpc" id="L589" title="1 of 2 branches missed.">      if (!futureRequest.getResult().isAnswered()) {</span>
<span class="nc" id="L590">        futureRequest.getResult().setAnswered(finalValue.isAnswered());</span>
      }
    }
<span class="fc" id="L593">  }</span>

  private long getMinLimit(final long a, final long b) {
<span class="fc" id="L596">    long res = a;</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">    if (a &lt;= 0) {</span>
<span class="fc" id="L598">      res = b;</span>
<span class="pc bpc" id="L599" title="2 of 4 branches missed.">    } else if (b &gt; 0 &amp;&amp; b &lt; a) {</span>
<span class="nc" id="L600">      res = b;</span>
    }
<span class="fc" id="L602">    return res;</span>
  }

  public void setChannelLimit(final boolean isSender, final long limit) {
<span class="fc" id="L606">    final ChannelTrafficShapingHandler limitHandler =</span>
<span class="fc" id="L607">        (ChannelTrafficShapingHandler) networkChannelRef.channel().pipeline()</span>
<span class="fc" id="L608">                                                        .get(</span>
                                                            NetworkServerInitializer.LIMITCHANNEL);
<span class="fc bfc" id="L610" title="All 2 branches covered.">    if (isSender) {</span>
<span class="fc" id="L611">      limitHandler.setWriteLimit(limit);</span>
<span class="fc" id="L612">      logger.info(&quot;Will write at {} Bytes/sec&quot;, limit);</span>
    } else {
<span class="fc" id="L614">      limitHandler.setReadLimit(limit);</span>
<span class="fc" id="L615">      logger.info(&quot;Will read at {} Bytes/sec&quot;, limit);</span>
    }
<span class="fc" id="L617">  }</span>

  public long getChannelLimit(final boolean isSender) {
    final long global;
    final long channel;
<span class="fc bfc" id="L622" title="All 2 branches covered.">    if (isSender) {</span>
<span class="fc" id="L623">      global = Configuration.configuration.getServerGlobalWriteLimit();</span>
<span class="fc" id="L624">      channel = Configuration.configuration.getServerChannelWriteLimit();</span>
    } else {
<span class="fc" id="L626">      global = Configuration.configuration.getServerGlobalReadLimit();</span>
<span class="fc" id="L627">      channel = Configuration.configuration.getServerChannelReadLimit();</span>
    }
<span class="fc" id="L629">    return getMinLimit(global, channel);</span>
  }

  @Override
  public String toString() {
<span class="nc bnc" id="L634" title="All 4 branches missed.">    return &quot;LCR: L: &quot; + localId + &quot; R: &quot; + remoteId + &quot; Startup[&quot; +</span>
           futureStartup + &quot;] Conn[&quot; + futureConnection +
           &quot;] ValidRequestRequest[&quot; + futureValidRequest + &quot;] EndTransfer[&quot; +
           (futureEndTransfer != null? futureEndTransfer : &quot;noEndTransfer&quot;) +
           &quot;] Request[&quot; + (futureRequest != null? futureRequest : &quot;noRequest&quot;) +
           ']';
  }

  /**
   * @return the recvThroughHandler
   */
  public RecvThroughHandler getRecvThroughHandler() {
<span class="fc" id="L646">    return recvThroughHandler;</span>
  }

  /**
   * @return True if in RecvThrough Mode
   */
  public boolean isRecvThroughMode() {
<span class="fc bfc" id="L653" title="All 2 branches covered.">    return recvThroughHandler != null;</span>
  }

  /**
   * @param recvThroughHandler the recvThroughHandler to set
   */
  public void setRecvThroughHandler(
      final RecvThroughHandler recvThroughHandler) {
<span class="fc" id="L661">    this.recvThroughHandler = recvThroughHandler;</span>
<span class="fc" id="L662">  }</span>

  /**
   * @return True if in SendThrough Mode
   */
  public boolean isSendThroughMode() {
<span class="fc" id="L668">    return isSendThroughMode;</span>
  }

  /**
   * @param isSendThroughMode the isSendThroughMode to set
   */
  public void setSendThroughMode(final boolean isSendThroughMode) {
<span class="fc" id="L675">    this.isSendThroughMode = isSendThroughMode;</span>
<span class="fc" id="L676">  }</span>

  /**
   * @return the clientRunner
   */
  public ClientRunner getClientRunner() {
<span class="nc" id="L682">    return clientRunner;</span>
  }

  /**
   * @param clientRunner the clientRunner to set
   */
  public void setClientRunner(final ClientRunner clientRunner) {
<span class="fc" id="L689">    this.clientRunner = clientRunner;</span>
<span class="fc" id="L690">  }</span>

  /**
   * Shortcut to set a new state in Session
   *
   * @param desiredState
   */
  public void sessionNewState(final R66FiniteDualStates desiredState) {
<span class="pc bpc" id="L698" title="1 of 2 branches missed.">    if (session != null) {</span>
<span class="fc" id="L699">      session.newState(desiredState);</span>
    }
<span class="fc" id="L701">  }</span>

  /**
   * @return the current state or TEST if no session exists
   */
  public R66FiniteDualStates getSessionState() {
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">    if (session != null) {</span>
<span class="fc" id="L708">      return session.getState();</span>
    }
<span class="nc" id="L710">    return R66FiniteDualStates.TEST;</span>
  }

  /**
   * @return the hashComputeDuringTransfer
   */
  public String getHashComputeDuringTransfer() {
<span class="fc" id="L717">    return hashComputeDuringTransfer;</span>
  }

  /**
   * @param hashComputeDuringTransfer the hashComputeDuringTransfer to
   *     set
   */
  public void setHashComputeDuringTransfer(
      final String hashComputeDuringTransfer) {
<span class="fc" id="L726">    this.hashComputeDuringTransfer = hashComputeDuringTransfer;</span>
<span class="fc" id="L727">  }</span>

  public void setPartialHash() {
<span class="nc" id="L730">    partialHash = true;</span>
<span class="nc" id="L731">  }</span>

  public boolean isPartialHash() {
<span class="fc" id="L734">    return partialHash;</span>
  }

  /**
   * @return the partner
   */
  public PartnerConfiguration getPartner() {
<span class="fc" id="L741">    return partner;</span>
  }

  /**
   * @param hostId the partner to set
   */
  public void setPartner(final String hostId) {
<span class="fc" id="L748">    logger.debug(&quot;host:&quot; + hostId);</span>
<span class="fc" id="L749">    partner = Configuration.configuration.getVersions().get(hostId);</span>
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">    if (partner == null) {</span>
<span class="nc" id="L751">      partner =</span>
<span class="nc" id="L752">          new PartnerConfiguration(hostId, R66Versions.V2_4_12.getVersion());</span>
    }
<span class="fc" id="L754">  }</span>

  /**
   * @return the requestId
   */
  public String getRequestId() {
<span class="fc" id="L760">    return requestId;</span>
  }

  /**
   * @param requestId the requestId to set
   */
  public void setRequestId(final String requestId) {
<span class="fc" id="L767">    this.requestId = requestId;</span>
<span class="fc" id="L768">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>