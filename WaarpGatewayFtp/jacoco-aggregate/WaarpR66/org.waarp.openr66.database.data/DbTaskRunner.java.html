<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DbTaskRunner.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Gateway Ftp</a> &gt; <a href="../index.html" class="el_bundle">WaarpR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.database.data</a> &gt; <span class="el_source">DbTaskRunner.java</span></div><h1>DbTaskRunner.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.openr66.database.data;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.DocumentHelper;
import org.dom4j.Element;
import org.dom4j.Node;
import org.dom4j.io.OutputFormat;
import org.dom4j.io.SAXReader;
import org.dom4j.io.XMLWriter;
import org.dom4j.tree.DefaultElement;
import org.waarp.common.command.exception.CommandAbstractException;
import org.waarp.common.database.DbConstant;
import org.waarp.common.database.DbPreparedStatement;
import org.waarp.common.database.DbSession;
import org.waarp.common.database.data.AbstractDbData;
import org.waarp.common.database.exception.WaarpDatabaseException;
import org.waarp.common.database.exception.WaarpDatabaseNoConnectionException;
import org.waarp.common.database.exception.WaarpDatabaseNoDataException;
import org.waarp.common.database.exception.WaarpDatabaseSqlException;
import org.waarp.common.digest.FilesystemBasedDigest;
import org.waarp.common.file.DirInterface;
import org.waarp.common.file.FileUtils;
import org.waarp.common.json.JsonHandler;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.lru.SynchronizedLruCache;
import org.waarp.common.utility.ParametersChecker;
import org.waarp.common.utility.WaarpStringUtils;
import org.waarp.common.xml.XmlUtil;
import org.waarp.openr66.context.ErrorCode;
import org.waarp.openr66.context.R66FiniteDualStates;
import org.waarp.openr66.context.R66Result;
import org.waarp.openr66.context.R66Session;
import org.waarp.openr66.context.filesystem.R66Dir;
import org.waarp.openr66.context.filesystem.R66File;
import org.waarp.openr66.context.task.AbstractTask;
import org.waarp.openr66.context.task.TaskType;
import org.waarp.openr66.context.task.exception.OpenR66RunnerEndTasksException;
import org.waarp.openr66.context.task.exception.OpenR66RunnerErrorException;
import org.waarp.openr66.context.task.exception.OpenR66RunnerException;
import org.waarp.openr66.dao.AbstractDAO;
import org.waarp.openr66.dao.DAOFactory;
import org.waarp.openr66.dao.Filter;
import org.waarp.openr66.dao.TransferDAO;
import org.waarp.openr66.dao.database.DBTransferDAO;
import org.waarp.openr66.dao.database.StatementExecutor;
import org.waarp.openr66.dao.exception.DAOConnectionException;
import org.waarp.openr66.dao.exception.DAONoDataException;
import org.waarp.openr66.dao.xml.XMLTransferDAO;
import org.waarp.openr66.pojo.Transfer;
import org.waarp.openr66.protocol.configuration.Configuration;
import org.waarp.openr66.protocol.configuration.PartnerConfiguration;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolBusinessException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNoSslException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolPacketException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolSystemException;
import org.waarp.openr66.protocol.localhandler.LocalChannelReference;
import org.waarp.openr66.protocol.localhandler.LocalTransaction;
import org.waarp.openr66.protocol.localhandler.packet.ErrorPacket;
import org.waarp.openr66.protocol.localhandler.packet.RequestPacket;
import org.waarp.openr66.protocol.localhandler.packet.RequestPacket.TRANSFERMODE;
import org.waarp.openr66.protocol.networkhandler.NetworkServerHandler;
import org.waarp.openr66.protocol.utils.ChannelUtils;
import org.waarp.openr66.protocol.utils.NbAndSpecialId;
import org.waarp.openr66.protocol.utils.R66Future;
import org.xml.sax.SAXException;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.waarp.common.database.DbConstant.*;
import static org.waarp.openr66.client.TransferArgs.*;

/**
 * Task Runner from pre operation to transfer to post operation, except in case
 * of error
 */
public class DbTaskRunner extends AbstractDbDataDao&lt;Transfer&gt; {
  private static final String TRANSFER_NOT_FOUND = &quot;Transfer not found&quot;;

  public static final String JSON_ORIGINALSIZE = &quot;ORIGINALSIZE&quot;;

  public static final String JSON_THROUGHMODE = &quot;THROUGHMODE&quot;;

  public static final String JSON_RESCHEDULE = &quot;RESCHEDULE&quot;;

  public static final String JSON_COMPRESSION = &quot;COMPRESSION&quot;;

  /**
   * Internal Logger
   */
<span class="fc" id="L127">  private static final WaarpLogger logger =</span>
<span class="fc" id="L128">      WaarpLoggerFactory.getLogger(DbTaskRunner.class);</span>
  private static final String GETTING_VALUES_IN_ERROR =
      &quot;Getting values in error&quot;;
  private static final String CANNOT_WRITE_XML_FILE = &quot;Cannot write XML file&quot;;
  private static final String UNSUPPORTED_ENCODING = &quot;Unsupported Encoding&quot;;
  private static final String CANNOT_DELETE_WRONG_XML_FILE =
      &quot;Cannot delete wrong XML file&quot;;
  private static final String FOLLOW_ID_LIKE = &quot;\&quot;&quot; + FOLLOW_JSON_KEY + &quot;\&quot;:&quot;;
  public static final String AND = &quot; AND &quot;;
  public static final String SELECT_COUNT = &quot;SELECT COUNT(&quot;;
  public static final String TRACE_FOR_ERROR = &quot;Trace for error&quot;;
  /**
   * HashTable in case of lack of database using LRU mode with 20 000 items
   * maximum (&lt; 100 KB?) for 180s
   */
  private static SynchronizedLruCache&lt;Long, Boolean&gt; dbR66TaskHashMap;

  /**
   * Create the LRU cache
   *
   * @param limit limit of number of entries in the cache
   * @param ttl time to leave used
   */
  public static void createLruCache(final int limit, final long ttl) {
<span class="fc" id="L152">    XMLTransferDAO.createLruCache(limit, ttl);</span>
<span class="fc" id="L153">    dbR66TaskHashMap = new SynchronizedLruCache&lt;Long, Boolean&gt;(limit, ttl);</span>
<span class="fc" id="L154">  }</span>

  public static String hashStatus() {
<span class="nc" id="L157">    return XMLTransferDAO.hashStatus();</span>
  }

  /**
   * To enable clear of oldest entries in the cache
   *
   * @return the number of elements removed
   */
  public static int clearCache() {
<span class="fc" id="L166">    dbR66TaskHashMap.forceClearOldest();</span>
<span class="fc" id="L167">    return XMLTransferDAO.clearCache();</span>
  }

  /**
   * To update the TTL for the cache (to 10xTIMEOUT)
   *
   * @param ttl
   */
  public static void updateLruCacheTimeout(final long ttl) {
<span class="fc" id="L176">    XMLTransferDAO.updateLruCacheTimeout(ttl);</span>
<span class="fc" id="L177">  }</span>

<span class="fc" id="L179">  public enum Columns {</span>
<span class="fc" id="L180">    SPECIALID, GLOBALSTEP, GLOBALLASTSTEP, STEP, RANK, BLOCKSZ, MODETRANS,</span>
<span class="fc" id="L181">    UPDATEDINFO, STEPSTATUS, INFOSTATUS, RETRIEVEMODE, ISMOVED, STARTTRANS,</span>
<span class="fc" id="L182">    STOPTRANS, OWNERREQ, REQUESTER, REQUESTED, IDRULE, FILENAME, ORIGINALNAME,</span>
<span class="fc" id="L183">    FILEINFO, TRANSFERINFO</span>
  }

<span class="fc" id="L186">  public static final int[] dbTypes = {</span>
      Types.BIGINT, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER,
      Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.CHAR, Types.CHAR,
      Types.BIT, Types.BIT, Types.TIMESTAMP, Types.TIMESTAMP, Types.NVARCHAR,
      Types.NVARCHAR, Types.NVARCHAR, Types.NVARCHAR, Types.VARCHAR,
      Types.VARCHAR, Types.VARCHAR, Types.VARCHAR
  };

  public static final String table = &quot; RUNNER &quot;;

  public static final String fieldseq = &quot;RUNSEQ&quot;;

<span class="fc" id="L198">  public static final String[] indexesNames = {</span>
      &quot;IDX_PUSH_FILTER&quot;, &quot;IDX_RUN_FILTER&quot;, &quot;IDX_MON_FILTER&quot;
  };
<span class="fc" id="L201">  public static final Columns[][] indexes = {</span>
      // Push
      {
          Columns.STOPTRANS, Columns.OWNERREQ
      },
      // Run
      {
          Columns.UPDATEDINFO, Columns.OWNERREQ, Columns.STARTTRANS
      },
      // Mon
      {
          Columns.GLOBALSTEP, Columns.OWNERREQ, Columns.STARTTRANS
      }
  };

  /**
   * Special For DbTaskRunner
   */
<span class="fc" id="L219">  public static final String[] PRIMARY_KEY = {</span>
<span class="fc" id="L220">      Columns.REQUESTED.name(), Columns.REQUESTER.name(),</span>
<span class="fc" id="L221">      Columns.OWNERREQ.name(), Columns.SPECIALID.name()</span>
  };

  public static final String XMLRUNNERS = &quot;taskrunners&quot;;
  public static final String XMLRUNNER = &quot;runner&quot;;
  public static final String XMLEXTENSION = &quot;_singlerunner.xml&quot;;

  /**
   * GlobalStep Bounds
   */
<span class="fc" id="L231">  public enum TASKSTEP {</span>
<span class="fc" id="L232">    NOTASK, PRETASK, TRANSFERTASK, POSTTASK, ALLDONETASK, ERRORTASK</span>
  }

  // Values
  private DbRule rule;

  private R66Session session;

<span class="fc" id="L240">  private boolean continueTransfer = true;</span>

  private boolean rescheduledTransfer;

  private LocalChannelReference localChannelReference;

  private boolean isRecvThrough;
  private boolean isSendThrough;
<span class="fc" id="L248">  private long originalSize = -1;</span>
<span class="fc" id="L249">  private boolean isOtherThanStatus = true;</span>
<span class="fc" id="L250">  private Map&lt;String, Object&gt; transferMap = null;</span>

  // ALL TABLE SHOULD IMPLEMENT THIS

  protected static final String selectAllFields = &quot; * &quot;;

  @Override
  protected final void initObject() {
    // Nothing
<span class="fc" id="L259">  }</span>

  @Override
  protected final String getTable() {
<span class="nc" id="L263">    return table;</span>
  }

  @Override
  protected final AbstractDAO&lt;Transfer&gt; getDao(final boolean isCacheable)
      throws DAOConnectionException {
<span class="fc" id="L269">    return DAOFactory.getInstance().getTransferDAO();</span>
  }

  /**
   * {@link UnsupportedOperationException}
   *
   * @return never
   */
  @Override
  protected final String getPrimaryKey() {
<span class="nc" id="L279">    throw new UnsupportedOperationException(&quot;Not correct for Transfer&quot;);</span>
  }

  /**
   * {@link UnsupportedOperationException}
   *
   * @return never
   */
  @Override
  protected final String getPrimaryField() {
<span class="nc" id="L289">    throw new UnsupportedOperationException(&quot;Not correct for Transfer&quot;);</span>
  }

  /**
   * @param session
   * @param requestPacket
   *
   * @return The associated requested Host Id
   */
  public static String getRequested(final R66Session session,
                                    final RequestPacket requestPacket) {
<span class="fc bfc" id="L300" title="All 2 branches covered.">    if (requestPacket.isToValidate()) {</span>
      // the request is initiated and sent by the requester
      try {
<span class="fc" id="L303">        return Configuration.configuration.getHostId(session.getAuth().isSsl());</span>
<span class="nc" id="L304">      } catch (final OpenR66ProtocolNoSslException e) {</span>
<span class="nc" id="L305">        return Configuration.configuration.getHostId();</span>
      }
    } else {
      // the request is sent after acknowledge by the requested
<span class="fc" id="L309">      return session.getAuth().getUser();</span>
    }
  }

  /**
   * @param session
   * @param requestPacket
   *
   * @return The associated requester Host Id
   */
  public static String getRequester(final R66Session session,
                                    final RequestPacket requestPacket) {
<span class="fc bfc" id="L321" title="All 2 branches covered.">    if (requestPacket.isToValidate()) {</span>
<span class="fc" id="L322">      return session.getAuth().getUser();</span>
    } else {
      try {
<span class="fc" id="L325">        return Configuration.configuration.getHostId(session.getAuth().isSsl());</span>
<span class="nc" id="L326">      } catch (final OpenR66ProtocolNoSslException e) {</span>
<span class="nc" id="L327">        return Configuration.configuration.getHostId();</span>
      }
    }
  }

  public final void checkThroughMode() {
<span class="fc" id="L333">    isRecvThrough = RequestPacket.isRecvThroughMode(pojo.getTransferMode(),</span>
<span class="fc" id="L334">                                                    isRequestOnRequested());</span>
<span class="fc" id="L335">    isSendThrough = RequestPacket.isSendThroughMode(pojo.getTransferMode(),</span>
<span class="fc" id="L336">                                                    isRequestOnRequested());</span>

<span class="fc bfc" id="L338" title="All 2 branches covered.">    if (localChannelReference != null) {</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">      if (localChannelReference.isRecvThroughMode()) {</span>
<span class="fc" id="L340">        isRecvThrough = true;</span>
      }
<span class="fc bfc" id="L342" title="All 2 branches covered.">      if (localChannelReference.isSendThroughMode()) {</span>
<span class="fc" id="L343">        isSendThrough = true;</span>
      }
<span class="fc bfc" id="L345" title="All 4 branches covered.">      if (isRecvThrough &amp;&amp; !localChannelReference.isRecvThroughMode()) {</span>
        // Cannot be a RecvThrough
<span class="fc" id="L347">        isRecvThrough = false;</span>
      }
<span class="fc bfc" id="L349" title="All 4 branches covered.">      if (isSendThrough &amp;&amp; !localChannelReference.isSendThroughMode()) {</span>
<span class="fc" id="L350">        isSendThrough = false;</span>
      }
    }
<span class="fc" id="L353">    logger.debug(&quot;DbTask {} isRecvThrough: {} isSendThrough: {}&quot;,</span>
<span class="fc" id="L354">                 pojo.getTransferMode(), isRecvThrough, isSendThrough);</span>
<span class="fc" id="L355">  }</span>

  private void setStopNow() {
<span class="fc" id="L358">    isSaved = false;</span>
<span class="fc" id="L359">    pojo.setStop(new Timestamp(System.currentTimeMillis()));</span>
<span class="fc" id="L360">  }</span>

<span class="fc" id="L362">  public DbTaskRunner(final Transfer transfer) {</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">    if (transfer == null) {</span>
<span class="nc" id="L364">      throw new IllegalArgumentException(</span>
          &quot;Argument in constructor cannot be null&quot;);
    }
<span class="fc" id="L367">    this.pojo = transfer;</span>
<span class="fc" id="L368">    isSaved = false;</span>
<span class="fc" id="L369">    isOtherThanStatus = true;</span>
<span class="fc" id="L370">    initializeTransferInfo();</span>
<span class="fc" id="L371">    checkThroughMode();</span>
<span class="fc" id="L372">    checkMapInfo();</span>
<span class="fc" id="L373">  }</span>

  /**
   * Constructor for submission (no transfer session), from database. It is
   * created, so with a new specialId if
   * necessary
   *
   * @param rule
   * @param isSender
   * @param requestPacket
   * @param requested
   * @param startTime
   *
   * @throws WaarpDatabaseException
   */
  public DbTaskRunner(final DbRule rule, final boolean isSender,
                      final RequestPacket requestPacket, final String requested,
<span class="fc" id="L390">                      final Timestamp startTime) throws WaarpDatabaseException {</span>
<span class="fc" id="L391">    session = null;</span>
<span class="fc" id="L392">    this.rule = rule;</span>

<span class="fc bfc" id="L394" title="All 2 branches covered.">    if (startTime != null) {</span>
<span class="fc" id="L395">      pojo = new Transfer(requested, rule.getIdRule(), requestPacket.getMode(),</span>
<span class="fc" id="L396">                          isSender, requestPacket.getFilename(),</span>
<span class="fc" id="L397">                          requestPacket.getTransferInformation(),</span>
<span class="fc" id="L398">                          requestPacket.getBlocksize(), startTime);</span>
    } else {
<span class="fc" id="L400">      pojo = new Transfer(requested, rule.getIdRule(), requestPacket.getMode(),</span>
<span class="fc" id="L401">                          isSender, requestPacket.getFilename(),</span>
<span class="fc" id="L402">                          requestPacket.getTransferInformation(),</span>
<span class="fc" id="L403">                          requestPacket.getBlocksize());</span>
    }

    // Usefull ?
<span class="fc" id="L407">    pojo.setRank(requestPacket.getRank());</span>
<span class="fc" id="L408">    pojo.setId(requestPacket.getSpecialId());</span>

<span class="fc" id="L410">    originalSize = requestPacket.getOriginalSize();</span>
<span class="fc" id="L411">    setOriginalSizeTransferMap(originalSize);</span>
    // itself but according to SSL
<span class="fc" id="L413">    pojo.setRequester(Configuration.configuration.getHostId(requested));</span>

    // Retrieve rule
<span class="fc" id="L416">    this.rule = new DbRule(getRuleId());</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">    if (requestPacket.getMode() != rule.getMode()) {</span>
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">      if (RequestPacket.isMD5Mode(requestPacket.getMode())) {</span>
<span class="fc" id="L419">        pojo.setTransferMode(RequestPacket.getModeMD5(rule.getMode()));</span>
      } else {
<span class="nc" id="L421">        pojo.setTransferMode(rule.getMode());</span>
      }
    }
<span class="fc" id="L424">    checkMapInfo();</span>
<span class="fc" id="L425">    checkThroughMode();</span>
<span class="fc" id="L426">    insert();</span>
<span class="fc" id="L427">    requestPacket.setSpecialId(pojo.getId());</span>
<span class="fc" id="L428">  }</span>

  /**
   * Constructor from a request without a valid Special Id to be inserted into
   * databases
   *
   * @param session
   * @param rule
   * @param isSender
   * @param requestPacket
   *
   * @throws WaarpDatabaseException
   */
  public DbTaskRunner(final R66Session session, final DbRule rule,
                      final boolean isSender, final RequestPacket requestPacket)
<span class="fc" id="L443">      throws WaarpDatabaseException {</span>
<span class="fc" id="L444">    this.session = session;</span>
<span class="fc" id="L445">    localChannelReference = session.getLocalChannelReference();</span>
<span class="fc" id="L446">    this.rule = rule;</span>

<span class="fc" id="L448">    pojo = new Transfer(getRequested(session, requestPacket), rule.getIdRule(),</span>
<span class="fc" id="L449">                        requestPacket.getMode(), isSender,</span>
<span class="fc" id="L450">                        requestPacket.getFilename(),</span>
<span class="fc" id="L451">                        requestPacket.getTransferInformation(),</span>
<span class="fc" id="L452">                        requestPacket.getBlocksize());</span>
<span class="fc" id="L453">    pojo.setRequester(getRequester(session, requestPacket));</span>
<span class="fc" id="L454">    pojo.setRank(requestPacket.getRank());</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">    if (requestPacket.getSpecialId() != ILLEGALVALUE) {</span>
<span class="fc" id="L456">      pojo.setId(requestPacket.getSpecialId());</span>
    }
<span class="fc" id="L458">    originalSize = requestPacket.getOriginalSize();</span>
<span class="fc" id="L459">    setOriginalSizeTransferMap(originalSize);</span>
<span class="fc" id="L460">    checkMapInfo();</span>
<span class="fc" id="L461">    checkThroughMode();</span>
<span class="fc" id="L462">    insert();</span>
<span class="fc" id="L463">    requestPacket.setSpecialId(pojo.getId());</span>
<span class="fc" id="L464">  }</span>

  /**
   * Constructor from a request with a valid Special Id so loaded from
   * database
   *
   * @param session
   * @param rule
   * @param id
   * @param requester
   * @param requested
   *
   * @throws WaarpDatabaseException
   */
  public DbTaskRunner(final R66Session session, final DbRule rule,
                      final long id, final String requester,
<span class="fc" id="L480">                      final String requested) throws WaarpDatabaseException {</span>
<span class="fc" id="L481">    this.session = session;</span>
<span class="fc" id="L482">    TransferDAO transferAccess = null;</span>
    try {
<span class="fc" id="L484">      transferAccess = DAOFactory.getInstance().getTransferDAO();</span>
<span class="fc" id="L485">      pojo = transferAccess.select(id, requester, requested,</span>
<span class="fc" id="L486">                                   Configuration.configuration.getHostId());</span>
<span class="fc" id="L487">      addMap();</span>
<span class="nc" id="L488">    } catch (final DAOConnectionException e) {</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">      if (Configuration.configuration.isShutdown()) {</span>
        // ignore since shutdown
<span class="nc" id="L491">        throw new WaarpDatabaseException(</span>
            &quot;Shutdown on going so database not accessible&quot;);
      }
<span class="nc" id="L494">      throw new WaarpDatabaseException(e);</span>
<span class="fc" id="L495">    } catch (final DAONoDataException e) {</span>
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">      if (Configuration.configuration.isShutdown()) {</span>
        // ignore since shutdown
<span class="nc" id="L498">        throw new WaarpDatabaseException(</span>
            &quot;Shutdown on going so database not accessible&quot;);
      }
<span class="fc" id="L501">      throw new WaarpDatabaseNoDataException(TRANSFER_NOT_FOUND, e);</span>
    } finally {
<span class="fc" id="L503">      DAOFactory.closeDAO(transferAccess);</span>
    }
<span class="fc" id="L505">    this.rule = new DbRule(getRuleId());</span>
<span class="pc bpc" id="L506" title="1 of 4 branches missed.">    if (rule != null &amp;&amp; !pojo.getRule().equals(rule.getIdRule())) {</span>
<span class="nc" id="L507">      throw new WaarpDatabaseNoDataException(&quot;Rule does not correspond&quot;);</span>
    }
<span class="fc" id="L509">    initializeTransferInfo();</span>
<span class="fc" id="L510">    checkThroughMode();</span>
<span class="fc" id="L511">    isSaved = true;</span>
<span class="fc" id="L512">    isOtherThanStatus = false;</span>
<span class="fc" id="L513">  }</span>

  /**
   * Minimal constructor from database
   *
   * @param id
   * @param requester
   * @param requested
   *
   * @throws WaarpDatabaseException
   */
  public DbTaskRunner(final long id, final String requester,
<span class="fc" id="L525">                      final String requested) throws WaarpDatabaseException {</span>
<span class="fc" id="L526">    TransferDAO transferAccess = null;</span>
    try {
<span class="fc" id="L528">      transferAccess = DAOFactory.getInstance().getTransferDAO();</span>
<span class="fc" id="L529">      pojo = transferAccess.select(id, requester, requested,</span>
<span class="fc" id="L530">                                   Configuration.configuration.getHostId());</span>
<span class="fc" id="L531">      addMap();</span>
<span class="nc" id="L532">    } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L533">      throw new WaarpDatabaseException(e);</span>
<span class="fc" id="L534">    } catch (final DAONoDataException e) {</span>
<span class="fc" id="L535">      throw new WaarpDatabaseNoDataException(TRANSFER_NOT_FOUND, e);</span>
    } finally {
<span class="fc" id="L537">      DAOFactory.closeDAO(transferAccess);</span>
    }
<span class="fc" id="L539">    rule = new DbRule(getRuleId());</span>
<span class="fc" id="L540">    initializeTransferInfo();</span>
<span class="fc" id="L541">    checkThroughMode();</span>
<span class="fc" id="L542">    isSaved = true;</span>
<span class="fc" id="L543">    isOtherThanStatus = false;</span>
<span class="fc" id="L544">  }</span>

  /**
   * Minimal constructor from database
   *
   * @param id
   * @param requester
   * @param requested
   *
   * @throws WaarpDatabaseException
   */
  public DbTaskRunner(final long id, final String requester,
                      final String requested, final String owner)
      throws WaarpDatabaseException {
<span class="fc" id="L558">    this(id, requester, requested);</span>
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">    if (ParametersChecker.isEmpty(owner)) {</span>
<span class="nc" id="L560">      pojo.setOwnerRequest(Configuration.configuration.getHostId());</span>
    } else {
<span class="fc" id="L562">      pojo.setOwnerRequest(owner);</span>
    }
<span class="fc" id="L564">    initializeTransferInfo();</span>
<span class="fc" id="L565">  }</span>

  /**
   * To create a new DbTaskRunner (specialId could be invalid) without making
   * any entry in the database
   *
   * @param source
   *
   * @throws WaarpDatabaseException
   */
<span class="fc" id="L575">  public DbTaskRunner(final ObjectNode source) throws WaarpDatabaseException {</span>
<span class="fc" id="L576">    pojo = new Transfer();</span>
<span class="fc" id="L577">    setFromJson(source, false);</span>
<span class="fc" id="L578">  }</span>

  private final void checkMapInfo() {
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">    if (getFileInformation() != null) {</span>
<span class="fc" id="L582">      setMapFromFileInfo();</span>
    } else {
<span class="nc" id="L584">      initializeTransferInfo();</span>
    }
<span class="fc" id="L586">  }</span>

  @Override
  public final void setFromJson(final ObjectNode source,
                                final boolean ignorePrimaryKey)
      throws WaarpDatabaseSqlException {
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">    if (pojo == null) {</span>
<span class="nc" id="L593">      pojo = new Transfer();</span>
    }
<span class="fc bfc" id="L595" title="All 2 branches covered.">    for (final Columns column : Columns.values()) {</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">      if (column == Columns.UPDATEDINFO) {</span>
<span class="fc" id="L597">        continue;</span>
      }
<span class="fc" id="L599">      final JsonNode item = source.get(column.name());</span>
<span class="pc bpc" id="L600" title="2 of 6 branches missed.">      if (item != null &amp;&amp; !item.isMissingNode() &amp;&amp; !item.isNull()) {</span>
<span class="pc bpc" id="L601" title="1 of 22 branches missed.">        switch (column) {</span>
          case BLOCKSZ:
<span class="fc" id="L603">            pojo.setBlockSize(item.asInt());</span>
<span class="fc" id="L604">            break;</span>
          case FILEINFO:
<span class="fc" id="L606">            pojo.setFileInfo(item.asText());</span>
<span class="fc" id="L607">            break;</span>
          case FILENAME:
<span class="fc" id="L609">            pojo.setFilename(item.asText());</span>
<span class="fc" id="L610">            break;</span>
          case GLOBALLASTSTEP:
<span class="fc" id="L612">            pojo.setLastGlobalStep(Transfer.TASKSTEP.valueOf(item.asInt()));</span>
<span class="fc" id="L613">            break;</span>
          case GLOBALSTEP:
<span class="fc" id="L615">            pojo.setGlobalStep(Transfer.TASKSTEP.valueOf(item.asInt()));</span>
<span class="fc" id="L616">            break;</span>
          case IDRULE:
<span class="fc" id="L618">            pojo.setRule(item.asText());</span>
<span class="fc" id="L619">            break;</span>
          case INFOSTATUS:
<span class="fc" id="L621">            pojo.setInfoStatus(ErrorCode.getFromCode(item.asText()));</span>
<span class="fc" id="L622">            break;</span>
          case ISMOVED:
<span class="fc" id="L624">            pojo.setIsMoved(item.asBoolean());</span>
<span class="fc" id="L625">            break;</span>
          case MODETRANS:
<span class="fc" id="L627">            pojo.setTransferMode(item.asInt());</span>
<span class="fc" id="L628">            break;</span>
          case ORIGINALNAME:
<span class="fc" id="L630">            pojo.setOriginalName(item.asText());</span>
<span class="fc" id="L631">            break;</span>
          case OWNERREQ:
<span class="fc" id="L633">            String owner = item.asText();</span>
<span class="pc bpc" id="L634" title="1 of 2 branches missed.">            if (ParametersChecker.isEmpty(owner)) {</span>
<span class="nc" id="L635">              owner = Configuration.configuration.getHostId();</span>
            }
<span class="fc" id="L637">            pojo.setOwnerRequest(owner);</span>
<span class="fc" id="L638">            break;</span>
          case RANK:
<span class="fc" id="L640">            pojo.setRank(item.asInt());</span>
<span class="fc" id="L641">            break;</span>
          case REQUESTED:
<span class="fc" id="L643">            pojo.setRequested(item.asText());</span>
<span class="fc" id="L644">            break;</span>
          case REQUESTER:
<span class="fc" id="L646">            pojo.setRequester(item.asText());</span>
<span class="fc" id="L647">            break;</span>
          case RETRIEVEMODE:
<span class="fc" id="L649">            pojo.setRetrieveMode(item.asBoolean());</span>
<span class="fc" id="L650">            break;</span>
          case SPECIALID:
<span class="fc" id="L652">            pojo.setId(item.asLong());</span>
<span class="fc" id="L653">            break;</span>
          case STARTTRANS:
<span class="fc" id="L655">            long start = item.asLong();</span>
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">            if (start == 0) {</span>
<span class="nc" id="L657">              start = System.currentTimeMillis();</span>
            }
<span class="fc" id="L659">            pojo.setStart(new Timestamp(start));</span>
<span class="fc" id="L660">            break;</span>
          case STEP:
<span class="fc" id="L662">            pojo.setStep(item.asInt());</span>
<span class="fc" id="L663">            break;</span>
          case STEPSTATUS:
<span class="fc" id="L665">            pojo.setStepStatus(ErrorCode.getFromCode(item.asText()));</span>
<span class="fc" id="L666">            break;</span>
          case STOPTRANS:
<span class="fc" id="L668">            long stop = item.asLong();</span>
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">            if (stop == 0) {</span>
<span class="nc" id="L670">              stop = System.currentTimeMillis();</span>
            }
<span class="fc" id="L672">            pojo.setStop(new Timestamp(stop));</span>
<span class="fc" id="L673">            break;</span>
          case TRANSFERINFO: {
<span class="fc" id="L675">            String text = item.asText().trim();</span>
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">            if (text.isEmpty()) {</span>
<span class="nc" id="L677">              text = &quot;{}&quot;;</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">              if (transferMap != null) {</span>
<span class="nc" id="L679">                transferMap.clear();</span>
              }
<span class="nc" id="L681">              transferMap = null;</span>
            }
<span class="fc" id="L683">            pojo.setTransferInfo(text);</span>
<span class="fc" id="L684">            break;</span>
          }
          default:
            break;
        }
      }
    }
<span class="fc" id="L691">    setMapFromFileInfo();</span>
<span class="fc" id="L692">    JsonNode node = source.path(JSON_RESCHEDULE);</span>
<span class="pc bpc" id="L693" title="1 of 4 branches missed.">    if (!node.isMissingNode() || !node.isNull()) {</span>
<span class="fc" id="L694">      rescheduledTransfer = node.asBoolean(false);</span>
    }
<span class="fc" id="L696">    node = source.path(JSON_THROUGHMODE);</span>
<span class="pc bpc" id="L697" title="1 of 4 branches missed.">    if (!node.isMissingNode() || !node.isNull()) {</span>
<span class="pc bpc" id="L698" title="1 of 2 branches missed.">      if (RequestPacket.isRecvMode(pojo.getTransferMode())) {</span>
<span class="fc" id="L699">        isRecvThrough = node.asBoolean();</span>
      } else {
<span class="nc" id="L701">        isSendThrough = node.asBoolean();</span>
      }
    }
<span class="fc" id="L704">    node = source.path(JSON_ORIGINALSIZE);</span>
<span class="pc bpc" id="L705" title="1 of 4 branches missed.">    if (!node.isMissingNode() || !node.isNull()) {</span>
<span class="fc" id="L706">      originalSize = node.asLong(getOriginalSizeTransferMap());</span>
    }
<span class="fc" id="L708">    isSaved = false;</span>
<span class="fc" id="L709">    isOtherThanStatus = true;</span>
    try {
<span class="fc" id="L711">      rule = new DbRule(getRuleId());</span>
<span class="nc" id="L712">    } catch (final WaarpDatabaseException e) {</span>
      // ignore
<span class="nc" id="L714">      rule = null;</span>
<span class="fc" id="L715">    }</span>
<span class="pc bpc" id="L716" title="1 of 2 branches missed.">    if (ParametersChecker.isEmpty(pojo.getFilename())) {</span>
<span class="nc" id="L717">      throw new WaarpDatabaseSqlException(</span>
          &quot;Cannot create a transfer without filename&quot;);
<span class="pc bpc" id="L719" title="1 of 2 branches missed.">    } else if (ParametersChecker.isEmpty(pojo.getRule())) {</span>
<span class="nc" id="L720">      throw new WaarpDatabaseSqlException(</span>
          &quot;Cannot create a transfer without rule&quot;);
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">    } else if (ParametersChecker.isEmpty(pojo.getOwnerRequest())) {</span>
<span class="nc" id="L723">      throw new WaarpDatabaseSqlException(</span>
          &quot;Cannot create a transfer without owner&quot;);
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">    } else if (ParametersChecker.isEmpty(pojo.getRequester())) {</span>
<span class="nc" id="L726">      throw new WaarpDatabaseSqlException(</span>
          &quot;Cannot create a transfer without requester&quot;);
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">    } else if (ParametersChecker.isEmpty(pojo.getRequested())) {</span>
<span class="nc" id="L729">      throw new WaarpDatabaseSqlException(</span>
          &quot;Cannot create a transfer without requested&quot;);
    }
<span class="fc" id="L732">    checkThroughMode();</span>
<span class="fc" id="L733">    checkValues();</span>
<span class="fc" id="L734">  }</span>

  /**
   * Constructor to initiate a request with a valid previous Special Id so
   * loaded from database.
   *
   * @param id
   * @param requested
   *
   * @throws WaarpDatabaseException
   */
  public DbTaskRunner(final long id, final String requested)
<span class="fc" id="L746">      throws WaarpDatabaseException {</span>
<span class="fc" id="L747">    TransferDAO transferAccess = null;</span>
    try {
<span class="fc" id="L749">      transferAccess = DAOFactory.getInstance().getTransferDAO();</span>
<span class="fc" id="L750">      final String requester = Configuration.configuration.getHostId(requested);</span>
<span class="fc" id="L751">      pojo = transferAccess.select(id, requester, requested,</span>
<span class="fc" id="L752">                                   Configuration.configuration.getHostId());</span>
<span class="fc" id="L753">      addMap();</span>
<span class="nc" id="L754">    } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L755">      throw new WaarpDatabaseException(e);</span>
<span class="fc" id="L756">    } catch (final DAONoDataException e) {</span>
<span class="fc" id="L757">      throw new WaarpDatabaseNoDataException(TRANSFER_NOT_FOUND, e);</span>
    } finally {
<span class="fc" id="L759">      DAOFactory.closeDAO(transferAccess);</span>
    }
<span class="fc" id="L761">    initializeTransferInfo();</span>
<span class="fc" id="L762">    checkThroughMode();</span>
<span class="fc" id="L763">    isSaved = true;</span>
<span class="fc" id="L764">    isOtherThanStatus = false;</span>
<span class="fc" id="L765">  }</span>

  @Override
  protected final void checkValues() throws WaarpDatabaseSqlException {
<span class="fc" id="L769">    pojo.checkValues();</span>
<span class="fc" id="L770">  }</span>

  /**
   * @return the condition to limit access to the row concerned by the Host
   */
  private static String getLimitWhereCondition() {
<span class="fc" id="L776">    return &quot; &quot; + Columns.OWNERREQ + &quot; = '&quot; +</span>
<span class="fc" id="L777">           Configuration.configuration.getHostId() + &quot;' &quot;;</span>
  }

  /**
   * To allow to remove specifically one SpecialId from MemoryHashmap
   *
   * @param specialId
   */
  public static void removeNoDbSpecialId(final long specialId) {
<span class="nc" id="L786">    XMLTransferDAO.removeNoDbSpecialId(specialId);</span>
<span class="nc" id="L787">  }</span>

  private void addMap() {
<span class="fc" id="L790">    dbR66TaskHashMap.put(pojo.getId(), Boolean.TRUE);</span>
<span class="fc" id="L791">  }</span>

  private boolean existMap() {
<span class="nc" id="L794">    return dbR66TaskHashMap.contains(pojo.getId());</span>
  }

  @Override
  public final boolean exist() throws WaarpDatabaseException {
<span class="nc bnc" id="L799" title="All 2 branches missed.">    if (existMap()) {</span>
<span class="nc" id="L800">      return true;</span>
    }
<span class="nc" id="L802">    TransferDAO transferAccess = null;</span>
    try {
<span class="nc" id="L804">      transferAccess = DAOFactory.getInstance().getTransferDAO();</span>
<span class="nc" id="L805">      return transferAccess.exist(pojo.getId(), pojo.getRequester(),</span>
<span class="nc" id="L806">                                  pojo.getRequested(),</span>
<span class="nc" id="L807">                                  Configuration.configuration.getHostId());</span>
<span class="nc" id="L808">    } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L809">      throw new WaarpDatabaseException(e);</span>
    } finally {
<span class="nc" id="L811">      DAOFactory.closeDAO(transferAccess);</span>
    }
  }

  /**
   * Shall be called to ensure that item is really available in database
   *
   * @return True iff the element exists in a database (and reloaded then from
   *     Database)
   *
   * @throws WaarpDatabaseException
   */
  public final boolean checkFromDbForSubmit() throws WaarpDatabaseException {
<span class="nc bnc" id="L824" title="All 2 branches missed.">    if (exist()) {</span>
<span class="nc" id="L825">      select();</span>
<span class="nc" id="L826">      rule = new DbRule(getRuleId());</span>
<span class="nc" id="L827">      return true;</span>
    }
<span class="nc" id="L829">    return false;</span>
  }

  @Override
  public final void select() throws WaarpDatabaseException {
<span class="fc" id="L834">    TransferDAO transferAccess = null;</span>
    try {
<span class="fc" id="L836">      transferAccess = DAOFactory.getInstance().getTransferDAO();</span>
<span class="fc" id="L837">      final boolean isSender = this.isSender();</span>
<span class="fc" id="L838">      pojo = transferAccess.select(pojo.getId(), pojo.getRequester(),</span>
<span class="fc" id="L839">                                   pojo.getRequested(),</span>
<span class="fc" id="L840">                                   Configuration.configuration.getHostId());</span>
<span class="fc" id="L841">      this.setSender(isSender);</span>
<span class="fc" id="L842">      transferMap.clear();</span>
<span class="fc" id="L843">      transferMap = null;</span>
<span class="fc" id="L844">      addMap();</span>
<span class="fc" id="L845">      isSaved = true;</span>
<span class="fc" id="L846">      isOtherThanStatus = false;</span>
<span class="nc" id="L847">    } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L848">      throw new WaarpDatabaseNoConnectionException(e);</span>
<span class="nc" id="L849">    } catch (final DAONoDataException e) {</span>
<span class="nc" id="L850">      throw new WaarpDatabaseNoDataException(TRANSFER_NOT_FOUND, e);</span>
    } finally {
<span class="fc" id="L852">      DAOFactory.closeDAO(transferAccess);</span>
    }
<span class="fc" id="L854">    rule = new DbRule(getRuleId());</span>
<span class="fc" id="L855">    initializeTransferInfo();</span>
<span class="fc" id="L856">    checkThroughMode();</span>
<span class="fc" id="L857">  }</span>

  private void checkSnmp() {
<span class="fc bfc" id="L860" title="All 2 branches covered.">    if (pojo.getUpdatedInfo().equals(UpdatedInfo.INERROR) ||</span>
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">        pojo.getUpdatedInfo().equals(UpdatedInfo.INTERRUPTED)) {</span>
<span class="pc bpc" id="L862" title="1 of 2 branches missed.">      if (Configuration.configuration.getR66Mib() != null) {</span>
<span class="nc" id="L863">        Configuration.configuration.getR66Mib().notifyInfoTask(</span>
<span class="nc" id="L864">            &quot;Task is &quot; + pojo.getUpdatedInfo().name(), this);</span>
      } else {
<span class="fc" id="L866">        logger.debug(&quot;Could send a SNMP trap here since {}&quot;,</span>
<span class="fc" id="L867">                     pojo.getUpdatedInfo());</span>
      }
    } else {
<span class="fc bfc" id="L870" title="All 2 branches covered.">      if (pojo.getGlobalStep() != Transfer.TASKSTEP.TRANSFERTASK ||</span>
<span class="pc bpc" id="L871" title="1 of 2 branches missed.">          pojo.getGlobalStep() == Transfer.TASKSTEP.TRANSFERTASK &amp;&amp;</span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">          pojo.getRank() % 100 == 0) {</span>
<span class="pc bpc" id="L873" title="1 of 2 branches missed.">        if (Configuration.configuration.getR66Mib() != null) {</span>
<span class="nc" id="L874">          Configuration.configuration.getR66Mib().notifyTask(</span>
<span class="nc" id="L875">              &quot;Task is currently &quot; + pojo.getUpdatedInfo().name(), this);</span>
        }
      }
    }
<span class="fc" id="L879">  }</span>

  @Override
  public final void insert() throws WaarpDatabaseException {
<span class="fc" id="L883">    final String nomap = pojo.getTransferInfo();</span>
<span class="fc" id="L884">    pojo.setTransferInfo(getTransferInfo());</span>
<span class="fc" id="L885">    super.insert();</span>
<span class="fc" id="L886">    addMap();</span>
<span class="fc" id="L887">    pojo.setTransferInfo(nomap);</span>
<span class="fc" id="L888">    isSaved = true;</span>
<span class="fc" id="L889">    isOtherThanStatus = false;</span>
<span class="fc" id="L890">  }</span>

  /**
   * Update Rank and Stop only
   *
   * @throws WaarpDatabaseException
   */
  public final void updateRank() throws WaarpDatabaseException {
    // SNMP notification
<span class="fc" id="L899">    checkSnmp();</span>
    // FIX SelfRequest
<span class="fc bfc" id="L901" title="All 2 branches covered.">    if (isSelfRequest()) {</span>
<span class="fc bfc" id="L902" title="All 2 branches covered.">      if (RequestPacket.isCompatibleMode(pojo.getTransferMode(),</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">                                         pojo.getRetrieveMode()?</span>
<span class="fc" id="L904">                                             RequestPacket.TRANSFERMODE.RECVMODE.ordinal() :</span>
<span class="fc" id="L905">                                             RequestPacket.TRANSFERMODE.SENDMODE.ordinal())) {</span>
<span class="pc bpc" id="L906" title="1 of 2 branches missed.">        if (isOtherThanStatus) {</span>
<span class="nc" id="L907">          optimizedUpdate();</span>
        } else {
<span class="fc" id="L909">          optimizedRankUpdate();</span>
        }
      }
    } else {
<span class="pc bpc" id="L913" title="1 of 2 branches missed.">      if (isOtherThanStatus) {</span>
<span class="nc" id="L914">        optimizedUpdate();</span>
      } else {
<span class="fc" id="L916">        optimizedRankUpdate();</span>
      }
    }
<span class="fc" id="L919">  }</span>

  /**
   * Update Runner using Rank (and stop) only update
   *
   * @throws WaarpDatabaseException
   */
  private void optimizedRankUpdate() throws WaarpDatabaseException {
<span class="fc" id="L927">    setStopNow();</span>
<span class="fc" id="L928">    TransferDAO transferAccess = null;</span>
    try {
<span class="fc" id="L930">      transferAccess = DAOFactory.getInstance().getTransferDAO();</span>
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">      if (transferAccess instanceof DBTransferDAO) {</span>
<span class="fc" id="L932">        ((DBTransferDAO) transferAccess).updateRank(pojo);</span>
      } else {
<span class="nc" id="L934">        final String nomap = pojo.getTransferInfo();</span>
<span class="nc" id="L935">        pojo.setTransferInfo(getTransferInfo());</span>
<span class="nc" id="L936">        transferAccess.update(pojo);</span>
<span class="nc" id="L937">        pojo.setTransferInfo(nomap);</span>
      }
<span class="fc" id="L939">      addMap();</span>
<span class="fc" id="L940">      isSaved = true;</span>
<span class="nc" id="L941">    } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L942">      throw new WaarpDatabaseException(e);</span>
<span class="nc" id="L943">    } catch (final DAONoDataException e) {</span>
<span class="nc" id="L944">      throw new WaarpDatabaseNoDataException(TRANSFER_NOT_FOUND, e);</span>
    } finally {
<span class="fc" id="L946">      DAOFactory.closeDAO(transferAccess);</span>
    }
<span class="fc" id="L948">  }</span>

  /**
   * Update Runner using Rank, stop, UpdatedInfo and StepStatus only update
   *
   * @throws WaarpDatabaseException
   */
  private void optimizedRankUpdatedInfoStepStatusUpdate()
      throws WaarpDatabaseException {
<span class="fc" id="L957">    TransferDAO transferAccess = null;</span>
    try {
<span class="fc" id="L959">      transferAccess = DAOFactory.getInstance().getTransferDAO();</span>
<span class="pc bpc" id="L960" title="1 of 2 branches missed.">      if (transferAccess instanceof DBTransferDAO) {</span>
<span class="fc" id="L961">        ((DBTransferDAO) transferAccess).updateRankUpdatedInfoStepStatusStop(</span>
            pojo);
      } else {
<span class="nc" id="L964">        final String nomap = pojo.getTransferInfo();</span>
<span class="nc" id="L965">        pojo.setTransferInfo(getTransferInfo());</span>
<span class="nc" id="L966">        transferAccess.update(pojo);</span>
<span class="nc" id="L967">        pojo.setTransferInfo(nomap);</span>
      }
<span class="fc" id="L969">      addMap();</span>
<span class="fc" id="L970">      isSaved = true;</span>
<span class="fc" id="L971">      isOtherThanStatus = false;</span>
<span class="fc" id="L972">    } catch (final DAOConnectionException e) {</span>
<span class="fc" id="L973">      throw new WaarpDatabaseException(e);</span>
<span class="nc" id="L974">    } catch (final DAONoDataException e) {</span>
<span class="nc" id="L975">      throw new WaarpDatabaseNoDataException(TRANSFER_NOT_FOUND, e);</span>
    } finally {
<span class="fc" id="L977">      DAOFactory.closeDAO(transferAccess);</span>
    }
<span class="fc" id="L979">  }</span>

  @Override
  public final void update() throws WaarpDatabaseException {
<span class="fc bfc" id="L983" title="All 2 branches covered.">    if (isSaved) {</span>
<span class="fc" id="L984">      return;</span>
    }
    // SNMP notification
<span class="fc" id="L987">    checkSnmp();</span>
    // FIX SelfRequest
<span class="fc bfc" id="L989" title="All 2 branches covered.">    if (isSelfRequest()) {</span>
<span class="fc bfc" id="L990" title="All 2 branches covered.">      if (RequestPacket.isCompatibleMode(pojo.getTransferMode(),</span>
<span class="fc bfc" id="L991" title="All 2 branches covered.">                                         pojo.getRetrieveMode()?</span>
<span class="fc" id="L992">                                             RequestPacket.TRANSFERMODE.RECVMODE.ordinal() :</span>
<span class="fc" id="L993">                                             RequestPacket.TRANSFERMODE.SENDMODE.ordinal())) {</span>
<span class="fc bfc" id="L994" title="All 2 branches covered.">        if (isOtherThanStatus) {</span>
<span class="fc" id="L995">          optimizedUpdate();</span>
        } else {
<span class="fc" id="L997">          optimizedRankUpdatedInfoStepStatusUpdate();</span>
        }
      }
    } else {
<span class="fc bfc" id="L1001" title="All 2 branches covered.">      if (isOtherThanStatus) {</span>
<span class="fc" id="L1002">        optimizedUpdate();</span>
      } else {
<span class="fc" id="L1004">        optimizedRankUpdatedInfoStepStatusUpdate();</span>
      }
    }
<span class="fc" id="L1007">  }</span>

  /**
   * Update Runner
   *
   * @throws WaarpDatabaseException
   */
  protected final void optimizedUpdate() throws WaarpDatabaseException {
<span class="fc" id="L1015">    setStopNow();</span>
<span class="fc" id="L1016">    checkValues();</span>
<span class="fc" id="L1017">    TransferDAO transferAccess = null;</span>
    try {
<span class="fc" id="L1019">      transferAccess = DAOFactory.getInstance().getTransferDAO();</span>
<span class="fc" id="L1020">      final String nomap = pojo.getTransferInfo();</span>
<span class="fc" id="L1021">      pojo.setTransferInfo(getTransferInfo());</span>
<span class="fc" id="L1022">      transferAccess.update(pojo);</span>
<span class="fc" id="L1023">      pojo.setTransferInfo(nomap);</span>
<span class="fc" id="L1024">      addMap();</span>
<span class="fc" id="L1025">      isSaved = true;</span>
<span class="fc" id="L1026">      isOtherThanStatus = false;</span>
<span class="nc" id="L1027">    } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L1028">      throw new WaarpDatabaseException(e);</span>
<span class="nc" id="L1029">    } catch (final DAONoDataException e) {</span>
<span class="nc" id="L1030">      throw new WaarpDatabaseNoDataException(TRANSFER_NOT_FOUND, e);</span>
    } finally {
<span class="fc" id="L1032">      DAOFactory.closeDAO(transferAccess);</span>
    }
<span class="fc" id="L1034">  }</span>

  @Override
  public final void delete() throws WaarpDatabaseException {
<span class="fc" id="L1038">    dbR66TaskHashMap.remove(pojo.getId());</span>
<span class="fc" id="L1039">    super.delete();</span>
<span class="fc" id="L1040">  }</span>

  public final void clean() {
    // ignore
<span class="fc" id="L1044">  }</span>

  /**
   * Special method used to force insert in case of SelfSubmit
   *
   * @throws WaarpDatabaseException
   */
  public final boolean specialSubmit() throws WaarpDatabaseException {
<span class="nc" id="L1052">    setStopNow();</span>
<span class="nc" id="L1053">    insert();</span>
<span class="nc" id="L1054">    return false;</span>
  }

  /**
   * Partial set from another runner (infostatus, rank, status, step, stop,
   * filename, globallastep, globalstep,
   * isFileMoved)
   *
   * @param runner
   */
  public final void setFrom(final DbTaskRunner runner) {
<span class="nc bnc" id="L1065" title="All 2 branches missed.">    if (runner != null) {</span>
<span class="nc" id="L1066">      pojo.setInfoStatus(runner.getErrorInfo());</span>
<span class="nc" id="L1067">      pojo.setRank(runner.getRank());</span>
<span class="nc" id="L1068">      pojo.setStepStatus(runner.getStatus());</span>
<span class="nc" id="L1069">      pojo.setStep(runner.getStep());</span>
<span class="nc" id="L1070">      pojo.setStop(runner.getStop());</span>
<span class="nc" id="L1071">      pojo.setFilename(runner.getFilename());</span>
<span class="nc" id="L1072">      pojo.setGlobalStep(runner.pojo.getGlobalStep());</span>
<span class="nc" id="L1073">      pojo.setLastGlobalStep(runner.pojo.getLastGlobalStep());</span>
<span class="nc" id="L1074">      pojo.setIsMoved(runner.isFileMoved());</span>
<span class="nc" id="L1075">      isOtherThanStatus = true;</span>
<span class="nc" id="L1076">      isSaved = false;</span>
    }
<span class="nc" id="L1078">  }</span>

  public final boolean isRecvThrough() {
<span class="fc" id="L1081">    return isRecvThrough;</span>
  }

  public final boolean isSendThrough() {
<span class="fc" id="L1085">    return isSendThrough;</span>
  }

  /**
   * Private constructor for Commander only
   */
<span class="fc" id="L1091">  private DbTaskRunner() {</span>
<span class="fc" id="L1092">    pojo = new Transfer();</span>
<span class="fc" id="L1093">    session = null;</span>
<span class="fc" id="L1094">    rule = null;</span>
<span class="fc" id="L1095">  }</span>

  /**
   * Set a localChannelReference
   *
   * @param localChannelReference
   */
  public final void setLocalChannelReference(
      final LocalChannelReference localChannelReference) {
<span class="fc" id="L1104">    this.localChannelReference = localChannelReference;</span>
<span class="fc" id="L1105">  }</span>

  /**
   * @return the localChannelReference
   */
  public final LocalChannelReference getLocalChannelReference() {
<span class="nc" id="L1111">    return localChannelReference;</span>
  }

  /**
   * For instance from Commander when getting updated information
   *
   * @param preparedStatement
   *
   * @return the next updated DbTaskRunner
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   */
  public static DbTaskRunner getFromStatement(
      final DbPreparedStatement preparedStatement)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
<span class="fc" id="L1127">    final DbTaskRunner dbTaskRunner = new DbTaskRunner();</span>
<span class="fc" id="L1128">    AbstractDAO&lt;Transfer&gt; transferDAO = null;</span>
    try {
<span class="fc" id="L1130">      transferDAO = dbTaskRunner.getDao(false);</span>
<span class="fc" id="L1131">      dbTaskRunner.pojo =</span>
<span class="fc" id="L1132">          ((StatementExecutor&lt;Transfer&gt;) transferDAO).getFromResultSet(</span>
<span class="fc" id="L1133">              preparedStatement.getResultSet());</span>
<span class="pc bpc" id="L1134" title="2 of 4 branches missed.">      if (dbTaskRunner.rule == null &amp;&amp; dbTaskRunner.pojo.getRule() != null) {</span>
        try {
<span class="fc" id="L1136">          dbTaskRunner.rule = new DbRule(dbTaskRunner.getRuleId());</span>
<span class="nc" id="L1137">        } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L1138">          throw new WaarpDatabaseSqlException(</span>
<span class="nc" id="L1139">              &quot;Rule cannot be found for DbTaskRunner: &quot; + dbTaskRunner.asJson(),</span>
              e);
<span class="fc" id="L1141">        }</span>
      }
<span class="fc" id="L1143">      dbTaskRunner.initializeTransferInfo();</span>
<span class="fc" id="L1144">      dbTaskRunner.checkThroughMode();</span>
<span class="fc" id="L1145">      return dbTaskRunner;</span>
<span class="nc" id="L1146">    } catch (final SQLException e) {</span>
<span class="nc" id="L1147">      DbConstant.error(e);</span>
<span class="nc" id="L1148">      throw new WaarpDatabaseSqlException(GETTING_VALUES_IN_ERROR, e);</span>
<span class="nc" id="L1149">    } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L1150">      throw new WaarpDatabaseSqlException(GETTING_VALUES_IN_ERROR, e);</span>
    } finally {
<span class="fc" id="L1152">      DAOFactory.closeDAO(transferDAO);</span>
    }
  }

  /**
   * For instance from Commander when getting updated information
   * &lt;p&gt;&lt;/p&gt;
   * &lt;p&gt;This version tries to load DbRule but will not make any error if not found!&lt;/p&gt;
   *
   * @param preparedStatement
   *
   * @return the next updated DbTaskRunner
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   */
  public static DbTaskRunner getFromStatementNoRule(
      final DbPreparedStatement preparedStatement)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
<span class="fc" id="L1171">    final DbTaskRunner dbTaskRunner = new DbTaskRunner();</span>
<span class="fc" id="L1172">    AbstractDAO&lt;Transfer&gt; transferDAO = null;</span>
    try {
<span class="fc" id="L1174">      transferDAO = dbTaskRunner.getDao(false);</span>
<span class="fc" id="L1175">      dbTaskRunner.pojo =</span>
<span class="fc" id="L1176">          ((StatementExecutor&lt;Transfer&gt;) transferDAO).getFromResultSet(</span>
<span class="fc" id="L1177">              preparedStatement.getResultSet());</span>
<span class="pc bpc" id="L1178" title="2 of 4 branches missed.">      if (dbTaskRunner.rule == null &amp;&amp; dbTaskRunner.pojo.getRule() != null) {</span>
        try {
<span class="fc" id="L1180">          dbTaskRunner.rule = new DbRule(dbTaskRunner.getRuleId());</span>
<span class="nc" id="L1181">        } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L1182">          logger.warn(&quot;Rule cannot be found for DbTaskRunner: &quot; +</span>
<span class="nc" id="L1183">                      dbTaskRunner.asJson() + &quot; : {}&quot;, e.getMessage());</span>
<span class="fc" id="L1184">        }</span>
      }
<span class="fc" id="L1186">      dbTaskRunner.initializeTransferInfo();</span>
<span class="fc" id="L1187">      dbTaskRunner.checkThroughMode();</span>
<span class="fc" id="L1188">      return dbTaskRunner;</span>
<span class="nc" id="L1189">    } catch (final SQLException e) {</span>
<span class="nc" id="L1190">      DbConstant.error(e);</span>
<span class="nc" id="L1191">      throw new WaarpDatabaseSqlException(GETTING_VALUES_IN_ERROR, e);</span>
<span class="nc" id="L1192">    } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L1193">      throw new WaarpDatabaseSqlException(GETTING_VALUES_IN_ERROR, e);</span>
    } finally {
<span class="fc" id="L1195">      DAOFactory.closeDAO(transferDAO);</span>
    }
  }

  /**
   * For REST interface, to prevent DbRule issue
   *
   * @param preparedStatement
   *
   * @return the next updated DbTaskRunner
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   */
  public static DbTaskRunner getFromStatementNoDbRule(
      final DbPreparedStatement preparedStatement)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
<span class="nc" id="L1212">    final DbTaskRunner dbTaskRunner = new DbTaskRunner();</span>
<span class="nc" id="L1213">    AbstractDAO&lt;Transfer&gt; transferDAO = null;</span>
    try {
<span class="nc" id="L1215">      transferDAO = dbTaskRunner.getDao(false);</span>
<span class="nc" id="L1216">      dbTaskRunner.pojo =</span>
<span class="nc" id="L1217">          ((StatementExecutor&lt;Transfer&gt;) transferDAO).getFromResultSet(</span>
<span class="nc" id="L1218">              preparedStatement.getResultSet());</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">      if (dbTaskRunner.rule == null) {</span>
        try {
<span class="nc" id="L1221">          dbTaskRunner.rule = new DbRule(dbTaskRunner.getRuleId());</span>
<span class="nc" id="L1222">        } catch (final WaarpDatabaseNoDataException e) {</span>
          // ignore
<span class="nc" id="L1224">        } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L1225">          throw new WaarpDatabaseSqlException(e);</span>
<span class="nc" id="L1226">        }</span>
      }
<span class="nc" id="L1228">      dbTaskRunner.initializeTransferInfo();</span>
<span class="nc" id="L1229">      dbTaskRunner.checkThroughMode();</span>
<span class="nc" id="L1230">      return dbTaskRunner;</span>
<span class="nc" id="L1231">    } catch (final SQLException e) {</span>
<span class="nc" id="L1232">      DbConstant.error(e);</span>
<span class="nc" id="L1233">      throw new WaarpDatabaseSqlException(GETTING_VALUES_IN_ERROR, e);</span>
<span class="nc" id="L1234">    } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L1235">      throw new WaarpDatabaseSqlException(GETTING_VALUES_IN_ERROR, e);</span>
    } finally {
<span class="nc" id="L1237">      DAOFactory.closeDAO(transferDAO);</span>
    }
  }

  /**
   * @param preparedStatement
   * @param srcrequest
   * @param limit
   * @param orderby
   * @param startid
   * @param stopid
   * @param start
   * @param stop
   * @param rule
   * @param req
   * @param pending
   * @param transfer
   * @param error
   * @param done
   * @param all
   *
   * @return The DbPreparedStatement already prepared according to select or
   *     delete command
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   */
  private static void getFilterCondition(
      final DbPreparedStatement preparedStatement, final String srcrequest,
      final int limit, final String whereCond, final String orderby,
      final String startid, final String stopid, final Timestamp start,
      final Timestamp stop, final String rule, final String req,
      final boolean pending, final boolean transfer, final boolean error,
      final boolean done, final boolean all)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
<span class="fc" id="L1272">    String request = srcrequest;</span>
<span class="fc bfc" id="L1273" title="All 2 branches covered.">    if (ParametersChecker.isEmpty(startid) &amp;&amp;</span>
<span class="fc bfc" id="L1274" title="All 6 branches covered.">        ParametersChecker.isEmpty(stopid) &amp;&amp; start == null &amp;&amp; stop == null &amp;&amp;</span>
<span class="pc bpc" id="L1275" title="2 of 6 branches missed.">        ParametersChecker.isEmpty(rule) &amp;&amp; ParametersChecker.isEmpty(req) &amp;&amp;</span>
        all) {
      // finish
<span class="pc bpc" id="L1278" title="1 of 2 branches missed.">      if (ParametersChecker.isNotEmpty(whereCond)) {</span>
<span class="fc" id="L1279">        request += &quot; WHERE &quot; + whereCond + orderby;</span>
      }
<span class="pc bpc" id="L1281" title="1 of 2 branches missed.">      if (limit &gt; 0) {</span>
<span class="fc" id="L1282">        request = preparedStatement.getDbSession().getAdmin().getDbModel()</span>
<span class="fc" id="L1283">                                   .limitRequest(selectAllFields, request,</span>
                                                 limit);
      }
<span class="fc" id="L1286">      preparedStatement.createPrepareStatement(request);</span>
<span class="fc" id="L1287">      return;</span>
    }
<span class="fc" id="L1289">    request += &quot; WHERE &quot;;</span>
<span class="fc" id="L1290">    final StringBuilder scondition = new StringBuilder(whereCond);</span>
<span class="fc" id="L1291">    boolean hasCondition = ParametersChecker.isNotEmpty(whereCond);</span>
<span class="pc bpc" id="L1292" title="1 of 4 branches missed.">    if (start != null &amp;&amp; stop != null) {</span>
<span class="pc bpc" id="L1293" title="1 of 2 branches missed.">      if (hasCondition) {</span>
<span class="fc" id="L1294">        scondition.append(AND);</span>
      }
<span class="fc" id="L1296">      scondition.append(Columns.STARTTRANS.name()).append(&quot; BETWEEN ? AND ? &quot;);</span>
<span class="fc" id="L1297">      hasCondition = true;</span>
<span class="pc bpc" id="L1298" title="1 of 2 branches missed.">    } else if (start != null) {</span>
<span class="nc bnc" id="L1299" title="All 2 branches missed.">      if (hasCondition) {</span>
<span class="nc" id="L1300">        scondition.append(AND);</span>
      }
<span class="nc" id="L1302">      scondition.append(Columns.STARTTRANS.name()).append(&quot; &gt;= ? &quot;);</span>
<span class="nc" id="L1303">      hasCondition = true;</span>
<span class="fc bfc" id="L1304" title="All 2 branches covered.">    } else if (stop != null) {</span>
<span class="pc bpc" id="L1305" title="1 of 2 branches missed.">      if (hasCondition) {</span>
<span class="fc" id="L1306">        scondition.append(AND);</span>
      }
<span class="fc" id="L1308">      scondition.append(Columns.STARTTRANS.name()).append(&quot; &lt;= ? &quot;);</span>
<span class="fc" id="L1309">      hasCondition = true;</span>
    }
<span class="fc bfc" id="L1311" title="All 2 branches covered.">    if (ParametersChecker.isNotEmpty(startid, stopid)) {</span>
<span class="pc bpc" id="L1312" title="1 of 2 branches missed.">      if (hasCondition) {</span>
<span class="fc" id="L1313">        scondition.append(AND);</span>
      }
<span class="fc" id="L1315">      hasCondition = true;</span>
<span class="fc" id="L1316">      scondition.append(Columns.SPECIALID.name()).append(&quot; BETWEEN ? AND ? &quot;);</span>
<span class="pc bpc" id="L1317" title="1 of 2 branches missed.">    } else if (ParametersChecker.isNotEmpty(startid)) {</span>
<span class="nc bnc" id="L1318" title="All 2 branches missed.">      if (hasCondition) {</span>
<span class="nc" id="L1319">        scondition.append(AND);</span>
      }
<span class="nc" id="L1321">      hasCondition = true;</span>
<span class="nc" id="L1322">      scondition.append(Columns.SPECIALID.name()).append(&quot; &gt;= ? &quot;);</span>
<span class="fc bfc" id="L1323" title="All 2 branches covered.">    } else if (ParametersChecker.isNotEmpty(stopid)) {</span>
<span class="pc bpc" id="L1324" title="1 of 2 branches missed.">      if (hasCondition) {</span>
<span class="fc" id="L1325">        scondition.append(AND);</span>
      }
<span class="fc" id="L1327">      hasCondition = true;</span>
<span class="fc" id="L1328">      scondition.append(Columns.SPECIALID.name()).append(&quot; &lt;= ? &quot;);</span>
    }
<span class="fc bfc" id="L1330" title="All 2 branches covered.">    if (ParametersChecker.isNotEmpty(rule)) {</span>
<span class="pc bpc" id="L1331" title="1 of 2 branches missed.">      if (hasCondition) {</span>
<span class="fc" id="L1332">        scondition.append(AND);</span>
      }
<span class="fc" id="L1334">      hasCondition = true;</span>
<span class="fc" id="L1335">      scondition.append(Columns.IDRULE.name()).append(&quot; = '&quot;).append(rule)</span>
<span class="fc" id="L1336">                .append(&quot;' &quot;);</span>
    }
<span class="fc bfc" id="L1338" title="All 2 branches covered.">    if (!all) {</span>
<span class="pc bpc" id="L1339" title="1 of 2 branches missed.">      if (hasCondition) {</span>
<span class="fc" id="L1340">        scondition.append(AND);</span>
      }
<span class="fc" id="L1342">      hasCondition = true;</span>
<span class="fc" id="L1343">      scondition.append(&quot;( &quot;);</span>
<span class="fc" id="L1344">      List&lt;Integer&gt; upds = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L1345">      List&lt;Integer&gt; gss = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L1346">      boolean hasone = false;</span>
<span class="fc bfc" id="L1347" title="All 2 branches covered.">      if (pending) {</span>
<span class="fc" id="L1348">        upds.add(UpdatedInfo.TOSUBMIT.ordinal());</span>
<span class="fc" id="L1349">        hasone = true;</span>
      }
<span class="fc bfc" id="L1351" title="All 2 branches covered.">      if (transfer) {</span>
<span class="fc" id="L1352">        upds.add(UpdatedInfo.RUNNING.ordinal());</span>
<span class="fc" id="L1353">        hasone = true;</span>
      }
<span class="fc bfc" id="L1355" title="All 2 branches covered.">      if (error) {</span>
<span class="fc" id="L1356">        upds.add(UpdatedInfo.INERROR.ordinal());</span>
<span class="fc" id="L1357">        upds.add(UpdatedInfo.INTERRUPTED.ordinal());</span>
<span class="fc" id="L1358">        gss.add(TASKSTEP.ERRORTASK.ordinal());</span>
<span class="fc" id="L1359">        hasone = true;</span>
      }
<span class="fc bfc" id="L1361" title="All 2 branches covered.">      if (done) {</span>
<span class="fc" id="L1362">        upds.add(UpdatedInfo.DONE.ordinal());</span>
<span class="fc" id="L1363">        gss.add(TASKSTEP.ALLDONETASK.ordinal());</span>
<span class="fc" id="L1364">        hasone = true;</span>
      }
<span class="fc bfc" id="L1366" title="All 2 branches covered.">      if (!hasone) {</span>
<span class="fc" id="L1367">        scondition.append(Columns.UPDATEDINFO.name()).append(&quot; IS NOT NULL &quot;);</span>
      } else {
<span class="pc bpc" id="L1369" title="1 of 2 branches missed.">        if (!upds.isEmpty()) {</span>
<span class="fc bfc" id="L1370" title="All 2 branches covered.">          if (upds.size() == 1) {</span>
<span class="fc" id="L1371">            scondition.append(Columns.UPDATEDINFO.name()).append(&quot; = &quot;)</span>
<span class="fc" id="L1372">                      .append(upds.get(0).toString());</span>
          } else {
<span class="fc" id="L1374">            scondition.append(Columns.UPDATEDINFO.name()).append(&quot; IN(&quot;);</span>
<span class="fc bfc" id="L1375" title="All 2 branches covered.">            for (int rank = 0; rank &lt; upds.size() - 1; rank++) {</span>
<span class="fc" id="L1376">              scondition.append(upds.get(rank).toString()).append(&quot;, &quot;);</span>
            }
<span class="fc" id="L1378">            scondition.append(upds.get(upds.size() - 1).toString()).append(&quot;)&quot;);</span>
          }
<span class="fc" id="L1380">          upds.clear();</span>
<span class="fc bfc" id="L1381" title="All 2 branches covered.">          if (!gss.isEmpty()) {</span>
<span class="fc" id="L1382">            scondition.append(&quot; OR &quot;);</span>
          }
        }
<span class="fc bfc" id="L1385" title="All 2 branches covered.">        if (!gss.isEmpty()) {</span>
<span class="fc bfc" id="L1386" title="All 2 branches covered.">          if (gss.size() == 1) {</span>
<span class="fc" id="L1387">            scondition.append(Columns.GLOBALSTEP.name()).append(&quot; = &quot;)</span>
<span class="fc" id="L1388">                      .append(gss.get(0).toString());</span>
          } else {
<span class="fc" id="L1390">            scondition.append(Columns.GLOBALSTEP.name()).append(&quot; IN(&quot;);</span>
<span class="fc bfc" id="L1391" title="All 2 branches covered.">            for (int rank = 0; rank &lt; gss.size() - 1; rank++) {</span>
<span class="fc" id="L1392">              scondition.append(gss.get(rank).toString()).append(&quot;, &quot;);</span>
            }
<span class="fc" id="L1394">            scondition.append(gss.get(gss.size() - 1).toString()).append(&quot;)&quot;);</span>
          }
<span class="fc" id="L1396">          gss.clear();</span>
        }
      }
<span class="fc" id="L1399">      scondition.append(&quot;) &quot;);</span>
    }
<span class="fc bfc" id="L1401" title="All 2 branches covered.">    if (ParametersChecker.isNotEmpty(req)) {</span>
<span class="pc bpc" id="L1402" title="1 of 2 branches missed.">      if (hasCondition) {</span>
<span class="fc" id="L1403">        scondition.append(AND);</span>
      }
<span class="fc" id="L1405">      hasCondition = true;</span>
<span class="fc" id="L1406">      scondition.append(&quot;( &quot;).append(Columns.REQUESTED.name()).append(&quot; = '&quot;)</span>
<span class="fc" id="L1407">                .append(req).append(&quot;' OR &quot;).append(Columns.REQUESTER.name())</span>
<span class="fc" id="L1408">                .append(&quot; = '&quot;).append(req).append(&quot;' )&quot;);</span>
    }
<span class="fc bfc" id="L1410" title="All 2 branches covered.">    if (limit &gt; 0) {</span>
<span class="fc" id="L1411">      scondition.insert(0, request).append(orderby);</span>
<span class="fc" id="L1412">      request = scondition.toString();</span>
<span class="fc" id="L1413">      request = preparedStatement.getDbSession().getAdmin().getDbModel()</span>
<span class="fc" id="L1414">                                 .limitRequest(selectAllFields, request, limit);</span>
    } else {
<span class="fc" id="L1416">      scondition.insert(0, request).append(orderby);</span>
<span class="fc" id="L1417">      request = scondition.toString();</span>
    }
<span class="fc" id="L1419">    preparedStatement.createPrepareStatement(request);</span>
<span class="fc" id="L1420">    int rank = 1;</span>
    try {
<span class="pc bpc" id="L1422" title="1 of 4 branches missed.">      if (start != null &amp;&amp; stop != null) {</span>
<span class="fc" id="L1423">        preparedStatement.getPreparedStatement().setTimestamp(rank, start);</span>
<span class="fc" id="L1424">        rank++;</span>
<span class="fc" id="L1425">        preparedStatement.getPreparedStatement().setTimestamp(rank, stop);</span>
<span class="fc" id="L1426">        rank++;</span>
<span class="pc bpc" id="L1427" title="1 of 2 branches missed.">      } else if (start != null) {</span>
<span class="nc" id="L1428">        preparedStatement.getPreparedStatement().setTimestamp(rank, start);</span>
<span class="nc" id="L1429">        rank++;</span>
<span class="fc bfc" id="L1430" title="All 2 branches covered.">      } else if (stop != null) {</span>
<span class="fc" id="L1431">        preparedStatement.getPreparedStatement().setTimestamp(rank, stop);</span>
<span class="fc" id="L1432">        rank++;</span>
      }
<span class="fc bfc" id="L1434" title="All 2 branches covered.">      if (ParametersChecker.isNotEmpty(startid)) {</span>
<span class="fc" id="L1435">        long value = ILLEGALVALUE;</span>
        try {
<span class="fc" id="L1437">          value = Long.parseLong(startid);</span>
<span class="nc" id="L1438">        } catch (final NumberFormatException e) {</span>
          // ignore then
<span class="fc" id="L1440">        }</span>
<span class="fc" id="L1441">        preparedStatement.getPreparedStatement().setLong(rank, value);</span>
<span class="fc" id="L1442">        rank++;</span>
      }
<span class="fc bfc" id="L1444" title="All 2 branches covered.">      if (ParametersChecker.isNotEmpty(stopid)) {</span>
<span class="fc" id="L1445">        long value = Long.MAX_VALUE;</span>
        try {
<span class="fc" id="L1447">          value = Long.parseLong(stopid);</span>
<span class="nc" id="L1448">        } catch (final NumberFormatException e) {</span>
          // ignore then
<span class="fc" id="L1450">        }</span>
<span class="fc" id="L1451">        preparedStatement.getPreparedStatement().setLong(rank, value);</span>
      }
<span class="nc" id="L1453">    } catch (final SQLException e) {</span>
<span class="nc" id="L1454">      preparedStatement.realClose();</span>
<span class="nc" id="L1455">      throw new WaarpDatabaseSqlException(e);</span>
<span class="fc" id="L1456">    }</span>
<span class="fc" id="L1457">  }</span>

  /**
   * @param session
   * @param limit
   * @param orderBySpecialId
   * @param startid
   * @param stopid
   * @param start
   * @param stop
   * @param rule
   * @param req
   * @param pending
   * @param transfer
   * @param error
   * @param done
   * @param all
   *
   * @return the DbPreparedStatement according to the filter
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   */
  public static DbPreparedStatement getFilterPrepareStatement(
      final DbSession session, final int limit, final boolean orderBySpecialId,
      final String startid, final String stopid, final Timestamp start,
      final Timestamp stop, final String rule, final String req,
      final boolean pending, final boolean transfer, final boolean error,
      final boolean done, final boolean all)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
<span class="fc" id="L1487">    return getFilterPrepareStatement(session, limit, orderBySpecialId, startid,</span>
                                     stopid, start, stop, rule, req, pending,
                                     transfer, error, done, all, null);
  }

  /**
   * @param session
   * @param limit
   * @param orderBySpecialId
   * @param startid
   * @param stopid
   * @param start
   * @param stop
   * @param rule
   * @param req
   * @param pending
   * @param transfer
   * @param error
   * @param done
   * @param all
   * @param owner
   *
   * @return the DbPreparedStatement according to the filter
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   */
  public static DbPreparedStatement getFilterPrepareStatement(
      final DbSession session, final int limit, final boolean orderBySpecialId,
      final String startid, final String stopid, final Timestamp start,
      final Timestamp stop, final String rule, final String req,
      final boolean pending, final boolean transfer, final boolean error,
      final boolean done, final boolean all, final String owner)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
<span class="fc" id="L1521">    final DbPreparedStatement preparedStatement =</span>
        new DbPreparedStatement(session);
<span class="fc" id="L1523">    final String request = &quot;SELECT &quot; + selectAllFields + &quot; FROM &quot; + table;</span>
<span class="fc" id="L1524">    String whereCond = &quot;&quot;;</span>
<span class="fc" id="L1525">    String orderby = &quot;&quot;;</span>
<span class="fc bfc" id="L1526" title="All 2 branches covered.">    if (ParametersChecker.isEmpty(owner)) {</span>
<span class="fc" id="L1527">      whereCond = getLimitWhereCondition();</span>
<span class="pc bpc" id="L1528" title="1 of 2 branches missed.">    } else if (!&quot;*&quot;.equals(owner)) {</span>
<span class="fc" id="L1529">      whereCond = Columns.OWNERREQ + &quot; = '&quot; + owner + &quot;' &quot;;</span>
    }
<span class="fc bfc" id="L1531" title="All 2 branches covered.">    if (orderBySpecialId) {</span>
<span class="fc" id="L1532">      orderby = &quot; ORDER BY &quot; + Columns.SPECIALID.name() + &quot; DESC &quot;;</span>
    } else {
<span class="fc" id="L1534">      orderby = &quot; ORDER BY &quot; + Columns.STARTTRANS.name() + &quot; DESC &quot;;</span>
    }
<span class="fc" id="L1536">    getFilterCondition(preparedStatement, request, limit, whereCond, orderby,</span>
                       startid, stopid, start, stop, rule, req, pending,
                       transfer, error, done, all);
<span class="fc" id="L1539">    return preparedStatement;</span>
  }

  /**
   * @param followId the followId to find
   *
   * @return the associated Filter
   */
  public static Filter getFollowIdFilter(final String followId) {
<span class="fc" id="L1548">    return new Filter(DBTransferDAO.TRANSFER_INFO_FIELD, Filter.LIKE,</span>
                      &quot;%&quot; + FOLLOW_ID_LIKE + followId + &quot;%&quot;);
  }

  /**
   * @return the Filter on current Owner
   */
  public static Filter getOwnerFilter() {
<span class="fc" id="L1556">    return new Filter(DBTransferDAO.OWNER_REQUEST_FIELD, &quot;=&quot;,</span>
<span class="fc" id="L1557">                      Configuration.configuration.getHostId());</span>
  }

  /**
   * @param followId the followId to find
   * @param orderByStart If true, sort on Start ; If false, does not
   *     set the order on start
   * @param limit the limit of items
   * @param allOwner if admin role, can resolve for all Owners
   *
   * @return the DbPreparedStatement for getting Updated Object
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   */
  public static DbTaskRunner[] getSelectSameFollowId(final String followId,
                                                     final boolean orderByStart,
                                                     final int limit,
                                                     final boolean allOwner)
      throws WaarpDatabaseNoConnectionException {
<span class="fc" id="L1577">    final List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;(2);</span>
<span class="fc" id="L1578">    filters.add(getFollowIdFilter(followId));</span>
<span class="fc bfc" id="L1579" title="All 2 branches covered.">    if (!allOwner) {</span>
<span class="fc" id="L1580">      filters.add(new Filter(Columns.OWNERREQ.toString(), &quot;=&quot;,</span>
<span class="fc" id="L1581">                             Configuration.configuration.getHostId()));</span>
    }
<span class="fc" id="L1583">    TransferDAO transferAccess = null;</span>
    List&lt;Transfer&gt; transfers;
    try {
<span class="fc" id="L1586">      transferAccess = DAOFactory.getInstance().getTransferDAO();</span>
<span class="fc bfc" id="L1587" title="All 2 branches covered.">      if (orderByStart) {</span>
<span class="fc" id="L1588">        transfers =</span>
<span class="fc" id="L1589">            transferAccess.find(filters, DBTransferDAO.TRANSFER_START_FIELD,</span>
                                true, limit);
      } else {
<span class="fc" id="L1592">        transfers = transferAccess.find(filters, limit);</span>
      }
<span class="nc" id="L1594">    } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L1595">      throw new WaarpDatabaseNoConnectionException(e);</span>
    } finally {
<span class="fc" id="L1597">      DAOFactory.closeDAO(transferAccess);</span>
    }
<span class="fc" id="L1599">    final DbTaskRunner[] res = new DbTaskRunner[transfers.size()];</span>
<span class="fc" id="L1600">    int i = 0;</span>
<span class="fc bfc" id="L1601" title="All 2 branches covered.">    for (final Transfer transfer : transfers) {</span>
<span class="fc" id="L1602">      res[i] = new DbTaskRunner(transfer);</span>
<span class="fc" id="L1603">      i++;</span>
<span class="fc" id="L1604">    }</span>
<span class="fc" id="L1605">    return res;</span>
  }

  /**
   * @param info
   * @param orderByStart If true, sort on Start ; If false, does not
   *     set the limit on start
   * @param limit
   *
   * @return the DbPreparedStatement for getting Updated Object
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   */
  public static DbTaskRunner[] getSelectFromInfoPrepareStatement(
      final UpdatedInfo info, final boolean orderByStart, final int limit)
      throws WaarpDatabaseNoConnectionException {
<span class="fc" id="L1622">    final List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;(3);</span>
<span class="fc" id="L1623">    filters.add(getOwnerFilter());</span>
<span class="fc" id="L1624">    filters.add(new Filter(DBTransferDAO.TRANSFER_START_FIELD, &quot;&lt;=&quot;,</span>
<span class="fc" id="L1625">                           new Timestamp(System.currentTimeMillis())));</span>
<span class="fc" id="L1626">    filters.add(new Filter(DBTransferDAO.UPDATED_INFO_FIELD, &quot;=&quot;,</span>
<span class="fc" id="L1627">                           org.waarp.openr66.pojo.UpdatedInfo.fromLegacy(info)</span>
<span class="fc" id="L1628">                                                             .ordinal()));</span>
<span class="fc" id="L1629">    TransferDAO transferAccess = null;</span>
    List&lt;Transfer&gt; transfers;
    try {
<span class="fc" id="L1632">      transferAccess = DAOFactory.getInstance().getTransferDAO();</span>
<span class="pc bpc" id="L1633" title="1 of 2 branches missed.">      if (orderByStart) {</span>
<span class="fc" id="L1634">        transfers =</span>
<span class="fc" id="L1635">            transferAccess.find(filters, DBTransferDAO.TRANSFER_START_FIELD,</span>
                                true, limit);
      } else {
<span class="nc" id="L1638">        transfers = transferAccess.find(filters, limit);</span>
      }
<span class="nc" id="L1640">    } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L1641">      throw new WaarpDatabaseNoConnectionException(e);</span>
    } finally {
<span class="fc" id="L1643">      DAOFactory.closeDAO(transferAccess);</span>
    }
<span class="fc" id="L1645">    final DbTaskRunner[] res = new DbTaskRunner[transfers.size()];</span>
<span class="fc" id="L1646">    int i = 0;</span>
<span class="fc bfc" id="L1647" title="All 2 branches covered.">    for (final Transfer transfer : transfers) {</span>
<span class="fc" id="L1648">      res[i] = new DbTaskRunner(transfer);</span>
<span class="fc" id="L1649">      i++;</span>
<span class="fc" id="L1650">    }</span>
<span class="fc" id="L1651">    return res;</span>
  }

  /**
   * @param session
   *
   * @return the DbPreparedStatement for getting Updated Object
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   */
  public static DbPreparedStatement getCountInfoPrepareStatement(
      final DbSession session)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
<span class="fc" id="L1665">    final String request =</span>
<span class="fc" id="L1666">        SELECT_COUNT + Columns.SPECIALID.name() + &quot;) FROM &quot; + table +</span>
<span class="fc" id="L1667">        &quot; WHERE &quot; + getLimitWhereCondition() + AND + Columns.STARTTRANS.name() +</span>
<span class="fc" id="L1668">        &quot; &gt;= ? AND &quot; + Columns.UPDATEDINFO.name() + &quot; = ? &quot;;</span>
<span class="fc" id="L1669">    final DbPreparedStatement pstt = new DbPreparedStatement(session, request);</span>
<span class="fc" id="L1670">    session.addLongTermPreparedStatement(pstt);</span>
<span class="fc" id="L1671">    return pstt;</span>
  }

  /**
   * @param pstt
   * @param info
   * @param time
   *
   * @return the number of elements (COUNT) from the statement
   */
  public static long getResultCountPrepareStatement(
      final DbPreparedStatement pstt, final UpdatedInfo info, final long time) {
<span class="fc" id="L1683">    long result = 0;</span>
    try {
<span class="fc" id="L1685">      finishSelectOrCountPrepareStatement(pstt, time);</span>
<span class="fc" id="L1686">      pstt.getPreparedStatement().setInt(2, info.ordinal());</span>
<span class="fc" id="L1687">      pstt.executeQuery();</span>
<span class="pc bpc" id="L1688" title="1 of 2 branches missed.">      if (pstt.getNext()) {</span>
<span class="fc" id="L1689">        result = pstt.getResultSet().getLong(1);</span>
      }
<span class="nc" id="L1691">    } catch (final WaarpDatabaseNoConnectionException ignored) {</span>
      // nothing
<span class="nc" id="L1693">    } catch (final WaarpDatabaseSqlException ignored) {</span>
      // nothing
<span class="nc" id="L1695">    } catch (final SQLException ignored) {</span>
      // nothing
    } finally {
<span class="fc" id="L1698">      pstt.close();</span>
    }
<span class="fc" id="L1700">    return result;</span>
  }

  /**
   * @param session
   * @param globalstep
   *
   * @return the DbPreparedStatement for getting Runner according to
   *     globalstep
   *     ordered by start
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   */
  public static DbPreparedStatement getCountStepPrepareStatement(
      final DbSession session, final TASKSTEP globalstep)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
<span class="fc" id="L1717">    String request =</span>
<span class="fc" id="L1718">        SELECT_COUNT + Columns.SPECIALID.name() + &quot;) FROM &quot; + table;</span>
<span class="fc bfc" id="L1719" title="All 2 branches covered.">    if (globalstep != null) {</span>
<span class="fc" id="L1720">      request += &quot; WHERE &quot; + getLimitWhereCondition() + AND +</span>
<span class="fc" id="L1721">                 Columns.STARTTRANS.name() + &quot; &gt;= ? AND &quot; +</span>
<span class="fc" id="L1722">                 Columns.GLOBALSTEP.name() + &quot; &quot; + &quot;= &quot; + globalstep.ordinal();</span>
    } else {
<span class="fc" id="L1724">      request += &quot; WHERE &quot; + getLimitWhereCondition() + AND +</span>
<span class="fc" id="L1725">                 Columns.STARTTRANS.name() + &quot; &gt;= ? &quot;;</span>
    }
<span class="fc" id="L1727">    final DbPreparedStatement prep = new DbPreparedStatement(session, request);</span>
<span class="fc" id="L1728">    session.addLongTermPreparedStatement(prep);</span>
<span class="fc" id="L1729">    return prep;</span>
  }

  /**
   * @param session
   *
   * @return the DbPreparedStatement for getting Runner according to status
   *     ordered by start
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   */
  public static DbPreparedStatement getCountStatusPrepareStatement(
      final DbSession session)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
<span class="fc" id="L1744">    String request =</span>
<span class="fc" id="L1745">        SELECT_COUNT + Columns.SPECIALID.name() + &quot;) FROM &quot; + table;</span>
<span class="fc" id="L1746">    request +=</span>
<span class="fc" id="L1747">        &quot; WHERE &quot; + getLimitWhereCondition() + AND + Columns.STARTTRANS.name() +</span>
        &quot; &gt;= ? &quot;;
<span class="fc" id="L1749">    request += AND + Columns.INFOSTATUS.name() + &quot; = ? &quot;;</span>
<span class="fc" id="L1750">    final DbPreparedStatement prep = new DbPreparedStatement(session, request);</span>
<span class="fc" id="L1751">    session.addLongTermPreparedStatement(prep);</span>
<span class="fc" id="L1752">    return prep;</span>
  }

  /**
   * @param pstt
   * @param error
   * @param time
   *
   * @return the number of elements (COUNT) from the statement
   */
  public static long getResultCountPrepareStatement(
      final DbPreparedStatement pstt, final ErrorCode error, final long time) {
<span class="fc" id="L1764">    long result = 0;</span>
    try {
<span class="fc" id="L1766">      finishSelectOrCountPrepareStatement(pstt, time);</span>
<span class="fc" id="L1767">      pstt.getPreparedStatement().setString(2, error.getCode());</span>
<span class="fc" id="L1768">      pstt.executeQuery();</span>
<span class="pc bpc" id="L1769" title="1 of 2 branches missed.">      if (pstt.getNext()) {</span>
<span class="fc" id="L1770">        result = pstt.getResultSet().getLong(1);</span>
      }
<span class="nc" id="L1772">    } catch (final WaarpDatabaseNoConnectionException ignored) {</span>
      // ignore
<span class="nc" id="L1774">    } catch (final WaarpDatabaseSqlException ignored) {</span>
      // ignore
<span class="nc" id="L1776">    } catch (final SQLException ignored) {</span>
      // ignore
    } finally {
<span class="fc" id="L1779">      pstt.close();</span>
    }
<span class="fc" id="L1781">    return result;</span>
  }

  /**
   * Only running transfers
   *
   * @param session
   * @param status
   *
   * @return the DbPreparedStatement for getting Runner according to status
   *     ordered by start
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   */
  public static DbPreparedStatement getCountStatusRunningPrepareStatement(
      final DbSession session, final ErrorCode status)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
<span class="fc" id="L1799">    String request =</span>
<span class="fc" id="L1800">        SELECT_COUNT + Columns.SPECIALID.name() + &quot;) FROM &quot; + table;</span>
<span class="fc" id="L1801">    request += &quot; WHERE &quot; + getLimitWhereCondition();</span>
<span class="fc" id="L1802">    request += AND + Columns.STARTTRANS.name() + &quot; &gt;= ? &quot;;</span>
<span class="fc" id="L1803">    request += AND + Columns.UPDATEDINFO.name() + &quot; = &quot; +</span>
<span class="fc" id="L1804">               UpdatedInfo.RUNNING.ordinal();</span>
<span class="fc bfc" id="L1805" title="All 2 branches covered.">    if (status != null) {</span>
<span class="fc" id="L1806">      request +=</span>
<span class="fc" id="L1807">          AND + Columns.STEPSTATUS.name() + &quot; = '&quot; + status.getCode() + '\'';</span>
    }
<span class="fc" id="L1809">    final DbPreparedStatement prep = new DbPreparedStatement(session, request);</span>
<span class="fc" id="L1810">    session.addLongTermPreparedStatement(prep);</span>
<span class="fc" id="L1811">    return prep;</span>
  }

  /**
   * Running or not transfers are concerned
   *
   * @param session
   * @param in True for Incoming, False for Outgoing
   *
   * @return the DbPreparedStatement for getting Runner according to in or out
   *     going way and Error
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   */
  public static DbPreparedStatement getCountInOutErrorPrepareStatement(
      final DbSession session, final boolean in)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
<span class="fc" id="L1829">    String request =</span>
<span class="fc" id="L1830">        SELECT_COUNT + Columns.SPECIALID.name() + &quot;) FROM &quot; + table;</span>
<span class="fc" id="L1831">    request += &quot; WHERE &quot; + getLimitWhereCondition() + &quot; &quot;;</span>
    final String requesterd;
<span class="fc" id="L1833">    final String from = Configuration.configuration.getHostId();</span>
<span class="fc" id="L1834">    final String sfrom = Configuration.configuration.getHostSslId();</span>
<span class="fc bfc" id="L1835" title="All 2 branches covered.">    if (in) {</span>
<span class="fc" id="L1836">      requesterd = Columns.REQUESTED.name();</span>
    } else {
<span class="fc" id="L1838">      requesterd = Columns.REQUESTER.name();</span>
    }
<span class="pc bpc" id="L1840" title="2 of 4 branches missed.">    if (from != null &amp;&amp; sfrom != null) {</span>
<span class="fc" id="L1841">      request += AND + requesterd + &quot; IN('&quot; + from + &quot;', '&quot; + sfrom + &quot;') &quot;;</span>
<span class="nc bnc" id="L1842" title="All 2 branches missed.">    } else if (from != null) {</span>
<span class="nc" id="L1843">      request += AND + requesterd + &quot; = '&quot; + from + &quot;' &quot;;</span>
    } else {
<span class="nc" id="L1845">      request += AND + requesterd + &quot; = '&quot; + sfrom + &quot;' &quot;;</span>
    }
<span class="fc" id="L1847">    request += AND + Columns.STARTTRANS.name() + &quot; &gt;= ? &quot;;</span>
<span class="fc" id="L1848">    request += AND + Columns.UPDATEDINFO.name() + &quot; = &quot; +</span>
<span class="fc" id="L1849">               UpdatedInfo.INERROR.ordinal();</span>
<span class="fc" id="L1850">    final DbPreparedStatement prep = new DbPreparedStatement(session, request);</span>
<span class="fc" id="L1851">    session.addLongTermPreparedStatement(prep);</span>
<span class="fc" id="L1852">    return prep;</span>
  }

  /**
   * Running or not transfers are concerned
   *
   * @param session
   * @param in True for Incoming, False for Outgoing
   * @param running True for Running only, False for all
   *
   * @return the DbPreparedStatement for getting Runner according to in or out
   *     going way
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   */
  public static DbPreparedStatement getCountInOutRunningPrepareStatement(
      final DbSession session, final boolean in, final boolean running)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
<span class="fc" id="L1871">    String request =</span>
<span class="fc" id="L1872">        SELECT_COUNT + Columns.SPECIALID.name() + &quot;) FROM &quot; + table;</span>
<span class="fc" id="L1873">    request += &quot; WHERE &quot; + getLimitWhereCondition() + &quot; &quot;;</span>
    final String requesterd;
<span class="fc" id="L1875">    final String from = Configuration.configuration.getHostId();</span>
<span class="fc" id="L1876">    final String sfrom = Configuration.configuration.getHostSslId();</span>
<span class="fc bfc" id="L1877" title="All 2 branches covered.">    if (in) {</span>
<span class="fc" id="L1878">      requesterd = Columns.REQUESTED.name();</span>
    } else {
<span class="fc" id="L1880">      requesterd = Columns.REQUESTER.name();</span>
    }
<span class="pc bpc" id="L1882" title="2 of 4 branches missed.">    if (from != null &amp;&amp; sfrom != null) {</span>
<span class="fc" id="L1883">      request += AND + requesterd + &quot; IN('&quot; + from + &quot;', '&quot; + sfrom + &quot;') &quot;;</span>
<span class="nc bnc" id="L1884" title="All 2 branches missed.">    } else if (from != null) {</span>
<span class="nc" id="L1885">      request += AND + requesterd + &quot; = '&quot; + from + &quot;' &quot;;</span>
    } else {
<span class="nc" id="L1887">      request += AND + requesterd + &quot; = '&quot; + sfrom + &quot;' &quot;;</span>
    }
<span class="fc" id="L1889">    request += AND + Columns.STARTTRANS.name() + &quot; &gt;= ? &quot;;</span>
<span class="fc bfc" id="L1890" title="All 2 branches covered.">    if (running) {</span>
<span class="fc" id="L1891">      request += AND + Columns.UPDATEDINFO.name() + &quot; = &quot; +</span>
<span class="fc" id="L1892">                 UpdatedInfo.RUNNING.ordinal();</span>
    }
<span class="fc" id="L1894">    final DbPreparedStatement prep = new DbPreparedStatement(session, request);</span>
<span class="fc" id="L1895">    session.addLongTermPreparedStatement(prep);</span>
<span class="fc" id="L1896">    return prep;</span>
  }

  /**
   * @param pstt
   *
   * @return the number of elements (COUNT) from the statement
   */
  public static long getResultCountPrepareStatement(
      final DbPreparedStatement pstt) {
<span class="fc" id="L1906">    long result = 0;</span>
    try {
<span class="fc" id="L1908">      pstt.executeQuery();</span>
<span class="pc bpc" id="L1909" title="1 of 2 branches missed.">      if (pstt.getNext()) {</span>
<span class="fc" id="L1910">        result = pstt.getResultSet().getLong(1);</span>
      }
<span class="nc" id="L1912">    } catch (final WaarpDatabaseNoConnectionException ignored) {</span>
      // ignore
<span class="nc" id="L1914">    } catch (final WaarpDatabaseSqlException ignored) {</span>
      // ignore
<span class="nc" id="L1916">    } catch (final SQLException ignored) {</span>
      // ignore
    } finally {
<span class="fc" id="L1919">      pstt.close();</span>
    }
<span class="fc" id="L1921">    return result;</span>
  }

  /**
   * Set the current time in the given updatedPreparedStatement
   *
   * @param pstt
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   */
  public static void finishSelectOrCountPrepareStatement(
      final DbPreparedStatement pstt, final long time)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
<span class="fc" id="L1935">    final Timestamp startlimit = new Timestamp(time);</span>
    try {
<span class="fc" id="L1937">      pstt.getPreparedStatement().setTimestamp(1, startlimit);</span>
<span class="nc" id="L1938">    } catch (final SQLException e) {</span>
<span class="nc" id="L1939">      logger.error(&quot;Database SQL Error: Cannot set timestamp: {}&quot;,</span>
<span class="nc" id="L1940">                   e.getMessage());</span>
<span class="nc" id="L1941">      throw new WaarpDatabaseSqlException(&quot;Cannot set timestamp&quot;, e);</span>
<span class="fc" id="L1942">    }</span>
<span class="fc" id="L1943">  }</span>

  /**
   * @param session
   * @param start
   * @param stop
   *
   * @return the DbPreparedStatement for getting Selected Object, whatever
   *     their
   *     status
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   */
  public static DbPreparedStatement getLogPrepareStatement(
      final DbSession session, final Timestamp start, final Timestamp stop)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
<span class="fc" id="L1960">    final DbPreparedStatement preparedStatement =</span>
        new DbPreparedStatement(session);
<span class="fc" id="L1962">    String request = &quot;SELECT &quot; + selectAllFields + &quot; FROM &quot; + table;</span>
<span class="pc bpc" id="L1963" title="1 of 4 branches missed.">    if (start != null &amp;&amp; stop != null) {</span>
<span class="fc" id="L1964">      request += &quot; WHERE &quot; + getLimitWhereCondition() + AND +</span>
<span class="fc" id="L1965">                 Columns.STARTTRANS.name() + &quot; BETWEEN ? AND ? ORDER BY &quot; +</span>
<span class="fc" id="L1966">                 Columns.SPECIALID.name() + &quot; DESC &quot;;</span>
<span class="fc" id="L1967">      preparedStatement.createPrepareStatement(request);</span>
      try {
<span class="fc" id="L1969">        preparedStatement.getPreparedStatement().setTimestamp(1, start);</span>
<span class="fc" id="L1970">        preparedStatement.getPreparedStatement().setTimestamp(2, stop);</span>
<span class="nc" id="L1971">      } catch (final SQLException e) {</span>
<span class="nc" id="L1972">        preparedStatement.realClose();</span>
<span class="nc" id="L1973">        throw new WaarpDatabaseSqlException(e);</span>
<span class="fc" id="L1974">      }</span>
<span class="pc bpc" id="L1975" title="1 of 2 branches missed.">    } else if (start != null) {</span>
<span class="nc" id="L1976">      request += &quot; WHERE &quot; + getLimitWhereCondition() + AND +</span>
<span class="nc" id="L1977">                 Columns.STARTTRANS.name() + &quot; &gt;= ? ORDER BY &quot; +</span>
<span class="nc" id="L1978">                 Columns.SPECIALID.name() + &quot; DESC &quot;;</span>
<span class="nc" id="L1979">      preparedStatement.createPrepareStatement(request);</span>
      try {
<span class="nc" id="L1981">        preparedStatement.getPreparedStatement().setTimestamp(1, start);</span>
<span class="nc" id="L1982">      } catch (final SQLException e) {</span>
<span class="nc" id="L1983">        preparedStatement.realClose();</span>
<span class="nc" id="L1984">        throw new WaarpDatabaseSqlException(e);</span>
<span class="nc" id="L1985">      }</span>
<span class="pc bpc" id="L1986" title="1 of 2 branches missed.">    } else if (stop != null) {</span>
<span class="nc" id="L1987">      request += &quot; WHERE &quot; + getLimitWhereCondition() + AND +</span>
<span class="nc" id="L1988">                 Columns.STARTTRANS.name() + &quot; &lt;= ? ORDER BY &quot; +</span>
<span class="nc" id="L1989">                 Columns.SPECIALID.name() + &quot; DESC &quot;;</span>
<span class="nc" id="L1990">      preparedStatement.createPrepareStatement(request);</span>
      try {
<span class="nc" id="L1992">        preparedStatement.getPreparedStatement().setTimestamp(1, stop);</span>
<span class="nc" id="L1993">      } catch (final SQLException e) {</span>
<span class="nc" id="L1994">        preparedStatement.realClose();</span>
<span class="nc" id="L1995">        throw new WaarpDatabaseSqlException(e);</span>
<span class="nc" id="L1996">      }</span>
    } else {
<span class="fc" id="L1998">      request += &quot; WHERE &quot; + getLimitWhereCondition() + &quot; ORDER BY &quot; +</span>
<span class="fc" id="L1999">                 Columns.SPECIALID.name() + &quot; DESC &quot;;</span>
<span class="fc" id="L2000">      preparedStatement.createPrepareStatement(request);</span>
    }
<span class="fc" id="L2002">    return preparedStatement;</span>
  }

  /**
   * purge in same interval all runners with globallaststep as ALLDONETASK or
   * UpdatedInfo as Done
   *
   * @param session
   * @param start
   * @param stop
   *
   * @return the number of log purged
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   */
  public static int purgeLogPrepareStatement(final DbSession session,
                                             final Timestamp start,
                                             final Timestamp stop)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
<span class="fc" id="L2022">    final DbPreparedStatement preparedStatement =</span>
        new DbPreparedStatement(session);
<span class="fc" id="L2024">    String request =</span>
<span class="fc" id="L2025">        &quot;DELETE FROM &quot; + table + &quot; WHERE &quot; + getLimitWhereCondition() + AND +</span>
<span class="fc" id="L2026">        &quot;(&quot; + Columns.UPDATEDINFO + &quot; = &quot; + UpdatedInfo.DONE.ordinal() +</span>
        &quot; OR &quot; + Columns.GLOBALLASTSTEP + &quot; = &quot; +
<span class="fc" id="L2028">        TASKSTEP.ALLDONETASK.ordinal() + &quot;) &quot;;</span>
    try {
<span class="pc bpc" id="L2030" title="3 of 4 branches missed.">      if (start != null &amp;&amp; stop != null) {</span>
<span class="nc" id="L2031">        request += AND + Columns.STARTTRANS.name() + &quot; &gt;= ? AND &quot; +</span>
<span class="nc" id="L2032">                   Columns.STOPTRANS.name() + &quot; &lt;= ? &quot;;</span>
<span class="nc" id="L2033">        preparedStatement.createPrepareStatement(request);</span>
        try {
<span class="nc" id="L2035">          preparedStatement.getPreparedStatement().setTimestamp(1, start);</span>
<span class="nc" id="L2036">          preparedStatement.getPreparedStatement().setTimestamp(2, stop);</span>
<span class="nc" id="L2037">        } catch (final SQLException e) {</span>
<span class="nc" id="L2038">          preparedStatement.realClose();</span>
<span class="nc" id="L2039">          throw new WaarpDatabaseSqlException(e);</span>
<span class="nc" id="L2040">        }</span>
<span class="pc bpc" id="L2041" title="1 of 2 branches missed.">      } else if (start != null) {</span>
<span class="nc" id="L2042">        request += AND + Columns.STARTTRANS.name() + &quot; &gt;= ? &quot;;</span>
<span class="nc" id="L2043">        preparedStatement.createPrepareStatement(request);</span>
        try {
<span class="nc" id="L2045">          preparedStatement.getPreparedStatement().setTimestamp(1, start);</span>
<span class="nc" id="L2046">        } catch (final SQLException e) {</span>
<span class="nc" id="L2047">          preparedStatement.realClose();</span>
<span class="nc" id="L2048">          throw new WaarpDatabaseSqlException(e);</span>
<span class="nc" id="L2049">        }</span>
<span class="pc bpc" id="L2050" title="1 of 2 branches missed.">      } else if (stop != null) {</span>
<span class="nc" id="L2051">        request += AND + Columns.STOPTRANS.name() + &quot; &lt;= ? &quot;;</span>
<span class="nc" id="L2052">        preparedStatement.createPrepareStatement(request);</span>
        try {
<span class="nc" id="L2054">          preparedStatement.getPreparedStatement().setTimestamp(1, stop);</span>
<span class="nc" id="L2055">        } catch (final SQLException e) {</span>
<span class="nc" id="L2056">          preparedStatement.realClose();</span>
<span class="nc" id="L2057">          throw new WaarpDatabaseSqlException(e);</span>
<span class="nc" id="L2058">        }</span>
      } else {
<span class="fc" id="L2060">        preparedStatement.createPrepareStatement(request);</span>
      }
<span class="fc" id="L2062">      final int nb = preparedStatement.executeUpdate();</span>
<span class="fc" id="L2063">      logger.info(&quot;Purge {} from {}&quot;, nb, request);</span>
<span class="fc" id="L2064">      return nb;</span>
    } finally {
<span class="fc" id="L2066">      preparedStatement.realClose();</span>
    }
  }

  /**
   * @param session
   * @param startid
   * @param stopid
   * @param start
   * @param stop
   * @param rule
   * @param req
   * @param pending
   * @param transfer
   * @param error
   * @param done
   * @param all
   *
   * @return the DbPreparedStatement according to the filter and ALLDONE,
   *     ERROR globallaststep
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   */
  public static int purgeLogPrepareStatement(final DbSession session,
                                             final String startid,
                                             final String stopid,
                                             final Timestamp start,
                                             final Timestamp stop,
                                             final String rule,
                                             final String req,
                                             final boolean pending,
                                             final boolean transfer,
                                             final boolean error,
                                             final boolean done,
                                             final boolean all)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
<span class="fc" id="L2103">    final DbPreparedStatement preparedStatement =</span>
        new DbPreparedStatement(session);
<span class="fc" id="L2105">    final String request = &quot;DELETE FROM &quot; + table;</span>
<span class="fc" id="L2106">    final String orderby = &quot;&quot;;</span>
    final String whereCond;
<span class="pc bpc" id="L2108" title="1 of 2 branches missed.">    if (ParametersChecker.isEmpty(startid) &amp;&amp;</span>
<span class="pc bpc" id="L2109" title="5 of 6 branches missed.">        ParametersChecker.isEmpty(stopid) &amp;&amp; start == null &amp;&amp; stop == null &amp;&amp;</span>
<span class="nc bnc" id="L2110" title="All 6 branches missed.">        ParametersChecker.isEmpty(rule) &amp;&amp; ParametersChecker.isEmpty(req) &amp;&amp;</span>
        all) {
<span class="nc" id="L2112">      whereCond =</span>
<span class="nc" id="L2113">          getLimitWhereCondition() + &quot; AND (&quot; + Columns.UPDATEDINFO + &quot; = &quot; +</span>
<span class="nc" id="L2114">          UpdatedInfo.DONE.ordinal() + &quot; OR &quot; + Columns.GLOBALLASTSTEP + &quot; = &quot; +</span>
<span class="nc" id="L2115">          TASKSTEP.ALLDONETASK.ordinal() + &quot;) &quot;;</span>
    } else {
<span class="pc bpc" id="L2117" title="1 of 2 branches missed.">      if (all) {</span>
<span class="nc" id="L2118">        whereCond =</span>
<span class="nc" id="L2119">            getLimitWhereCondition() + &quot; AND (&quot; + Columns.UPDATEDINFO + &quot; IN(&quot; +</span>
<span class="nc" id="L2120">            UpdatedInfo.DONE.ordinal() + &quot;, &quot; + UpdatedInfo.INERROR.ordinal() +</span>
            &quot;) OR &quot; + Columns.GLOBALLASTSTEP + &quot; = &quot; +
<span class="nc" id="L2122">            TASKSTEP.ALLDONETASK.ordinal() + &quot;) &quot;;</span>
      } else {
<span class="fc" id="L2124">        whereCond =</span>
<span class="fc" id="L2125">            getLimitWhereCondition() + AND + Columns.UPDATEDINFO + &quot; &lt;&gt; &quot; +</span>
<span class="fc" id="L2126">            UpdatedInfo.RUNNING.ordinal();// limit by field</span>
      }
    }
    int nb;
    try {
<span class="fc" id="L2131">      getFilterCondition(preparedStatement, request, 0, whereCond, orderby,</span>
                         startid, stopid, start, stop, rule, req, pending,
                         transfer, error, done, all);
<span class="fc" id="L2134">      nb = preparedStatement.executeUpdate();</span>
<span class="fc" id="L2135">      logger.info(&quot;Purge {} from {}&quot;, nb, request);</span>
    } finally {
<span class="fc" id="L2137">      preparedStatement.realClose();</span>
    }
<span class="fc" id="L2139">    return nb;</span>
  }

  /**
   * Change RUNNING, INTERRUPTED to TOSUBMIT TaskRunner from database. This
   * method is to be used when the
   * commander is starting the very first time, in order to be ready to rerun
   * tasks that are pending.
   *
   * @param session
   *
   * @throws WaarpDatabaseNoConnectionException
   */
  public static void resetToSubmit(final DbSession session)
      throws WaarpDatabaseNoConnectionException {
    // Change RUNNING and INTERRUPTED to TOSUBMIT since they should be ready
<span class="fc" id="L2155">    final String request =</span>
<span class="fc" id="L2156">        &quot;UPDATE &quot; + table + &quot; SET &quot; + Columns.UPDATEDINFO.name() + '=' +</span>
<span class="fc" id="L2157">        AbstractDbData.UpdatedInfo.TOSUBMIT.ordinal() + &quot; WHERE &quot; +</span>
<span class="fc" id="L2158">        getLimitWhereCondition() + &quot; AND &quot; + Columns.UPDATEDINFO.name() +</span>
<span class="fc" id="L2159">        &quot; IN(&quot; + AbstractDbData.UpdatedInfo.RUNNING.ordinal() + &quot;, &quot; +</span>
<span class="fc" id="L2160">        AbstractDbData.UpdatedInfo.INTERRUPTED.ordinal() + &quot;)&quot;;</span>
<span class="fc" id="L2161">    final DbPreparedStatement initial = new DbPreparedStatement(session);</span>
    try {
<span class="fc" id="L2163">      initial.createPrepareStatement(request);</span>
<span class="fc" id="L2164">      initial.executeUpdate();</span>
<span class="nc" id="L2165">    } catch (final WaarpDatabaseNoConnectionException e) {</span>
<span class="nc" id="L2166">      logger.error(&quot;Database No Connection Error: Cannot execute Commander: {}&quot;,</span>
<span class="nc" id="L2167">                   e.getMessage());</span>
<span class="nc" id="L2168">    } catch (final WaarpDatabaseSqlException e) {</span>
<span class="nc" id="L2169">      logger.error(&quot;Database SQL Error: Cannot execute Commander&quot;, e);</span>
    } finally {
<span class="fc" id="L2171">      initial.close();</span>
    }
<span class="fc" id="L2173">  }</span>

  /**
   * Change CompleteOk+ALLDONETASK to Updated = DONE TaskRunner from database.
   * This method is a clean function
   * to be used for instance before log export or at the very beginning of the
   * commander.
   *
   * @throws WaarpDatabaseNoConnectionException
   */
  public static void changeFinishedToDone()
      throws WaarpDatabaseNoConnectionException {
    // Update all UpdatedInfo to DONE where GlobalLastStep = ALLDONETASK and
    // status = CompleteOk
<span class="fc" id="L2187">    final List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();</span>
<span class="fc" id="L2188">    filters.add(getOwnerFilter());</span>
<span class="fc" id="L2189">    filters.add(new Filter(DBTransferDAO.UPDATED_INFO_FIELD, &quot;&lt;&gt;&quot;,</span>
<span class="fc" id="L2190">                           UpdatedInfo.DONE.ordinal()));</span>
<span class="fc" id="L2191">    filters.add(new Filter(DBTransferDAO.UPDATED_INFO_FIELD, &quot;&gt;&quot;,</span>
<span class="fc" id="L2192">                           UpdatedInfo.UNKNOWN.ordinal()));</span>
<span class="fc" id="L2193">    filters.add(new Filter(DBTransferDAO.GLOBAL_LAST_STEP_FIELD, &quot;=&quot;,</span>
<span class="fc" id="L2194">                           Transfer.TASKSTEP.ALLDONETASK.ordinal()));</span>
<span class="fc" id="L2195">    filters.add(new Filter(DBTransferDAO.STEP_STATUS_FIELD, &quot;&gt;&quot;,</span>
<span class="fc" id="L2196">                           ErrorCode.CompleteOk.getCode()));</span>

<span class="fc" id="L2198">    TransferDAO transferAccess = null;</span>
    try {
<span class="fc" id="L2200">      transferAccess = DAOFactory.getInstance().getTransferDAO();</span>
<span class="fc" id="L2201">      final List&lt;Transfer&gt; transfers = transferAccess.find(filters);</span>
<span class="pc bpc" id="L2202" title="1 of 2 branches missed.">      for (final Transfer transfer : transfers) {</span>
<span class="nc" id="L2203">        transfer.setUpdatedInfo(org.waarp.openr66.pojo.UpdatedInfo.DONE);</span>
<span class="nc bnc" id="L2204" title="All 2 branches missed.">        if (transferAccess instanceof DBTransferDAO) {</span>
<span class="nc" id="L2205">          ((DBTransferDAO) transferAccess).updateRankUpdatedInfoStepStatusStop(</span>
              transfer);
        } else {
<span class="nc" id="L2208">          transferAccess.update(transfer);</span>
        }
<span class="nc" id="L2210">      }</span>
<span class="nc" id="L2211">    } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L2212">      throw new WaarpDatabaseNoConnectionException(e);</span>
<span class="nc" id="L2213">    } catch (final DAONoDataException e) {</span>
<span class="nc" id="L2214">      throw new WaarpDatabaseNoConnectionException(TRANSFER_NOT_FOUND);</span>
    } finally {
<span class="fc" id="L2216">      DAOFactory.closeDAO(transferAccess);</span>
    }
<span class="fc" id="L2218">  }</span>

  /**
   * Reset the runner (ready to be run again)
   *
   * @return True if OK, False if already finished
   */
  public final boolean reset() {
    // Reset the status if already stopped and not finished
<span class="pc bpc" id="L2227" title="1 of 2 branches missed.">    if (getStatus() != ErrorCode.CompleteOk) {</span>
      // restart
<span class="pc bpc" id="L2229" title="3 of 5 branches missed.">      switch (TASKSTEP.values()[getGloballaststep()]) {</span>
        case PRETASK:
          // restart
<span class="nc" id="L2232">          setPreTask();</span>
<span class="nc" id="L2233">          setExecutionStatus(ErrorCode.InitOk);</span>
<span class="nc" id="L2234">          break;</span>
        case TRANSFERTASK:
          // continue
<span class="fc" id="L2237">          final int newrank = getRank();</span>
<span class="fc" id="L2238">          setTransferTask(newrank);</span>
<span class="fc" id="L2239">          setExecutionStatus(ErrorCode.PreProcessingOk);</span>
<span class="fc" id="L2240">          break;</span>
        case POSTTASK:
          // restart
<span class="nc" id="L2243">          setPostTask();</span>
<span class="nc" id="L2244">          setExecutionStatus(ErrorCode.TransferOk);</span>
<span class="nc" id="L2245">          break;</span>
        case NOTASK:
<span class="fc" id="L2247">          setInitialTask();</span>
<span class="fc" id="L2248">          setExecutionStatus(ErrorCode.Unknown);</span>
<span class="fc" id="L2249">          break;</span>
        default:
          break;
      }
<span class="fc" id="L2253">      changeUpdatedInfo(UpdatedInfo.UNKNOWN);</span>
<span class="fc" id="L2254">      setErrorExecutionStatus(pojo.getStepStatus());</span>
<span class="fc" id="L2255">      return true;</span>
    } else {
      // Already finished
<span class="nc" id="L2258">      return false;</span>
    }
  }

  /**
   * Decrease if necessary the rank
   */
  public final void restartRank() {
<span class="nc bnc" id="L2266" title="All 2 branches missed.">    if (!pojo.getRetrieveMode()) {</span>
<span class="nc" id="L2267">      int newrank = getRank();</span>
<span class="nc bnc" id="L2268" title="All 2 branches missed.">      if (newrank &gt; 0) {</span>
<span class="nc" id="L2269">        logger.debug(&quot;Decrease Rank Restart of -{} from {}&quot;,</span>
<span class="nc" id="L2270">                     Configuration.getRankRestart(), newrank);</span>
<span class="nc" id="L2271">        newrank -= Configuration.getRankRestart();</span>
<span class="nc bnc" id="L2272" title="All 2 branches missed.">        if (newrank &lt;= 0) {</span>
<span class="nc" id="L2273">          newrank = 1;</span>
        }
<span class="nc bnc" id="L2275" title="All 2 branches missed.">        if (getRank() != newrank) {</span>
<span class="nc" id="L2276">          logger.warn(&quot;Decreased Rank Restart at rank: {} for {}&quot;, newrank,</span>
                      this);
        }
      }
<span class="nc" id="L2280">      setTransferTask(newrank);</span>
    }
<span class="nc" id="L2282">  }</span>

  /**
   * Make this Runner ready for restart
   *
   * @param submit True to resubmit this task, else False to keep it
   *     as
   *     running (only reset)
   *
   * @return True if OK or False if Already finished or if submitted and the
   *     request is a selfRequested and is
   *     not ready to restart locally
   */
  public final boolean restart(final boolean submit) {
    // Restart if not Requested
<span class="pc bpc" id="L2297" title="3 of 4 branches missed.">    if (submit &amp;&amp; isRequestOnRequested()) {</span>
<span class="nc bnc" id="L2298" title="All 2 branches missed.">      if (pojo.getLastGlobalStep() != Transfer.TASKSTEP.ALLDONETASK ||</span>
<span class="nc bnc" id="L2299" title="All 2 branches missed.">          pojo.getLastGlobalStep() != Transfer.TASKSTEP.ERRORTASK) {</span>
        // nothing
      }
<span class="nc" id="L2302">      return false;</span>
    }
    // Restart if already stopped and not finished
<span class="pc bpc" id="L2305" title="1 of 2 branches missed.">    if (reset()) {</span>
      // if not submit and transfertask and receiver AND not requester
      // If requester and receiver =&gt; rank is already decreased when request is sent
<span class="pc bpc" id="L2308" title="1 of 4 branches missed.">      if (!submit &amp;&amp; pojo.getGlobalStep() == Transfer.TASKSTEP.TRANSFERTASK &amp;&amp;</span>
<span class="pc bpc" id="L2309" title="1 of 4 branches missed.">          !pojo.getRetrieveMode() &amp;&amp; isRequestOnRequested()) {</span>
<span class="nc" id="L2310">        logger.debug(&quot;Will try to restart transfer {}&quot;, this);</span>
<span class="nc" id="L2311">        restartRank();</span>
<span class="nc" id="L2312">        logger.debug(&quot;New restart for transfer is {}&quot;, this);</span>
      }
<span class="pc bpc" id="L2314" title="1 of 2 branches missed.">      if (submit) {</span>
<span class="nc" id="L2315">        changeUpdatedInfo(UpdatedInfo.TOSUBMIT);</span>
      } else {
<span class="fc" id="L2317">        changeUpdatedInfo(UpdatedInfo.RUNNING);</span>
      }
<span class="fc" id="L2319">      return true;</span>
    } else {
      // Already finished so DONE
<span class="nc" id="L2322">      setAllDone();</span>
<span class="nc" id="L2323">      setErrorExecutionStatus(ErrorCode.QueryAlreadyFinished);</span>
<span class="nc" id="L2324">      forceSaveStatus();</span>
<span class="nc" id="L2325">      return false;</span>
    }
  }

  /**
   * Stop or Cancel a Runner from database point of view
   *
   * @param code
   *
   * @return True if correctly stopped or canceled
   */
  public final boolean stopOrCancelRunner(final ErrorCode code) {
<span class="fc bfc" id="L2337" title="All 2 branches covered.">    if (!isFinished()) {</span>
<span class="fc" id="L2338">      reset();</span>
<span class="pc bpc" id="L2339" title="1 of 2 branches missed.">      switch (code) {</span>
        case CanceledTransfer:
        case StoppedTransfer:
        case RemoteShutdown:
<span class="fc" id="L2343">          changeUpdatedInfo(UpdatedInfo.INERROR);</span>
<span class="fc" id="L2344">          break;</span>
        default:
<span class="nc" id="L2346">          changeUpdatedInfo(UpdatedInfo.INTERRUPTED);</span>
      }
      try {
<span class="fc" id="L2349">        update();</span>
<span class="nc" id="L2350">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L2351">        logger.error(&quot;Cannot save transfer status: {}&quot;, e.getMessage());</span>
<span class="fc" id="L2352">      }</span>
<span class="fc" id="L2353">      logger.warn(&quot;StopOrCancel: {}     {}&quot;, code.getMesg(), toShortString());</span>
<span class="fc" id="L2354">      return true;</span>
    } else {
<span class="pc bpc" id="L2356" title="1 of 2 branches missed.">      if (logger.isInfoEnabled()) {</span>
<span class="nc" id="L2357">        logger.info(&quot;Transfer already finished {}&quot;, toShortString());</span>
      }
    }
<span class="fc" id="L2360">    return false;</span>
  }

  @Override
  public final void changeUpdatedInfo(final UpdatedInfo info) {
<span class="fc" id="L2365">    if (pojo.getUpdatedInfo() !=</span>
<span class="fc bfc" id="L2366" title="All 2 branches covered.">        org.waarp.openr66.pojo.UpdatedInfo.valueOf(info.ordinal())) {</span>
<span class="fc" id="L2367">      setStopNow();</span>
<span class="fc" id="L2368">      isSaved = false;</span>
<span class="fc" id="L2369">      pojo.setUpdatedInfo(</span>
<span class="fc" id="L2370">          org.waarp.openr66.pojo.UpdatedInfo.valueOf(info.ordinal()));</span>
    }
<span class="fc" id="L2372">  }</span>

  /**
   * Set the ErrorCode for the InfoStatus
   *
   * @param code
   */
  public final void setErrorExecutionStatus(final ErrorCode code) {
<span class="fc bfc" id="L2380" title="All 2 branches covered.">    if (pojo.getInfoStatus() != code) {</span>
<span class="fc" id="L2381">      setStopNow();</span>
<span class="fc" id="L2382">      isSaved = false;</span>
<span class="fc" id="L2383">      pojo.setInfoStatus(code);</span>
    }
<span class="fc" id="L2385">  }</span>

  /**
   * @return The current UpdatedInfo value
   */
  public final UpdatedInfo getUpdatedInfo() {
<span class="fc" id="L2391">    return pojo.getUpdatedInfo().getLegacy();</span>
  }

  /**
   * @return the error code associated with the Updated Info
   */
  public final ErrorCode getErrorInfo() {
<span class="fc" id="L2398">    return pojo.getInfoStatus();</span>
  }

  /**
   * @return the step
   */
  public final int getStep() {
<span class="fc" id="L2405">    return pojo.getStep();</span>
  }

  /**
   * @return the rescheduledTransfer
   */
  public final boolean isRescheduledTransfer() {
<span class="fc" id="L2412">    return rescheduledTransfer;</span>
  }

  /**
   * Set this DbTaskRunner as rescheduled (valid only while still in memory)
   */
  public final void setRescheduledTransfer() {
<span class="nc" id="L2419">    rescheduledTransfer = true;</span>
<span class="nc" id="L2420">  }</span>

  /**
   * To set the rank at startup of the request if the request specify a
   * specific
   * rank
   *
   * @param rank the rank to set
   */
  public final void setRankAtStartup(final int rank) {
<span class="fc bfc" id="L2430" title="All 2 branches covered.">    if (pojo.getRank() &gt; rank) {</span>
<span class="fc" id="L2431">      isSaved = false;</span>
<span class="fc" id="L2432">      pojo.setRank(rank);</span>
    }
<span class="fc" id="L2434">  }</span>

  /**
   * @param blocksize the block size to set
   */
  public final void setBlocksize(final int blocksize) {
<span class="fc bfc" id="L2440" title="All 2 branches covered.">    if (pojo.getBlockSize() != blocksize) {</span>
<span class="fc" id="L2441">      isSaved = false;</span>
<span class="fc" id="L2442">      isOtherThanStatus = true;</span>
<span class="fc" id="L2443">      pojo.setBlockSize(blocksize);</span>
    }
<span class="fc" id="L2445">  }</span>

  /**
   * @param filename the filename to set
   */
  public final void setFilename(final String filename) {
<span class="pc bpc" id="L2451" title="1 of 4 branches missed.">    if (pojo.getFilename() == null || !pojo.getFilename().equals(filename)) {</span>
<span class="fc" id="L2452">      isSaved = false;</span>
<span class="fc" id="L2453">      isOtherThanStatus = true;</span>
<span class="fc" id="L2454">      pojo.setFilename(filename);</span>
    }
<span class="fc" id="L2456">  }</span>

  /**
   * @param newFilename the new Filename to set
   * @param isFileMoved the isFileMoved to set
   */
  public final void setFileMoved(final String newFilename,
                                 final boolean isFileMoved) {
<span class="fc" id="L2464">    isSaved = false;</span>
<span class="fc" id="L2465">    isOtherThanStatus = true;</span>
<span class="fc" id="L2466">    pojo.setIsMoved(isFileMoved);</span>
<span class="fc" id="L2467">    pojo.setFilename(newFilename);</span>
<span class="fc" id="L2468">  }</span>

  /**
   * @param originalFilename the originalFilename to set
   */
  public final void setOriginalFilename(final String originalFilename) {
<span class="pc bpc" id="L2474" title="1 of 2 branches missed.">    if (pojo.getOriginalName() == null ||</span>
<span class="fc bfc" id="L2475" title="All 2 branches covered.">        !pojo.getOriginalName().equals(originalFilename)) {</span>
<span class="fc" id="L2476">      isSaved = false;</span>
<span class="fc" id="L2477">      isOtherThanStatus = true;</span>
<span class="fc" id="L2478">      pojo.setOriginalName(originalFilename);</span>
    }
<span class="fc" id="L2480">  }</span>

  /**
   * @return the rank
   */
  public final int getRank() {
<span class="fc" id="L2486">    return pojo.getRank();</span>
  }

  /**
   * Change the status from Task Execution
   *
   * @param status
   */
  public final void setExecutionStatus(final ErrorCode status) {
<span class="pc bpc" id="L2495" title="1 of 2 branches missed.">    if (pojo.getStepStatus() != status) {</span>
<span class="fc" id="L2496">      isSaved = false;</span>
<span class="fc" id="L2497">      pojo.setStepStatus(status);</span>
    }
<span class="fc" id="L2499">  }</span>

  /**
   * @return the status
   */
  public final ErrorCode getStatus() {
<span class="fc" id="L2505">    return pojo.getStepStatus();</span>
  }

  /**
   * @return the isSender
   */
  public final boolean isSender() {
<span class="fc" id="L2512">    return pojo.getRetrieveMode();</span>
  }

  /**
   * @return if is Sender from Session
   */
  public final boolean isSessionSender() {
<span class="fc bfc" id="L2519" title="All 2 branches covered.">    if (session == null) {</span>
<span class="fc" id="L2520">      return isSender();</span>
    }
<span class="fc" id="L2522">    return session.isSender();</span>
  }

  /**
   * @return the isFileMoved
   */
  public final boolean isFileMoved() {
<span class="fc" id="L2529">    return pojo.getIsMoved();</span>
  }

  /**
   * @return the blocksize
   */
  public final int getBlocksize() {
<span class="fc" id="L2536">    return pojo.getBlockSize();</span>
  }

  /**
   * @return the filename
   */
  public final String getFilename() {
<span class="fc" id="L2543">    return pojo.getFilename();</span>
  }

  /**
   * @return the originalFilename
   */
  public final String getOriginalFilename() {
<span class="fc" id="L2550">    return pojo.getOriginalName();</span>
  }

  /**
   * Utility to get possible Json from File information to Transfer information
   */
  private void setMapFromFileInfo() {
<span class="fc" id="L2557">    final Map&lt;String, Object&gt; mapFileInfo =</span>
<span class="fc" id="L2558">        getMapFromString(getFileInformation());</span>
<span class="fc" id="L2559">    final boolean isBlocCompressed =</span>
<span class="fc" id="L2560">        AbstractTask.isCompressionRequested(getFileInformation(), session);</span>
<span class="pc bpc" id="L2561" title="3 of 6 branches missed.">    if (isBlocCompressed &amp;&amp; (session == null || (session != null &amp;&amp;</span>
<span class="nc bnc" id="L2562" title="All 2 branches missed.">                                                 session.isCompressionEnabled()))) {</span>
<span class="fc" id="L2563">      mapFileInfo.put(JSON_COMPRESSION, true);</span>
    } else {
<span class="fc" id="L2565">      mapFileInfo.remove(JSON_COMPRESSION);</span>
    }
<span class="fc" id="L2567">    final Map&lt;String, Object&gt; mapTransferInfo =</span>
<span class="fc" id="L2568">        getMapFromString(getTransferInfo());</span>
<span class="fc" id="L2569">    mapTransferInfo.putAll(mapFileInfo);</span>
<span class="fc" id="L2570">    setTransferMap(mapTransferInfo);</span>
<span class="fc" id="L2571">  }</span>

  /**
   * Initialize the internal Object
   */
  private void initializeTransferInfo() {
<span class="fc bfc" id="L2577" title="All 2 branches covered.">    if (transferMap == null) {</span>
<span class="fc" id="L2578">      transferMap = getTransferMap();</span>
    }
<span class="fc" id="L2580">  }</span>

  /**
   * @param smap the source of the map
   *
   * @return the Map&lt;String, Object&gt; from the content of the
   *     argument
   */
  public static Map&lt;String, Object&gt; getMapFromString(final String smap) {
<span class="fc" id="L2589">    final Pattern pattern = Pattern.compile(&quot;\\{[^\\}]*\\}&quot;);</span>
<span class="fc" id="L2590">    final Matcher matcher = pattern.matcher(JsonHandler.unEscape(smap));</span>
<span class="fc" id="L2591">    final StringBuilder map = new StringBuilder(&quot;{&quot;);</span>
<span class="fc bfc" id="L2592" title="All 2 branches covered.">    while (matcher.find()) {</span>
<span class="fc" id="L2593">      final String temp = matcher.group(0);</span>
<span class="fc bfc" id="L2594" title="All 2 branches covered.">      if (temp.length() &gt; 5) { // {a:a} = 5</span>
<span class="fc bfc" id="L2595" title="All 2 branches covered.">        if (map.length() != 1) {</span>
<span class="fc" id="L2596">          map.append(&quot;, &quot;);</span>
        }
<span class="fc" id="L2598">        map.append(temp, 1, temp.length() - 1);</span>
      }
<span class="fc" id="L2600">    }</span>
<span class="fc" id="L2601">    map.append(&quot;}&quot;);</span>
<span class="fc" id="L2602">    return JsonHandler.getMapFromString(map.toString());</span>
  }

  /**
   * @param smap the source of the map
   *
   * @return the String without the Map&lt;String, Object&gt; from the content of the
   *     argument
   */
  public static String getOutOfMapFromString(final String smap) {
<span class="fc" id="L2612">    return smap.replaceAll(&quot;\\{[^\\}]*\\}&quot;, &quot;&quot;);</span>
  }

  /**
   * @return the Map&lt;String, Object&gt; from the content of the
   *     transferInformation
   */
  public final Map&lt;String, Object&gt; getTransferMap() {
<span class="fc bfc" id="L2620" title="All 2 branches covered.">    if (transferMap != null) {</span>
<span class="fc" id="L2621">      return transferMap;</span>
    }
<span class="fc" id="L2623">    final String noMap = getOtherInfoOutOfMap();</span>
<span class="fc" id="L2624">    final Map&lt;String, Object&gt; map = getMapFromString(pojo.getTransferInfo());</span>
<span class="fc" id="L2625">    internalSetNoMapMap(map, noMap);</span>
<span class="fc" id="L2626">    return map;</span>
  }

  private String getOtherInfoOutOfMap() {
<span class="fc" id="L2630">    return getOutOfMapFromString(pojo.getTransferInfo());</span>
  }

  /**
   * @param map the Map to add as Json string to transferInformation
   */
  public final void setTransferMap(final Map&lt;String, ?&gt; map) {
<span class="fc" id="L2637">    isSaved = false;</span>
<span class="fc" id="L2638">    isOtherThanStatus = true;</span>
<span class="fc" id="L2639">    transferMap = (Map&lt;String, Object&gt;) map;</span>
<span class="fc" id="L2640">  }</span>

  private void internalSetNoMapMap(final Map&lt;String, ?&gt; map,
                                   final String noMap) {
<span class="fc" id="L2644">    transferMap = (Map&lt;String, Object&gt;) map;</span>
<span class="pc bpc" id="L2645" title="1 of 4 branches missed.">    if (noMap == null || noMap.isEmpty()) {</span>
<span class="fc" id="L2646">      pojo.setTransferInfo(&quot;&quot;);</span>
    } else {
<span class="fc" id="L2648">      pojo.setTransferInfo(noMap);</span>
    }
<span class="fc" id="L2650">  }</span>


  /**
   * @param transferInfo the transfer Information to set
   */
  public final void setTransferInfo(final String transferInfo) {
<span class="fc" id="L2657">    final String noMap = getOutOfMapFromString(transferInfo).trim();</span>
<span class="pc bpc" id="L2658" title="1 of 2 branches missed.">    if (transferMap != null) {</span>
<span class="fc" id="L2659">      transferMap.clear();</span>
<span class="fc" id="L2660">      transferMap = null;</span>
    }
<span class="fc" id="L2662">    final Map&lt;String, Object&gt; map = getMapFromString(transferInfo);</span>
<span class="pc bpc" id="L2663" title="3 of 4 branches missed.">    if (transferMap == null || !transferMap.equals(map) ||</span>
<span class="nc bnc" id="L2664" title="All 2 branches missed.">        !pojo.getTransferInfo().equals(noMap)) {</span>
<span class="fc" id="L2665">      isSaved = false;</span>
<span class="fc" id="L2666">      isOtherThanStatus = true;</span>
<span class="fc" id="L2667">      internalSetNoMapMap(map, noMap);</span>
    }
<span class="fc" id="L2669">  }</span>

  /**
   * Helper to set a new (key, value) in the map Transfer
   *
   * @param key
   * @param value
   */
  public final void addToTransferMap(final String key, final Object value) {
<span class="fc bfc" id="L2678" title="All 2 branches covered.">    final Map&lt;String, Object&gt; map =</span>
<span class="fc" id="L2679">        transferMap != null? transferMap : getTransferMap();</span>
<span class="fc" id="L2680">    map.put(key, value);</span>
<span class="fc" id="L2681">    setTransferMap(map);</span>
<span class="fc" id="L2682">  }</span>

  /**
   * Helper to remove a (key, value) from the map Transfer
   *
   * @param key
   */
  public final void removeFromTransferMap(final String key) {
<span class="pc bpc" id="L2690" title="1 of 2 branches missed.">    final Map&lt;String, Object&gt; map =</span>
<span class="pc" id="L2691">        transferMap != null? transferMap : getTransferMap();</span>
<span class="fc" id="L2692">    map.remove(key);</span>
<span class="fc" id="L2693">    setTransferMap(map);</span>
<span class="fc" id="L2694">  }</span>

  /**
   * @param key
   *
   * @return the associated value or null if it does not exist
   */
  public final Object getFromTransferMap(final String key) {
<span class="fc" id="L2702">    return getTransferMap().get(key);</span>
  }

  /**
   * @param size the new size value to set in TransferMap
   */
  private void setOriginalSizeTransferMap(final long size) {
<span class="fc" id="L2709">    addToTransferMap(JSON_ORIGINALSIZE, size);</span>
<span class="fc" id="L2710">  }</span>

  /**
   * @return the size set in TransferMap
   */
  private long getOriginalSizeTransferMap() {
<span class="fc" id="L2716">    final Object size = getFromTransferMap(JSON_ORIGINALSIZE);</span>
<span class="pc bpc" id="L2717" title="1 of 2 branches missed.">    if (size == null) {</span>
<span class="fc" id="L2718">      return -1;</span>
    }
<span class="nc bnc" id="L2720" title="All 2 branches missed.">    if (size instanceof Long) {</span>
<span class="nc" id="L2721">      return (Long) size;</span>
    } else {
<span class="nc" id="L2723">      return (Integer) size;</span>
    }
  }

  /**
   * @return the Follow Id or null if not exists
   */
  public final String getFollowId() {
<span class="fc" id="L2731">    final Object followId = getFromTransferMap(FOLLOW_JSON_KEY);</span>
<span class="fc bfc" id="L2732" title="All 2 branches covered.">    if (followId != null) {</span>
<span class="fc" id="L2733">      return followId.toString();</span>
    }
<span class="fc" id="L2735">    return null;</span>
  }

  /**
   * @param followId the followId to set
   */
  public final void setFollowId(final long followId) {
<span class="fc" id="L2742">    addToTransferMap(FOLLOW_JSON_KEY, followId);</span>
<span class="fc" id="L2743">  }</span>

  /**
   * @return True if Block Compression is active (meaning both partners
   *     allow it and the transfer asked for it through '#COMPRESS#')
   */
  public final boolean isBlockCompression() {
<span class="fc" id="L2750">    final Object compression = getFromTransferMap(JSON_COMPRESSION);</span>
<span class="pc bpc" id="L2751" title="1 of 2 branches missed.">    if (logger.isDebugEnabled()) {</span>
<span class="nc bnc" id="L2752" title="All 2 branches missed.">      logger.debug(&quot;current value {} {} =&gt; {}&quot;, pojo.getTransferInfo(),</span>
<span class="nc" id="L2753">                   transferMap, compression != null? compression : false,</span>
                   new Exception(&quot;Trace for &quot; + &quot;debugging&quot;));
    }
<span class="fc bfc" id="L2756" title="All 2 branches covered.">    if (compression != null) {</span>
<span class="pc bpc" id="L2757" title="1 of 2 branches missed.">      if (compression instanceof Boolean) {</span>
<span class="fc" id="L2758">        return (Boolean) compression;</span>
      } else {
<span class="nc" id="L2760">        return Boolean.parseBoolean(compression.toString());</span>
      }
    }
<span class="fc" id="L2763">    return false;</span>
  }

  /**
   * @param compression True if the Bock Compression is active
   */
  public final void setBlockCompression(final boolean compression) {
<span class="fc" id="L2770">    final Object compressionObject = getFromTransferMap(JSON_COMPRESSION);</span>
<span class="pc bpc" id="L2771" title="1 of 4 branches missed.">    if (compressionObject != null || compression) {</span>
<span class="fc" id="L2772">      addToTransferMap(JSON_COMPRESSION, compression);</span>
    }
<span class="fc bfc" id="L2774" title="All 2 branches covered.">    if (!compression) {</span>
<span class="fc" id="L2775">      removeFromTransferMap(JSON_COMPRESSION);</span>
    }
<span class="fc" id="L2777">  }</span>

  /**
   * @return the Transfer Information (internal informations)
   */
  public final String getTransferInfo() {
<span class="fc bfc" id="L2783" title="All 2 branches covered.">    if (transferMap == null) {</span>
<span class="fc" id="L2784">      return pojo.getTransferInfo();</span>
    }
<span class="fc" id="L2786">    final String nomap = pojo.getTransferInfo();</span>
<span class="fc" id="L2787">    final String result =</span>
<span class="fc bfc" id="L2788" title="All 2 branches covered.">        (ParametersChecker.isEmpty(nomap)? &quot;&quot; : nomap.trim() + &quot; &quot;) +</span>
<span class="fc" id="L2789">        JsonHandler.writeAsString(transferMap).trim();</span>
<span class="fc" id="L2790">    return result;</span>
  }

  /**
   * @return the fileInformation
   */
  public final String getFileInformation() {
<span class="fc" id="L2797">    return pojo.getFileInfo();</span>
  }

  /**
   * Set a new File information for this transfer
   *
   * @param newFileInformation
   */
  public final void setFileInformation(final String newFileInformation) {
<span class="pc bpc" id="L2806" title="1 of 2 branches missed.">    if (pojo.getFileInfo() == null ||</span>
<span class="pc bpc" id="L2807" title="1 of 2 branches missed.">        !pojo.getFileInfo().equals(newFileInformation)) {</span>
<span class="fc" id="L2808">      pojo.setFileInfo(newFileInformation);</span>
<span class="fc" id="L2809">      isOtherThanStatus = true;</span>
<span class="fc" id="L2810">      isSaved = false;</span>
<span class="fc" id="L2811">      setMapFromFileInfo();</span>
    }
<span class="fc" id="L2813">  }</span>

  /**
   * @return the specialId
   */
  public final long getSpecialId() {
<span class="fc" id="L2819">    return pojo.getId();</span>
  }

  /**
   * @return the rule
   */
  public final DbRule getRule() {
<span class="pc bpc" id="L2826" title="1 of 4 branches missed.">    if (rule == null &amp;&amp; getRuleId() != null) {</span>
      try {
<span class="fc" id="L2828">        rule = new DbRule(getRuleId());</span>
<span class="nc" id="L2829">      } catch (final WaarpDatabaseException ignored) {</span>
        // nothing
<span class="fc" id="L2831">      }</span>
    }
<span class="fc" id="L2833">    return rule;</span>
  }

  /**
   * @return the ruleId
   */
  public final String getRuleId() {
<span class="fc" id="L2840">    return pojo.getRule();</span>
  }

  /**
   * @param ruleId the RuleId to set
   *
   * @throws WaarpDatabaseException if the RuleId is wrong
   */
  public final void setRuleId(final String ruleId)
      throws WaarpDatabaseException {
<span class="nc bnc" id="L2850" title="All 4 branches missed.">    if (rule == null || !rule.getIdRule().equals(ruleId)) {</span>
<span class="nc" id="L2851">      rule = new DbRule(ruleId);</span>
<span class="nc" id="L2852">      pojo.setRule(ruleId);</span>
<span class="nc" id="L2853">      isSaved = false;</span>
<span class="nc" id="L2854">      isOtherThanStatus = true;</span>
    }
<span class="nc" id="L2856">  }</span>

  /**
   * @return the mode
   */
  public final int getMode() {
<span class="fc" id="L2862">    return pojo.getTransferMode();</span>
  }

  /**
   * @return the globalstep
   */
  public final TASKSTEP getGlobalStep() {
<span class="fc" id="L2869">    return pojo.getGlobalStep().toLegacy();</span>
  }

  /**
   * @return the globalstep
   */
  public final TASKSTEP getLastGlobalStep() {
<span class="fc" id="L2876">    return pojo.getLastGlobalStep().toLegacy();</span>
  }

  /**
   * @return the globallaststep
   */
  public final int getGloballaststep() {
<span class="fc" id="L2883">    return pojo.getLastGlobalStep().ordinal();</span>
  }

  /**
   * @return True if this runner is ready for transfer or post operation
   */
  public final boolean ready() {
<span class="fc bfc" id="L2890" title="All 2 branches covered.">    return pojo.getGlobalStep() != Transfer.TASKSTEP.NOTASK &amp;&amp;</span>
<span class="pc bpc" id="L2891" title="1 of 2 branches missed.">           pojo.getGlobalStep() != Transfer.TASKSTEP.PRETASK;</span>
  }

  /**
   * @return True if the runner is currently in transfer
   */
  public final boolean isInTransfer() {
<span class="fc bfc" id="L2898" title="All 2 branches covered.">    return pojo.getGlobalStep() == Transfer.TASKSTEP.TRANSFERTASK;</span>
  }

  /**
   * @return True if this runner is finished, either in success or in error
   */
  public final boolean isFinished() {
<span class="fc bfc" id="L2905" title="All 4 branches covered.">    return isAllDone() || isInError();</span>
  }

  /**
   * @return True if this runner is in error and no more running
   */
  public final boolean isInError() {
<span class="fc bfc" id="L2912" title="All 2 branches covered.">    return pojo.getGlobalStep() == Transfer.TASKSTEP.ERRORTASK &amp;&amp;</span>
<span class="fc bfc" id="L2913" title="All 2 branches covered.">           pojo.getStepStatus() != ErrorCode.Running;</span>
  }

  /**
   * @return True if the runner is finished in success
   */
  public final boolean isAllDone() {
<span class="fc bfc" id="L2920" title="All 2 branches covered.">    return pojo.getGlobalStep() == Transfer.TASKSTEP.ALLDONETASK;</span>
  }

  /**
   * To be called before executing Pre execution
   *
   * @return True if the task is going to run PRE task from the first action
   */
  public final boolean isPreTaskStarting() {
<span class="pc bpc" id="L2929" title="1 of 2 branches missed.">    if (pojo.getLastGlobalStep() == Transfer.TASKSTEP.PRETASK ||</span>
<span class="pc bpc" id="L2930" title="1 of 2 branches missed.">        pojo.getLastGlobalStep() == Transfer.TASKSTEP.NOTASK) {</span>
<span class="pc bpc" id="L2931" title="1 of 2 branches missed.">      return pojo.getStep() - 1 &lt;= 0;</span>
    }
<span class="nc" id="L2933">    return false;</span>
  }

  /**
   * Set the Initial Task step (before Pre task)
   */
  public final void setInitialTask() {
<span class="fc" id="L2940">    setStopNow();</span>
<span class="fc" id="L2941">    isSaved = false;</span>
<span class="fc" id="L2942">    pojo.setGlobalStep(Transfer.TASKSTEP.NOTASK);</span>
<span class="fc" id="L2943">    pojo.setLastGlobalStep(Transfer.TASKSTEP.NOTASK);</span>
<span class="fc" id="L2944">    pojo.setStep(-1);</span>
<span class="fc" id="L2945">    pojo.setStepStatus(ErrorCode.Running);</span>
<span class="fc" id="L2946">    pojo.setInfoStatus(ErrorCode.Unknown);</span>
<span class="fc" id="L2947">    pojo.setUpdatedInfo(org.waarp.openr66.pojo.UpdatedInfo.valueOf(</span>
<span class="fc" id="L2948">        UpdatedInfo.RUNNING.ordinal()));</span>
<span class="fc" id="L2949">  }</span>

  /**
   * Set Pre Task step
   */
  public final void setPreTask() {
<span class="fc" id="L2955">    setStopNow();</span>
<span class="fc" id="L2956">    isSaved = false;</span>
<span class="fc" id="L2957">    pojo.setGlobalStep(Transfer.TASKSTEP.PRETASK);</span>
<span class="fc" id="L2958">    pojo.setLastGlobalStep(Transfer.TASKSTEP.PRETASK);</span>
<span class="fc" id="L2959">    final int step = pojo.getStep();</span>
<span class="pc bpc" id="L2960" title="1 of 2 branches missed.">    if (step &lt;= 0) {</span>
<span class="fc" id="L2961">      pojo.setStep(0);</span>
    } else {
<span class="nc" id="L2963">      pojo.setStep(step - 1);</span>
    }
<span class="fc" id="L2965">    pojo.setStepStatus(ErrorCode.Running);</span>
<span class="fc" id="L2966">    pojo.setInfoStatus(ErrorCode.InitOk);</span>
<span class="fc" id="L2967">    pojo.setUpdatedInfo(org.waarp.openr66.pojo.UpdatedInfo.valueOf(</span>
<span class="fc" id="L2968">        UpdatedInfo.RUNNING.ordinal()));</span>
<span class="fc" id="L2969">  }</span>

  /**
   * Set Transfer rank
   *
   * @param rank
   */
  public final void setTransferTask(final int rank) {
<span class="fc" id="L2977">    setStopNow();</span>
<span class="fc" id="L2978">    isSaved = false;</span>
<span class="fc" id="L2979">    pojo.setGlobalStep(Transfer.TASKSTEP.TRANSFERTASK);</span>
<span class="fc" id="L2980">    pojo.setLastGlobalStep(Transfer.TASKSTEP.TRANSFERTASK);</span>
<span class="fc" id="L2981">    final int lastRank = pojo.getRank();</span>
<span class="pc bpc" id="L2982" title="1 of 2 branches missed.">    if (lastRank &gt; rank) {</span>
<span class="nc" id="L2983">      pojo.setRank(rank);</span>
    }
<span class="fc" id="L2985">    pojo.setStepStatus(ErrorCode.Running);</span>
<span class="fc" id="L2986">    pojo.setInfoStatus(ErrorCode.PreProcessingOk);</span>
<span class="fc" id="L2987">  }</span>

  /**
   * Set the Post Task step
   */
  public final void setPostTask() {
<span class="fc" id="L2993">    setStopNow();</span>
<span class="fc" id="L2994">    isSaved = false;</span>
<span class="fc" id="L2995">    pojo.setGlobalStep(Transfer.TASKSTEP.POSTTASK);</span>
<span class="fc" id="L2996">    pojo.setLastGlobalStep(Transfer.TASKSTEP.POSTTASK);</span>
<span class="fc" id="L2997">    final int step = pojo.getStep();</span>
<span class="pc bpc" id="L2998" title="1 of 2 branches missed.">    if (step &lt;= 0) {</span>
<span class="fc" id="L2999">      pojo.setStep(0);</span>
    } else {
<span class="nc" id="L3001">      pojo.setStep(step - 1);</span>
    }
<span class="fc" id="L3003">    pojo.setStepStatus(ErrorCode.Running);</span>
<span class="fc" id="L3004">    pojo.setInfoStatus(ErrorCode.TransferOk);</span>
<span class="fc" id="L3005">  }</span>

  /**
   * Set the Error Task step
   */
  public final void setErrorTask() {
<span class="fc" id="L3011">    setStopNow();</span>
<span class="fc" id="L3012">    isSaved = false;</span>
<span class="fc" id="L3013">    pojo.setGlobalStep(Transfer.TASKSTEP.ERRORTASK);</span>
<span class="fc" id="L3014">    pojo.setStep(0);</span>
<span class="fc" id="L3015">    pojo.setStepStatus(ErrorCode.Running);</span>
<span class="fc" id="L3016">  }</span>

  /**
   * Set the global step as finished (after post task in success)
   */
  public final void setAllDone() {
<span class="fc" id="L3022">    setStopNow();</span>
<span class="fc" id="L3023">    isSaved = false;</span>
<span class="fc" id="L3024">    pojo.setGlobalStep(Transfer.TASKSTEP.ALLDONETASK);</span>
<span class="fc" id="L3025">    pojo.setLastGlobalStep(Transfer.TASKSTEP.ALLDONETASK);</span>
<span class="fc" id="L3026">    pojo.setStep(0);</span>
<span class="fc" id="L3027">    pojo.setStepStatus(ErrorCode.CompleteOk);</span>
<span class="fc" id="L3028">    pojo.setInfoStatus(ErrorCode.CompleteOk);</span>
<span class="fc" id="L3029">    pojo.setUpdatedInfo(</span>
<span class="fc" id="L3030">        org.waarp.openr66.pojo.UpdatedInfo.valueOf(UpdatedInfo.DONE.ordinal()));</span>
<span class="fc" id="L3031">  }</span>

  /**
   * Set the status of the transfer
   *
   * @param code TransferOk if success
   *
   * @return the current rank of transfer
   */
  public final int finishTransferTask(final ErrorCode code) {
<span class="fc" id="L3041">    setStopNow();</span>
<span class="fc bfc" id="L3042" title="All 2 branches covered.">    if (code == ErrorCode.TransferOk) {</span>
<span class="fc" id="L3043">      pojo.setStepStatus(code);</span>
<span class="fc" id="L3044">      pojo.setInfoStatus(code);</span>
<span class="fc" id="L3045">      isSaved = false;</span>
    } else {
<span class="fc" id="L3047">      continueTransfer = false;</span>
<span class="fc" id="L3048">      final ErrorCode infostatus = pojo.getInfoStatus();</span>
<span class="pc bpc" id="L3049" title="5 of 10 branches missed.">      if (infostatus == ErrorCode.InitOk ||</span>
          infostatus == ErrorCode.PostProcessingOk ||
          infostatus == ErrorCode.PreProcessingOk ||
          infostatus == ErrorCode.Running ||
          infostatus == ErrorCode.TransferOk) {
<span class="nc" id="L3054">        pojo.setInfoStatus(code);</span>
<span class="nc" id="L3055">        isSaved = false;</span>
      }
<span class="pc bpc" id="L3057" title="1 of 2 branches missed.">      if (!pojo.getUpdatedInfo().equals(UpdatedInfo.INTERRUPTED)) {</span>
<span class="fc" id="L3058">        pojo.setUpdatedInfo(org.waarp.openr66.pojo.UpdatedInfo.valueOf(</span>
<span class="fc" id="L3059">            UpdatedInfo.INERROR.ordinal()));</span>
<span class="fc" id="L3060">        isSaved = false;</span>
      }
    }
<span class="fc" id="L3063">    return pojo.getRank();</span>
  }

  /**
   * @return True if the transfer is valid to continue
   */
  public final boolean continueTransfer() {
<span class="fc" id="L3070">    return continueTransfer;</span>
  }

  /**
   * Run the task from the given task information (from rule)
   *
   * @param tasks
   *
   * @return The future of the operation (in success or not)
   *
   * @throws OpenR66RunnerEndTasksException
   * @throws OpenR66RunnerErrorException
   */
  private R66Future runNextTask(final String[][] tasks)
      throws OpenR66RunnerEndTasksException, OpenR66RunnerErrorException {
<span class="pc bpc" id="L3085" title="1 of 2 branches missed.">    if (logger.isDebugEnabled()) {</span>
<span class="nc bnc" id="L3086" title="All 4 branches missed.">      logger.debug(&quot;{}:{}:{}:{}:{} Sender: {} {}&quot;, (session == null),</span>
<span class="nc bnc" id="L3087" title="All 2 branches missed.">                   session == null? &quot;norunner&quot; : session.getRunner() == null,</span>
<span class="nc bnc" id="L3088" title="All 2 branches missed.">                   toLogRunStep(), getStep(),</span>
<span class="nc" id="L3089">                   tasks == null? &quot;null&quot; : tasks.length, isSessionSender(),</span>
<span class="nc" id="L3090">                   rule.printTasks(isSessionSender(), getGlobalStep()));</span>
    }
<span class="pc bpc" id="L3092" title="1 of 2 branches missed.">    if (tasks == null) {</span>
<span class="nc" id="L3093">      throw new OpenR66RunnerEndTasksException(&quot;No tasks!&quot;);</span>
    }
<span class="fc" id="L3095">    R66Session tempSession = session;</span>
<span class="fc bfc" id="L3096" title="All 2 branches covered.">    if (tempSession == null) {</span>
<span class="fc" id="L3097">      tempSession = new R66Session();</span>
<span class="pc bpc" id="L3098" title="1 of 2 branches missed.">      if (tempSession.getRunner() == null) {</span>
<span class="fc" id="L3099">        tempSession.setNoSessionRunner(this, localChannelReference);</span>
      }
    } else {
<span class="pc bpc" id="L3102" title="1 of 2 branches missed.">      if (tempSession.getRunner() == null) {</span>
<span class="nc" id="L3103">        tempSession.setNoSessionRunner(this,</span>
<span class="nc" id="L3104">                                       tempSession.getLocalChannelReference());</span>
      }
    }
<span class="fc" id="L3107">    session = tempSession;</span>
<span class="fc" id="L3108">    final LocalChannelReference lcr = session.getLocalChannelReference();</span>
<span class="pc bpc" id="L3109" title="1 of 4 branches missed.">    if (lcr != null &amp;&amp; lcr.getCurrentCode() == ErrorCode.Unknown) {</span>
<span class="fc" id="L3110">      session.getLocalChannelReference()</span>
<span class="fc" id="L3111">             .setErrorMessage(getErrorInfo().getMesg(), getErrorInfo());</span>
    }
<span class="fc bfc" id="L3113" title="All 2 branches covered.">    if (tasks.length &lt;= getStep()) {</span>
<span class="fc" id="L3114">      throw new OpenR66RunnerEndTasksException();</span>
    }
    // Possible long task
<span class="fc" id="L3117">    NetworkServerHandler nsh = null;</span>
<span class="pc bpc" id="L3118" title="1 of 2 branches missed.">    if (lcr != null) {</span>
<span class="fc" id="L3119">      nsh = lcr.getNetworkServerHandler();</span>
<span class="fc bfc" id="L3120" title="All 2 branches covered.">      if (nsh != null) {</span>
<span class="fc" id="L3121">        nsh.resetKeepAlive();</span>
      }
    }
<span class="fc" id="L3124">    final AbstractTask task = getTask(tasks[getStep()], tempSession);</span>
<span class="pc bpc" id="L3125" title="1 of 2 branches missed.">    if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L3126">      logger.debug(&quot;{} Task: {}&quot;, toLogRunStep(), task.getClass().getName());</span>
    }
<span class="fc" id="L3128">    task.run();</span>
<span class="fc" id="L3129">    task.getFutureCompletion().awaitOrInterruptible();</span>
    // Possible long task
<span class="fc bfc" id="L3131" title="All 2 branches covered.">    if (nsh != null) {</span>
<span class="fc" id="L3132">      nsh.resetKeepAlive();</span>
    }
<span class="pc bpc" id="L3134" title="1 of 2 branches missed.">    if (task.getType() == TaskType.RESCHEDULE) {</span>
      // Special case : must test if exec is OK since it must be the last
<span class="nc bnc" id="L3136" title="All 2 branches missed.">      if (isRescheduledTransfer()) {</span>
<span class="nc" id="L3137">        throw new OpenR66RunnerEndTasksException();</span>
      }
    }
<span class="fc" id="L3140">    setStopNow();</span>
<span class="fc" id="L3141">    return task.getFutureCompletion();</span>
  }

  /**
   * @param task
   * @param tempSession
   *
   * @return the corresponding AbstractTask
   *
   * @throws OpenR66RunnerErrorException
   */
  public final AbstractTask getTask(final String[] task,
                                    final R66Session tempSession)
      throws OpenR66RunnerErrorException {
<span class="fc" id="L3155">    final String name = task[0];</span>
<span class="fc" id="L3156">    final String arg = task[1];</span>
    final int delay;
    try {
<span class="fc" id="L3159">      delay = Integer.parseInt(task[2]);</span>
<span class="nc" id="L3160">    } catch (final NumberFormatException e) {</span>
<span class="nc" id="L3161">      logger.warn(&quot;Malformed task so stop the execution: &quot; + toShortString());</span>
<span class="nc" id="L3162">      throw new OpenR66RunnerErrorException(</span>
          &quot;Malformed task so stop the execution&quot;);
<span class="fc" id="L3164">    }</span>
<span class="fc" id="L3165">    return TaskType.getTaskFromId(name, arg, delay, tempSession);</span>
  }

  /**
   * @return the future of the task run
   *
   * @throws OpenR66RunnerEndTasksException
   * @throws OpenR66RunnerErrorException
   * @throws OpenR66RunnerEndTasksException
   */
  private R66Future runNext()
      throws OpenR66RunnerErrorException, OpenR66RunnerEndTasksException {
<span class="pc bpc" id="L3177" title="1 of 2 branches missed.">    if (rule == null) {</span>
<span class="nc bnc" id="L3178" title="All 2 branches missed.">      if (getRuleId() != null) {</span>
        try {
<span class="nc" id="L3180">          rule = new DbRule(getRuleId());</span>
<span class="nc" id="L3181">        } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L3182">          rule = null;</span>
<span class="nc" id="L3183">        }</span>
      }
<span class="nc bnc" id="L3185" title="All 2 branches missed.">      if (rule == null) {</span>
<span class="nc" id="L3186">        throw new OpenR66RunnerErrorException(&quot;Rule Object not initialized&quot;);</span>
      }
    }
<span class="pc bpc" id="L3189" title="1 of 2 branches missed.">    if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L3190">      logger.debug(&quot;{} Sender: {} {}&quot;, toLogRunStep(), isSessionSender(),</span>
<span class="nc" id="L3191">                   rule.printTasks(isSessionSender(), getGlobalStep()));</span>
    }
<span class="pc bpc" id="L3193" title="1 of 4 branches missed.">    switch (getGlobalStep()) {</span>
      case PRETASK:
        try {
<span class="fc bfc" id="L3196" title="All 2 branches covered.">          if (isSessionSender()) {</span>
<span class="fc" id="L3197">            return runNextTask(rule.getSpreTasksArray());</span>
          } else {
<span class="fc" id="L3199">            return runNextTask(rule.getRpreTasksArray());</span>
          }
<span class="fc" id="L3201">        } catch (final OpenR66RunnerEndTasksException e) {</span>
<span class="pc bpc" id="L3202" title="1 of 2 branches missed.">          if (getStatus() == ErrorCode.Running) {</span>
<span class="fc" id="L3203">            setExecutionStatus(ErrorCode.PreProcessingOk);</span>
<span class="fc" id="L3204">            setErrorExecutionStatus(ErrorCode.PreProcessingOk);</span>
          }
<span class="fc" id="L3206">          throw e;</span>
        }
      case POSTTASK:
        try {
<span class="fc bfc" id="L3210" title="All 2 branches covered.">          if (isSessionSender()) {</span>
<span class="fc" id="L3211">            return runNextTask(rule.getSpostTasksArray());</span>
          } else {
<span class="fc" id="L3213">            return runNextTask(rule.getRpostTasksArray());</span>
          }
<span class="fc" id="L3215">        } catch (final OpenR66RunnerEndTasksException e) {</span>
<span class="pc bpc" id="L3216" title="1 of 2 branches missed.">          if (getStatus() == ErrorCode.Running) {</span>
<span class="fc" id="L3217">            setExecutionStatus(ErrorCode.PostProcessingOk);</span>
<span class="fc" id="L3218">            setErrorExecutionStatus(ErrorCode.PostProcessingOk);</span>
          }
<span class="fc" id="L3220">          throw e;</span>
        }
      case ERRORTASK:
        try {
<span class="fc bfc" id="L3224" title="All 2 branches covered.">          if (isSessionSender()) {</span>
<span class="fc" id="L3225">            return runNextTask(rule.getSerrorTasksArray());</span>
          } else {
<span class="fc" id="L3227">            return runNextTask(rule.getRerrorTasksArray());</span>
          }
<span class="fc" id="L3229">        } catch (final OpenR66RunnerEndTasksException e) {</span>
<span class="pc bpc" id="L3230" title="1 of 2 branches missed.">          if (getStatus() == ErrorCode.Running) {</span>
<span class="fc" id="L3231">            setExecutionStatus(getErrorInfo());</span>
          }
<span class="fc" id="L3233">          throw e;</span>
        }
      default:
<span class="nc" id="L3236">        throw new OpenR66RunnerErrorException(&quot;Global Step unknown&quot;);</span>
    }
  }

  /**
   * Run all task from current status (globalstep and step)
   *
   * @throws OpenR66RunnerErrorException
   */
  public final void run() throws OpenR66RunnerErrorException {
    R66Future future;
<span class="pc bpc" id="L3247" title="1 of 2 branches missed.">    if (logger.isDebugEnabled()) {</span>
      try {
<span class="nc" id="L3249">        logger.debug(&quot;{} Status: {} Sender: {} {}&quot;, toLogRunStep(), getStatus(),</span>
<span class="nc" id="L3250">                     isSessionSender(),</span>
<span class="nc" id="L3251">                     rule.printTasks(isSessionSender(), getGlobalStep()));</span>
<span class="nc" id="L3252">      } catch (final NullPointerException ignored) {</span>
        // Ignored
<span class="nc" id="L3254">      }</span>
    }
<span class="pc bpc" id="L3256" title="1 of 2 branches missed.">    if (getStatus() != ErrorCode.Running) {</span>
<span class="nc" id="L3257">      throw new OpenR66RunnerErrorException(</span>
          &quot;Current global STEP not ready to run: &quot; + this);
    }
    while (true) {
<span class="pc bpc" id="L3261" title="1 of 2 branches missed.">      if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L3262">        logger.debug(toLogRunStep());</span>
      }
      try {
<span class="fc" id="L3265">        future = runNext();</span>
<span class="fc" id="L3266">      } catch (final OpenR66RunnerEndTasksException e) {</span>
<span class="fc bfc" id="L3267" title="All 2 branches covered.">        if (pojo.getStep() != 0) {</span>
<span class="fc" id="L3268">          pojo.setStep(0);</span>
<span class="fc" id="L3269">          isSaved = false;</span>
        }
<span class="fc" id="L3271">        return;</span>
<span class="nc" id="L3272">      } catch (final OpenR66RunnerErrorException e) {</span>
<span class="nc" id="L3273">        setErrorExecutionStatus(ErrorCode.ExternalOp);</span>
<span class="nc" id="L3274">        saveStatus();</span>
<span class="nc" id="L3275">        throw new OpenR66RunnerErrorException(</span>
<span class="nc" id="L3276">            &quot;Runner is in error: &quot; + e.getMessage(), e);</span>
<span class="fc" id="L3277">      }</span>
<span class="pc bpc" id="L3278" title="1 of 4 branches missed.">      if (!future.isDone() || future.isFailed()) {</span>
<span class="fc" id="L3279">        final R66Result result = future.getResult();</span>
<span class="fc bfc" id="L3280" title="All 2 branches covered.">        if (result != null) {</span>
<span class="fc" id="L3281">          setErrorExecutionStatus(future.getResult().getCode());</span>
        } else {
<span class="fc" id="L3283">          setErrorExecutionStatus(ErrorCode.ExternalOp);</span>
        }
<span class="fc" id="L3285">        saveStatus();</span>
<span class="fc" id="L3286">        logger.info(&quot;Future is failed: {}&quot;, getErrorInfo().getMesg());</span>
<span class="pc bpc" id="L3287" title="1 of 2 branches missed.">        if (future.getCause() != null) {</span>
<span class="fc" id="L3288">          throw new OpenR66RunnerErrorException(</span>
<span class="fc" id="L3289">              &quot;Runner is failed: &quot; + future.getCause().getMessage(),</span>
<span class="fc" id="L3290">              future.getCause());</span>
        } else {
<span class="nc" id="L3292">          throw new OpenR66RunnerErrorException(</span>
<span class="nc" id="L3293">              &quot;Runner is failed: &quot; + getErrorInfo().getMesg());</span>
        }
      }
<span class="fc" id="L3296">      pojo.setStep(getStep() + 1);</span>
<span class="fc" id="L3297">      isSaved = false;</span>
    }
  }

  /**
   * Once the transfer is over, finalize the Runner by running the error or
   * post
   * operation according to the
   * status.
   *
   * @param localChannelReference
   * @param file
   * @param finalValue
   * @param status
   *
   * @throws OpenR66RunnerErrorException
   * @throws OpenR66ProtocolSystemException
   */
  public final void finalizeTransfer(
      LocalChannelReference localChannelReference, final R66File file,
      final R66Result finalValue, final boolean status)
      throws OpenR66RunnerErrorException, OpenR66ProtocolSystemException {
<span class="fc" id="L3319">    logger.debug(&quot;status: {}:{}&quot;, status, finalValue);</span>

<span class="pc bpc" id="L3321" title="1 of 2 branches missed.">    if (session == null) {</span>
<span class="nc bnc" id="L3322" title="All 2 branches missed.">      if (localChannelReference == null) {</span>
<span class="nc" id="L3323">        return;</span>
      }
<span class="nc" id="L3325">      session = localChannelReference.getSession();</span>
    }
<span class="pc bpc" id="L3327" title="1 of 2 branches missed.">    if (localChannelReference == null) {</span>
<span class="nc" id="L3328">      localChannelReference = session.getLocalChannelReference();</span>
    }
<span class="fc bfc" id="L3330" title="All 2 branches covered.">    if (status) {</span>
<span class="fc" id="L3331">      internalFinalizeValid(localChannelReference, file, finalValue);</span>
    } else {
<span class="fc" id="L3333">      logger.debug(&quot;ContinueTransfer: {} status:{}:{}&quot;, continueTransfer,</span>
<span class="fc" id="L3334">                   status, finalValue);</span>
<span class="fc bfc" id="L3335" title="All 2 branches covered.">      if (finalValue.getException() == null) {</span>
<span class="fc" id="L3336">        finalValue.setException(new OpenR66RunnerException(TRACE_FOR_ERROR));</span>
      }
<span class="fc" id="L3338">      errorTransfer(finalValue, file, localChannelReference);</span>
    }
<span class="fc" id="L3340">  }</span>

  private void internalFinalizeValid(
      final LocalChannelReference localChannelReference, final R66File file,
      final R66Result finalValue)
      throws OpenR66RunnerErrorException, OpenR66ProtocolSystemException {
    // First move the file
<span class="fc bfc" id="L3347" title="All 2 branches covered.">    if (session.isSender()) {</span>
      // Nothing to do since it is the original file
<span class="fc" id="L3349">      setPostTask();</span>
    } else {
<span class="fc" id="L3351">      finalizeReceiver(localChannelReference, file, finalValue);</span>
    }
<span class="fc bfc" id="L3353" title="All 4 branches covered.">    if (isRecvThrough() || isSendThrough()) {</span>
      // File could not exist
<span class="pc bpc" id="L3355" title="1 of 2 branches missed.">    } else if (getStep() == 0) {</span>
      // File must exist
      try {
<span class="pc bpc" id="L3358" title="1 of 2 branches missed.">        if (!file.exists()) {</span>
          // error
<span class="nc" id="L3360">          final R66Result error = new R66Result(</span>
<span class="nc" id="L3361">              new OpenR66RunnerException(ErrorCode.FileNotFound.getMesg()),</span>
<span class="nc" id="L3362">              session, finalValue.isAnswered(), ErrorCode.FileNotFound, this);</span>
<span class="nc" id="L3363">          setErrorExecutionStatus(ErrorCode.FileNotFound);</span>
<span class="nc" id="L3364">          errorTransfer(error, file, localChannelReference);</span>
<span class="nc" id="L3365">          return;</span>
        }
<span class="nc" id="L3367">      } catch (final CommandAbstractException e) {</span>
        // error
<span class="nc" id="L3369">        final R66Result error = new R66Result(</span>
<span class="nc" id="L3370">            new OpenR66RunnerException(ErrorCode.FileNotFound.getMesg()),</span>
<span class="nc" id="L3371">            session, finalValue.isAnswered(), ErrorCode.FileNotFound, this);</span>
<span class="nc" id="L3372">        setErrorExecutionStatus(ErrorCode.FileNotFound);</span>
<span class="nc" id="L3373">        errorTransfer(error, file, localChannelReference);</span>
<span class="nc" id="L3374">        return;</span>
<span class="fc" id="L3375">      }</span>
    }
    try {
<span class="fc" id="L3378">      run();</span>
<span class="fc" id="L3379">    } catch (final OpenR66RunnerErrorException e1) {</span>
<span class="fc" id="L3380">      final R66Result result =</span>
          new R66Result(e1, session, false, ErrorCode.ExternalOp, this);
<span class="fc" id="L3382">      result.setFile(file);</span>
<span class="fc" id="L3383">      result.setRunner(this);</span>
<span class="fc" id="L3384">      changeUpdatedInfo(UpdatedInfo.INERROR);</span>
<span class="fc" id="L3385">      saveStatus();</span>
<span class="fc" id="L3386">      result.setException(e1);</span>
<span class="fc" id="L3387">      errorTransfer(result, file, localChannelReference);</span>
<span class="pc bpc" id="L3388" title="1 of 2 branches missed.">      if (localChannelReference != null) {</span>
<span class="fc" id="L3389">        localChannelReference.invalidateRequest(result);</span>
      }
<span class="fc" id="L3391">      throw e1;</span>
<span class="fc" id="L3392">    }</span>
<span class="fc" id="L3393">    saveStatus();</span>
    /*
     * Done later on after EndRequest this.setAllDone() this.saveStatus()
     */
<span class="pc bpc" id="L3397" title="1 of 2 branches missed.">    logger.info(&quot;Transfer done on {} at RANK {}&quot;,</span>
<span class="fc" id="L3398">                file != null? file : &quot;no file&quot;, getRank());</span>
<span class="pc bpc" id="L3399" title="1 of 2 branches missed.">    if (localChannelReference != null) {</span>
<span class="fc" id="L3400">      localChannelReference.validateEndTransfer(finalValue);</span>
    }
<span class="fc" id="L3402">  }</span>

  private void finalizeReceiver(
      final LocalChannelReference localChannelReference, final R66File file,
      final R66Result finalValue)
      throws OpenR66RunnerErrorException, OpenR66ProtocolSystemException {
<span class="fc" id="L3408">    final int poststep = getStep();</span>
<span class="fc" id="L3409">    setPostTask();</span>
    // in case of error
<span class="fc" id="L3411">    final R66Result error =</span>
<span class="fc" id="L3412">        new R66Result(session, finalValue.isAnswered(), ErrorCode.FinalOp,</span>
                      this);
<span class="pc bpc" id="L3414" title="1 of 4 branches missed.">    if (!isRecvThrough() &amp;&amp; (getGlobalStep() == TASKSTEP.TRANSFERTASK ||</span>
<span class="pc bpc" id="L3415" title="2 of 4 branches missed.">                             getGlobalStep() == TASKSTEP.POSTTASK &amp;&amp;</span>
                             poststep == 0)) {
<span class="fc" id="L3417">      resultFileMove(localChannelReference, file, error);</span>
      // check if necessary once more the hash
<span class="fc bfc" id="L3419" title="All 2 branches covered.">      if (Configuration.configuration.isLocalDigest()) {</span>
<span class="fc" id="L3420">        String hash = null;</span>
<span class="pc bpc" id="L3421" title="1 of 2 branches missed.">        if (localChannelReference != null &amp;&amp;</span>
<span class="pc bpc" id="L3422" title="1 of 2 branches missed.">            !localChannelReference.isPartialHash() &amp;&amp;</span>
<span class="pc bpc" id="L3423" title="1 of 2 branches missed.">            !localChannelReference.getPartner().useFinalHash()) {</span>
          // If partner is using final hash, not necessary since both
          // sides already checked already during end of transfer
<span class="nc" id="L3426">          hash = localChannelReference.getHashComputeDuringTransfer();</span>
        }
<span class="pc bpc" id="L3428" title="1 of 2 branches missed.">        if (hash != null) {</span>
          // we can compute it once more
          try {
<span class="nc" id="L3431">            if (!FilesystemBasedDigest.getHex(</span>
<span class="nc" id="L3432">                                          FilesystemBasedDigest.getHash(file.getTrueFile(), true,</span>
<span class="nc" id="L3433">                                                                        Configuration.configuration.getDigest()))</span>
<span class="nc bnc" id="L3434" title="All 2 branches missed.">                                      .equals(hash)) {</span>
              // KO
<span class="nc" id="L3436">              final R66Result result = new R66Result(</span>
                  new OpenR66RunnerErrorException(
                      &quot;Bad final digest on receive operation&quot;), session, false,
                  ErrorCode.FinalOp, this);
<span class="nc" id="L3440">              result.setFile(file);</span>
<span class="nc" id="L3441">              result.setRunner(this);</span>
<span class="nc" id="L3442">              localChannelReference.invalidateRequest(result);</span>
<span class="nc" id="L3443">              error.setException(result.getException());</span>
<span class="nc" id="L3444">              errorTransfer(error, file, localChannelReference);</span>
<span class="nc" id="L3445">              throw (OpenR66RunnerErrorException) result.getException();</span>
            }
<span class="nc" id="L3447">          } catch (final IOException e) {</span>
<span class="nc" id="L3448">            final R66Result result = new R66Result(</span>
                new OpenR66RunnerErrorException(
                    &quot;Bad final digest on receive operation&quot;, e), session, false,
                ErrorCode.FinalOp, this);
<span class="nc" id="L3452">            result.setFile(file);</span>
<span class="nc" id="L3453">            result.setRunner(this);</span>
<span class="nc" id="L3454">            localChannelReference.invalidateRequest(result);</span>
<span class="nc" id="L3455">            error.setException(result.getException());</span>
<span class="nc" id="L3456">            errorTransfer(error, file, localChannelReference);</span>
<span class="nc" id="L3457">            throw (OpenR66RunnerErrorException) result.getException();</span>
<span class="nc" id="L3458">          }</span>
        }
      }
    }
<span class="fc" id="L3462">  }</span>

  private void resultFileMove(final LocalChannelReference localChannelReference,
                              final R66File file, final R66Result error)
      throws OpenR66RunnerErrorException, OpenR66ProtocolSystemException {
    // Result file moves
<span class="fc" id="L3468">    final String finalpath = R66Dir.getFinalUniqueFilename(file);</span>
<span class="fc" id="L3469">    logger.debug(&quot;Will move file {}&quot;, finalpath);</span>
    try {
<span class="pc bpc" id="L3471" title="1 of 2 branches missed.">      if (!file.renameTo(getRule().setRecvPath(finalpath))) {</span>
<span class="nc" id="L3472">        final OpenR66ProtocolSystemException e =</span>
            new OpenR66ProtocolSystemException(
                &quot;Cannot move file to final position&quot;);
<span class="nc" id="L3475">        final R66Result result =</span>
            new R66Result(e, session, false, ErrorCode.FinalOp, this);
<span class="nc" id="L3477">        result.setFile(file);</span>
<span class="nc" id="L3478">        result.setRunner(this);</span>
<span class="nc bnc" id="L3479" title="All 2 branches missed.">        if (localChannelReference != null) {</span>
<span class="nc" id="L3480">          localChannelReference.invalidateRequest(result);</span>
        }
<span class="nc" id="L3482">        error.setException(result.getException());</span>
<span class="nc" id="L3483">        errorTransfer(error, file, localChannelReference);</span>
<span class="nc" id="L3484">        throw e;</span>
      }
<span class="nc" id="L3486">    } catch (final OpenR66ProtocolSystemException e) {</span>
<span class="nc" id="L3487">      final R66Result result =</span>
          new R66Result(e, session, false, ErrorCode.FinalOp, this);
<span class="nc" id="L3489">      result.setFile(file);</span>
<span class="nc" id="L3490">      result.setRunner(this);</span>
<span class="nc bnc" id="L3491" title="All 2 branches missed.">      if (localChannelReference != null) {</span>
<span class="nc" id="L3492">        localChannelReference.invalidateRequest(result);</span>
      }
<span class="nc" id="L3494">      error.setException(result.getException());</span>
<span class="nc" id="L3495">      errorTransfer(error, file, localChannelReference);</span>
<span class="nc" id="L3496">      throw e;</span>
<span class="nc" id="L3497">    } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L3498">      final R66Result result =</span>
          new R66Result(new OpenR66RunnerErrorException(e), session, false,
                        ErrorCode.FinalOp, this);
<span class="nc" id="L3501">      result.setFile(file);</span>
<span class="nc" id="L3502">      result.setRunner(this);</span>
<span class="nc bnc" id="L3503" title="All 2 branches missed.">      if (localChannelReference != null) {</span>
<span class="nc" id="L3504">        localChannelReference.invalidateRequest(result);</span>
      }
<span class="nc" id="L3506">      error.setException(result.getException());</span>
<span class="nc" id="L3507">      errorTransfer(error, file, localChannelReference);</span>
<span class="nc" id="L3508">      throw (OpenR66RunnerErrorException) result.getException();</span>
<span class="fc" id="L3509">    }</span>
<span class="fc" id="L3510">    logger.debug(&quot;File finally moved: {}&quot;, file);</span>
    try {
<span class="fc" id="L3512">      setFilename(file.getFile());</span>
<span class="nc" id="L3513">    } catch (final CommandAbstractException ignored) {</span>
      // nothing
<span class="fc" id="L3515">    }</span>
<span class="fc" id="L3516">  }</span>

  /**
   * Finalize a transfer in error
   *
   * @param finalValue
   * @param file
   * @param localChannelReference
   *
   * @throws OpenR66RunnerErrorException
   */
  private void errorTransfer(final R66Result finalValue, final R66File file,
                             final LocalChannelReference localChannelReference)
      throws OpenR66RunnerErrorException {
    // error or not ?
<span class="fc" id="L3531">    final ErrorCode runnerStatus = getErrorInfo();</span>
<span class="pc bpc" id="L3532" title="1 of 2 branches missed.">    if (finalValue.getException() != null) {</span>
<span class="fc" id="L3533">      logger.error(&quot;Transfer KO on &quot; + file + &quot; due to &quot; +</span>
<span class="fc" id="L3534">                   finalValue.getException().getMessage());</span>
<span class="fc bfc" id="L3535" title="All 2 branches covered.">      if (TRACE_FOR_ERROR.equalsIgnoreCase(</span>
<span class="fc" id="L3536">          finalValue.getException().getMessage())) {</span>
<span class="fc" id="L3537">        logger.error(finalValue.getException());</span>
      }
    } else {
<span class="nc" id="L3540">      logger.error(&quot;Transfer KO on &quot; + file + &quot; due to &quot; + finalValue);</span>
    }
<span class="pc bpc" id="L3542" title="1 of 2 branches missed.">    if (runnerStatus == ErrorCode.CanceledTransfer) {</span>
      // delete file, reset runner
<span class="nc" id="L3544">      setRankAtStartup(0);</span>
<span class="nc" id="L3545">      deleteTempFile();</span>
<span class="nc" id="L3546">      changeUpdatedInfo(UpdatedInfo.INERROR);</span>
<span class="nc" id="L3547">      saveStatus();</span>
<span class="nc" id="L3548">      finalValue.setAnswered(true);</span>
<span class="pc bpc" id="L3549" title="1 of 4 branches missed.">    } else if (runnerStatus == ErrorCode.StoppedTransfer ||</span>
               runnerStatus == ErrorCode.Shutdown) {
      // just save runner and stop
<span class="fc" id="L3552">      changeUpdatedInfo(UpdatedInfo.INERROR);</span>
<span class="fc" id="L3553">      saveStatus();</span>
<span class="fc" id="L3554">      finalValue.setAnswered(true);</span>
    }
<span class="fc" id="L3556">    logger.debug(&quot;status: {} wasNotError:{}:{}&quot;, getStatus(),</span>
<span class="fc bfc" id="L3557" title="All 2 branches covered.">                 getGlobalStep() != TASKSTEP.ERRORTASK, finalValue);</span>
<span class="fc bfc" id="L3558" title="All 2 branches covered.">    if (getGlobalStep() != TASKSTEP.ERRORTASK) {</span>
      // errorstep was not already executed
      // real error
<span class="pc bpc" id="L3561" title="1 of 2 branches missed.">      if (localChannelReference != null) {</span>
<span class="fc" id="L3562">        localChannelReference.setErrorMessage(finalValue.getMessage(),</span>
<span class="fc" id="L3563">                                              finalValue.getCode());</span>
      }
      // First send error mesg
<span class="pc bpc" id="L3566" title="1 of 4 branches missed.">      if (!finalValue.isAnswered() &amp;&amp; localChannelReference != null) {</span>
<span class="fc" id="L3567">        localChannelReference.sessionNewState(R66FiniteDualStates.ERROR);</span>
<span class="fc" id="L3568">        final ErrorPacket errorPacket = new ErrorPacket(finalValue.getMessage(),</span>
<span class="fc" id="L3569">                                                        finalValue.getCode()</span>
<span class="fc" id="L3570">                                                                  .getCode(),</span>
                                                        ErrorPacket.FORWARDCLOSECODE);
        try {
<span class="fc" id="L3573">          ChannelUtils.writeAbstractLocalPacket(localChannelReference,</span>
                                                errorPacket, true);
<span class="fc" id="L3575">          finalValue.setAnswered(true);</span>
<span class="nc" id="L3576">        } catch (final OpenR66ProtocolPacketException e1) {</span>
          // should not be
<span class="fc" id="L3578">        }</span>
      }
      // now run error task
<span class="fc" id="L3581">      setErrorTask();</span>
<span class="fc" id="L3582">      saveStatus();</span>
      try {
<span class="fc" id="L3584">        run();</span>
<span class="nc" id="L3585">      } catch (final OpenR66RunnerErrorException e1) {</span>
<span class="nc" id="L3586">        changeUpdatedInfo(UpdatedInfo.INERROR);</span>
<span class="nc" id="L3587">        setErrorExecutionStatus(runnerStatus);</span>
<span class="nc" id="L3588">        saveStatus();</span>
<span class="nc bnc" id="L3589" title="All 2 branches missed.">        if (localChannelReference != null) {</span>
<span class="nc" id="L3590">          localChannelReference.invalidateRequest(finalValue);</span>
        }
<span class="nc" id="L3592">        throw e1;</span>
<span class="fc" id="L3593">      }</span>
    }
<span class="pc bpc" id="L3595" title="1 of 2 branches missed.">    if (!isRescheduledTransfer()) {</span>
<span class="fc" id="L3596">      changeUpdatedInfo(UpdatedInfo.INERROR);</span>
    }
<span class="fc" id="L3598">    RequestPacket.isThroughMode(getMode());</span>
    // re set the original status
<span class="fc" id="L3600">    setErrorExecutionStatus(runnerStatus);</span>
<span class="fc" id="L3601">    saveStatus();</span>
<span class="pc bpc" id="L3602" title="1 of 2 branches missed.">    if (localChannelReference != null) {</span>
<span class="fc" id="L3603">      localChannelReference.invalidateRequest(finalValue);</span>
    }
<span class="fc" id="L3605">  }</span>

  /**
   * Increment the rank of the transfer
   */
  public final void incrementRank() {
<span class="fc" id="L3611">    pojo.setRank(getRank() + 1);</span>
<span class="fc" id="L3612">    isSaved = false;</span>
<span class="fc" id="L3613">    int modulo = 10;</span>
<span class="fc bfc" id="L3614" title="All 2 branches covered.">    if (!admin.isCompatibleWithThreadSharedConnexion()) {</span>
<span class="fc" id="L3615">      modulo =</span>
          100; // Bug in JDBC MariaDB/MySQL which tends to consume more memory
    }
<span class="fc bfc" id="L3618" title="All 2 branches covered.">    if (getRank() % modulo == 0) {</span>
      // Save each 10 blocks
      try {
<span class="fc" id="L3621">        updateRank();</span>
<span class="nc" id="L3622">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L3623">        logger.warn(&quot;Cannot update Runner: {}&quot;, e.getMessage());</span>
<span class="fc" id="L3624">      }</span>
    }
<span class="fc" id="L3626">  }</span>

  /**
   * This method is to be called each time an operation is happening on Runner
   *
   * @throws OpenR66RunnerErrorException
   */
  public final void saveStatus() throws OpenR66RunnerErrorException {
    try {
<span class="fc" id="L3635">      update();</span>
<span class="fc" id="L3636">    } catch (final WaarpDatabaseException e) {</span>
<span class="fc" id="L3637">      throw new OpenR66RunnerErrorException(e);</span>
<span class="fc" id="L3638">    }</span>
<span class="fc" id="L3639">  }</span>

  /**
   * This method is to be called each time an operation is happening on Runner
   * and it is forced (for SelfRequest
   * handling)
   *
   * @return True if saved
   *
   * @throws OpenR66RunnerErrorException
   */
  public final boolean forceSaveStatus() {
<span class="fc" id="L3651">    final boolean isSender = isSender();</span>
<span class="fc" id="L3652">    setSenderForUpdate();</span>
<span class="fc" id="L3653">    boolean status = true;</span>
    try {
<span class="fc" id="L3655">      saveStatus();</span>
<span class="nc" id="L3656">    } catch (final OpenR66RunnerErrorException e) {</span>
<span class="nc" id="L3657">      status = false;</span>
<span class="fc" id="L3658">    }</span>
<span class="fc" id="L3659">    setSender(isSender);</span>
<span class="fc" id="L3660">    return status;</span>
  }

  /**
   * Clear the runner
   */
  public final void clear() {
    // ignore
<span class="nc" id="L3668">  }</span>

  /**
   * Delete the temporary empty file (retrieved file at rank 0)
   */
  public final void deleteTempFile() {
<span class="fc bfc" id="L3674" title="All 4 branches covered.">    if (!isSessionSender() &amp;&amp; getRank() == 0) {</span>
      try {
<span class="pc bpc" id="L3676" title="1 of 2 branches missed.">        if (session != null) {</span>
<span class="fc" id="L3677">          final R66File file = session.getFile();</span>
<span class="pc bpc" id="L3678" title="1 of 2 branches missed.">          if (file != null) {</span>
<span class="fc" id="L3679">            file.delete();</span>
          }
        }
<span class="nc" id="L3682">      } catch (final CommandAbstractException e1) {</span>
<span class="nc" id="L3683">        logger.warn(&quot;Cannot delete temporary empty file&quot; + &quot; : {}&quot;,</span>
<span class="nc" id="L3684">                    e1.getMessage());</span>
<span class="fc" id="L3685">      }</span>
    }
<span class="fc" id="L3687">  }</span>

  @Override
  public final String toString() {
<span class="pc bpc" id="L3691" title="1 of 2 branches missed.">    return &quot;Run: '&quot; + (rule != null? rule.toString() : getRuleId()) +</span>
<span class="fc" id="L3692">           &quot;' Filename: '&quot; + getFilename() + &quot;', STEP: '&quot; + getGlobalStep() +</span>
<span class="fc" id="L3693">           '(' + getLastGlobalStep() + &quot;):&quot; + getStep() + ':' +</span>
<span class="fc" id="L3694">           getStatus().getMesg() + &quot;', TransferRank: &quot; + getRank() +</span>
<span class="fc" id="L3695">           &quot;, Blocksize: &quot; + getBlocksize() + &quot;, SpecialId: &quot; + getSpecialId() +</span>
<span class="fc" id="L3696">           &quot;, isSender: &quot; + isSender() + &quot;, isMoved: &quot; + isFileMoved() +</span>
<span class="fc" id="L3697">           &quot;, Mode: '&quot; + getMode() + &quot;', Requester: '&quot; + getRequester() +</span>
<span class="fc" id="L3698">           &quot;', Requested: '&quot; + getRequested() + &quot;', Start: '&quot; + getStart() +</span>
<span class="fc" id="L3699">           &quot;', Stop: '&quot; + getStop() + &quot;', Internal: '&quot; +</span>
<span class="fc" id="L3700">           getUpdatedInfo().name() + ':' + getErrorInfo().getMesg() +</span>
           &quot;', OriginalSize: &quot; + originalSize + &quot;, Fileinfo: '&quot; +
<span class="fc" id="L3702">           getFileInformation() + &quot;', Transferinfo: '&quot; + getTransferInfo() +</span>
           '\'';
  }

  public final String toLogRunStep() {
<span class="nc" id="L3707">    return &quot;Run: &quot; + getRuleId() + &quot; on &quot; + getFilename() + &quot; STEP: &quot; +</span>
<span class="nc" id="L3708">           getGlobalStep() + '(' + getLastGlobalStep() + &quot;):&quot; + getStep() +</span>
<span class="nc" id="L3709">           ':' + getStatus().getMesg();</span>
  }

  public final String toShortNoHtmlString(final String newline) {
<span class="nc" id="L3713">    return &quot;{Run: '&quot; + getRuleId() + &quot;', Filename: '&quot; + getFilename() + &quot;',&quot; +</span>
<span class="nc" id="L3714">           newline + &quot; STEP: '&quot; + getGlobalStep() + '(' + getLastGlobalStep() +</span>
<span class="nc" id="L3715">           &quot;):&quot; + getStep() + ':' + getStatus().getMesg() + &quot;',&quot; + newline +</span>
<span class="nc" id="L3716">           &quot; TransferRank: &quot; + getRank() + &quot;, Blocksize: &quot; + getBlocksize() +</span>
<span class="nc" id="L3717">           &quot;, SpecialId: &quot; + getSpecialId() + &quot;, isSender: '&quot; + isSender() +</span>
<span class="nc" id="L3718">           &quot;', isMoved: '&quot; + isFileMoved() + &quot;', Mode: '&quot; +</span>
<span class="nc" id="L3719">           TRANSFERMODE.values()[getMode()] + newline + &quot;', Requester: '&quot; +</span>
<span class="nc" id="L3720">           getRequester() + &quot;', Requested: '&quot; + getRequested() + &quot;', Start: '&quot; +</span>
<span class="nc" id="L3721">           getStart() + &quot;', Stop: '&quot; + getStop() + &quot;',&quot; + newline +</span>
<span class="nc" id="L3722">           &quot; Internal: '&quot; + getUpdatedInfo().name() + ':' +</span>
<span class="nc" id="L3723">           getErrorInfo().getMesg() + &quot;', OriginalSize: &quot; + originalSize + ',' +</span>
<span class="nc" id="L3724">           newline + &quot; Fileinfo: '&quot; + getFileInformation() +</span>
<span class="nc" id="L3725">           &quot;', Transferinfo: '&quot; + getTransferInfo() + &quot;'}&quot;;</span>
  }

  public final String toShortString() {
<span class="fc" id="L3729">    return &quot;&lt;RULE&gt;&quot; + getRuleId() + &quot;&lt;/RULE&gt;&lt;ID&gt;&quot; + getSpecialId() +</span>
<span class="fc" id="L3730">           &quot;&lt;/ID&gt;&lt;FILE&gt;&quot; + getFilename() + &quot;&lt;/FILE&gt;&lt;ORIGINALFILE&gt;&quot; +</span>
<span class="fc" id="L3731">           getOriginalFilename() + &quot;&lt;/ORIGINALFILE&gt;     &lt;STEP&gt;&quot; +</span>
<span class="fc" id="L3732">           getGlobalStep() + '(' + getLastGlobalStep() + &quot;):&quot; + getStep() +</span>
<span class="fc" id="L3733">           ':' + getStatus().getMesg() + &quot;&lt;/STEP&gt;&lt;RANK&gt;&quot; + getRank() +</span>
<span class="fc" id="L3734">           &quot;&lt;/RANK&gt;&lt;BLOCKSIZE&gt;&quot; + getBlocksize() + &quot;&lt;/BLOCKSIZE&gt;     &lt;SENDER&gt;&quot; +</span>
<span class="fc" id="L3735">           isSender() + &quot;&lt;/SENDER&gt;&lt;MOVED&gt;&quot; + isFileMoved() + &quot;&lt;/MOVED&gt;&lt;MODE&gt;&quot; +</span>
<span class="fc" id="L3736">           TRANSFERMODE.values()[getMode()] + &quot;&lt;/MODE&gt;     &lt;REQR&gt;&quot; +</span>
<span class="fc" id="L3737">           getRequester() + &quot;&lt;/REQR&gt;&lt;REQD&gt;&quot; + getRequested() +</span>
<span class="fc" id="L3738">           &quot;&lt;/REQD&gt;     &lt;START&gt;&quot; + getStart() + &quot;&lt;/START&gt;&lt;STOP&gt;&quot; + getStop() +</span>
<span class="fc" id="L3739">           &quot;&lt;/STOP&gt;     &lt;INTERNAL&gt;&quot; + getUpdatedInfo().name() + &quot; : &quot; +</span>
<span class="fc" id="L3740">           getErrorInfo().getMesg() + &quot;&lt;/INTERNAL&gt;&lt;ORIGINALSIZE&gt;&quot; +</span>
           originalSize + &quot;&lt;/ORIGINALSIZE&gt;     &lt;FILEINFO&gt;&quot; +
<span class="fc" id="L3742">           getFileInformation() + &quot;&lt;/FILEINFO&gt; &lt;TRANSFERINFO&gt;&quot; +</span>
<span class="fc" id="L3743">           getTransferInfo() + &quot;&lt;/TRANSFERINFO&gt;&quot;;</span>
  }

  /**
   * @return the header for a table of runners in Html format
   */
  public static String headerHtml() {
<span class="fc" id="L3750">    return &quot;&lt;td&gt;SpecialId&lt;/td&gt;&lt;td&gt;Rule&lt;/td&gt;&lt;td&gt;Filename&lt;/td&gt;&lt;td&gt;Info&quot; +</span>
           &quot;&lt;/td&gt;&lt;td&gt;Step (LastStep)&lt;/td&gt;&lt;td&gt;Action&lt;/td&gt;&lt;td&gt;Status&quot; +
           &quot;&lt;/td&gt;&lt;td&gt;Internal&lt;/t&gt;&lt;td&gt;Transfer Rank&lt;/td&gt;&lt;td&gt;BlockSize&lt;/td&gt;&lt;td&gt;isMoved&quot; +
           &quot;&lt;/td&gt;&lt;td&gt;Requester&lt;/td&gt;&lt;td&gt;Requested&quot; +
           &quot;&lt;/td&gt;&lt;td&gt;Start&lt;/td&gt;&lt;td&gt;Stop&lt;/td&gt;&lt;td&gt;Bandwidth (Mbits)&lt;/td&gt;&lt;td&gt;Free Space(MB)&lt;/td&gt;&quot;;
  }

  /**
   * @param session
   *
   * @return The associated freespace of the current directory (in MB)
   */
  public final long freespaceMB(final R66Session session) {
<span class="nc bnc" id="L3763" title="All 2 branches missed.">    if (getLastGlobalStep() == TASKSTEP.ALLDONETASK ||</span>
<span class="nc bnc" id="L3764" title="All 2 branches missed.">        getLastGlobalStep() == TASKSTEP.POSTTASK) {</span>
      // All finished or Post task
<span class="nc" id="L3766">      return freespace(session, false) / 0x100000L;</span>
    } else {
      // are we in sending or receive
<span class="nc" id="L3769">      return freespace(session, true) / 0x100000L;</span>
    }
  }

  /**
   * @param session
   * @param isWorkingPath
   *
   * @return The associated freespace of the directory (Working if True, Recv
   *     if
   *     False) (in B, not MB)
   */
  public final long freespace(final R66Session session,
                              final boolean isWorkingPath) {
<span class="fc" id="L3783">    long freespace = -1;</span>
<span class="fc" id="L3784">    DbRule dbRule = null;</span>
    try {
<span class="pc bpc" id="L3786" title="1 of 2 branches missed.">      dbRule = this.rule != null? this.rule : new DbRule(getRuleId());</span>
<span class="nc" id="L3787">    } catch (final WaarpDatabaseException ignored) {</span>
      // ignore
<span class="fc" id="L3789">    }</span>
<span class="pc bpc" id="L3790" title="1 of 2 branches missed.">    if (this.rule == null) {</span>
<span class="nc" id="L3791">      this.rule = dbRule;</span>
    }
<span class="pc bpc" id="L3793" title="2 of 4 branches missed.">    if (dbRule != null &amp;&amp; !isSender()) {</span>
      try {
        final String sdir;
<span class="fc bfc" id="L3796" title="All 2 branches covered.">        if (isWorkingPath) {</span>
<span class="fc" id="L3797">          sdir = dbRule.getWorkPath();</span>
        } else {
<span class="fc" id="L3799">          sdir = dbRule.getRecvPath();</span>
        }
        final R66Dir dir;
<span class="pc bpc" id="L3802" title="1 of 2 branches missed.">        if (session.getDirsFromSession().containsKey(sdir)) {</span>
<span class="nc" id="L3803">          dir = session.getDirsFromSession().get(sdir);</span>
        } else {
<span class="fc" id="L3805">          dir = new R66Dir(session);</span>
<span class="fc" id="L3806">          dir.changeDirectory(sdir);</span>
<span class="fc" id="L3807">          session.getDirsFromSession().put(sdir, dir);</span>
        }
<span class="fc" id="L3809">        freespace = dir.getFreeSpace();</span>
<span class="nc" id="L3810">      } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L3811">        logger.warn(&quot;Error while freespace compute {}&quot;, e.getMessage(), e);</span>
<span class="fc" id="L3812">      }</span>
    }
<span class="fc" id="L3814">    return freespace;</span>
  }

  private String bandwidthMB() {
<span class="nc bnc" id="L3818" title="All 2 branches missed.">    final double drank = getRank() &lt;= 0? 1 : getRank();</span>
<span class="nc" id="L3819">    final double dblocksize = getBlocksize();</span>
<span class="nc" id="L3820">    final double size = drank * dblocksize;</span>
<span class="nc" id="L3821">    final double time = getStop().getTime() + 1 - getStart().getTime();</span>
<span class="nc" id="L3822">    final double result = size / time / 0x100000L * 1000;</span>
<span class="nc" id="L3823">    return String.format(&quot;%,.2f&quot;, result);</span>
  }

  private String getHtmlColor() {
    final String color;
<span class="nc bnc" id="L3828" title="All 7 branches missed.">    switch (getGlobalStep()) {</span>
      case NOTASK:
<span class="nc" id="L3830">        color = &quot;Orange&quot;;</span>
<span class="nc" id="L3831">        break;</span>
      case PRETASK:
<span class="nc" id="L3833">        color = &quot;Yellow&quot;;</span>
<span class="nc" id="L3834">        break;</span>
      case TRANSFERTASK:
<span class="nc" id="L3836">        color = &quot;LightGreen&quot;;</span>
<span class="nc" id="L3837">        break;</span>
      case POSTTASK:
<span class="nc" id="L3839">        color = &quot;Turquoise&quot;;</span>
<span class="nc" id="L3840">        break;</span>
      case ERRORTASK:
<span class="nc" id="L3842">        color = &quot;Red&quot;;</span>
<span class="nc" id="L3843">        break;</span>
      case ALLDONETASK:
<span class="nc" id="L3845">        color = &quot;Cyan&quot;;</span>
<span class="nc" id="L3846">        break;</span>
      default:
<span class="nc" id="L3848">        color = &quot;&quot;;</span>
    }
<span class="nc" id="L3850">    return color;</span>
  }

  private String getInfoHtmlColor() {
    final String color;
<span class="nc bnc" id="L3855" title="All 7 branches missed.">    switch (getUpdatedInfo()) {</span>
      case DONE:
<span class="nc" id="L3857">        color = &quot;Cyan&quot;;</span>
<span class="nc" id="L3858">        break;</span>
      case INERROR:
<span class="nc" id="L3860">        color = &quot;Red&quot;;</span>
<span class="nc" id="L3861">        break;</span>
      case INTERRUPTED:
<span class="nc" id="L3863">        color = &quot;Orange&quot;;</span>
<span class="nc" id="L3864">        break;</span>
      case NOTUPDATED:
<span class="nc" id="L3866">        color = &quot;Yellow&quot;;</span>
<span class="nc" id="L3867">        break;</span>
      case RUNNING:
<span class="nc" id="L3869">        color = &quot;LightGreen&quot;;</span>
<span class="nc" id="L3870">        break;</span>
      case TOSUBMIT:
      case UNKNOWN:
<span class="nc" id="L3873">        color = &quot;Turquoise&quot;;</span>
<span class="nc" id="L3874">        break;</span>
      default:
<span class="nc" id="L3876">        color = &quot;&quot;;</span>
    }
<span class="nc" id="L3878">    return color;</span>
  }

  /**
   * @param session
   * @param running special info
   *
   * @return the runner in Html format compatible with the header from
   *     headerHtml method
   */
  public final String toHtml(final R66Session session, final String running) {
<span class="nc" id="L3889">    final long freespace = freespaceMB(session);</span>
<span class="nc" id="L3890">    final String color = getHtmlColor();</span>
<span class="nc" id="L3891">    final String updcolor = getInfoHtmlColor();</span>
<span class="nc bnc" id="L3892" title="All 2 branches missed.">    return &quot;&lt;td&gt;&quot; + getSpecialId() + &quot;&lt;/td&gt;&lt;td&gt;&quot; +</span>
<span class="nc" id="L3893">           (rule != null? rule.toShortString() : getRuleId()) + &quot;&lt;/td&gt;&lt;td&gt;&quot; +</span>
<span class="nc" id="L3894">           getFilename() + &quot;&lt;/td&gt;&lt;td&gt;&quot; + getFileInformation() + '[' +</span>
<span class="nc" id="L3895">           getTransferInfo() + ']' + &quot;&lt;/td&gt;&lt;td bgcolor=\&quot;&quot; + color + &quot;\&quot;&gt;&quot; +</span>
<span class="nc" id="L3896">           getGlobalStep() + &quot; (&quot; + getGloballaststep() + &quot;)&lt;/td&gt;&lt;td&gt;&quot; +</span>
<span class="nc" id="L3897">           getStep() + &quot;&lt;/td&gt;&lt;td&gt;&quot; + getStatus().getMesg() + &quot; &lt;b&gt;&quot; + running +</span>
           &quot;&lt;/b&gt;&lt;/td&gt;&lt;td bgcolor=\&quot;&quot; + updcolor + &quot;\&quot;&gt;&quot; +
<span class="nc" id="L3899">           getUpdatedInfo().name() + &quot; : &quot; + getErrorInfo().getMesg() +</span>
<span class="nc" id="L3900">           &quot;&lt;/td&gt;&lt;td&gt;&quot; + getRank() + &quot;&lt;/td&gt;&lt;td&gt;&quot; + getBlocksize() +</span>
<span class="nc" id="L3901">           &quot;&lt;/td&gt;&lt;td&gt;&quot; + isFileMoved() + &quot;&lt;/td&gt;&lt;td&gt;&quot; + getRequester() +</span>
<span class="nc" id="L3902">           &quot;&lt;/td&gt;&lt;td&gt;&quot; + getRequested() + &quot;&lt;/td&gt;&lt;td&gt;&quot; + getStart() +</span>
<span class="nc" id="L3903">           &quot;&lt;/td&gt;&lt;td&gt;&quot; + getStop() + &quot;&lt;/td&gt;&lt;td&gt;&quot; + bandwidthMB() + &quot;&lt;/td&gt;&quot; +</span>
           &quot;&lt;td&gt;&quot; + freespace + &quot;&lt;/td&gt;&quot;;
  }

  /**
   * @param session
   * @param body
   * @param running special info
   *
   * @return the runner in Html format specified by body by replacing all
   *     instance of fields
   */
  public final String toSpecializedHtml(final R66Session session,
                                        final String body,
                                        final String running) {
<span class="nc" id="L3918">    final long freespace = freespaceMB(session);</span>
<span class="nc" id="L3919">    final StringBuilder builder = new StringBuilder(body);</span>
<span class="nc" id="L3920">    WaarpStringUtils.replaceAll(builder, &quot;XXXSpecIdXXX&quot;,</span>
<span class="nc" id="L3921">                                Long.toString(getSpecialId()));</span>
<span class="nc bnc" id="L3922" title="All 2 branches missed.">    WaarpStringUtils.replace(builder, &quot;XXXRulXXX&quot;,</span>
<span class="nc" id="L3923">                             rule != null? rule.toShortString() :</span>
                                 &quot;&lt;p style='color:red'&gt;Rule Name:&quot; +
<span class="nc" id="L3925">                                 getRuleId() +</span>
                                 &quot; &lt;em&gt;(rule not found)&lt;/em&gt;&lt;/p&gt;&quot;);
<span class="nc" id="L3927">    WaarpStringUtils.replace(builder, &quot;XXXFileXXX&quot;, getFilename());</span>
<span class="nc" id="L3928">    WaarpStringUtils.replace(builder, &quot;XXXInfoXXX&quot;, getFileInformation());</span>
<span class="nc" id="L3929">    WaarpStringUtils.replace(builder, &quot;XXXTransXXX&quot;, getTransferInfo());</span>
<span class="nc" id="L3930">    WaarpStringUtils.replace(builder, &quot;XXXStepXXX&quot;,</span>
<span class="nc" id="L3931">                             getGlobalStep() + &quot; (&quot; + getGloballaststep() +</span>
                             ')');
<span class="nc" id="L3933">    WaarpStringUtils.replace(builder, &quot;XXXCOLXXX&quot;, getHtmlColor());</span>
<span class="nc" id="L3934">    WaarpStringUtils.replace(builder, &quot;XXXActXXX&quot;, Integer.toString(getStep()));</span>
<span class="nc" id="L3935">    WaarpStringUtils.replace(builder, &quot;XXXStatXXX&quot;,</span>
<span class="nc" id="L3936">                             pojo.getStepStatus().getMesg());</span>
<span class="nc" id="L3937">    WaarpStringUtils.replace(builder, &quot;XXXRunningXXX&quot;, running);</span>
<span class="nc" id="L3938">    WaarpStringUtils.replace(builder, &quot;XXXInternXXX&quot;,</span>
<span class="nc" id="L3939">                             getUpdatedInfo().name() + &quot; : &quot; +</span>
<span class="nc" id="L3940">                             getErrorInfo().getMesg());</span>
<span class="nc" id="L3941">    WaarpStringUtils.replace(builder, &quot;XXXUPDCOLXXX&quot;, getInfoHtmlColor());</span>
<span class="nc" id="L3942">    WaarpStringUtils.replace(builder, &quot;XXXBloXXX&quot;, Integer.toString(getRank()));</span>
<span class="nc" id="L3943">    WaarpStringUtils.replace(builder, &quot;XXXisSendXXX&quot;,</span>
<span class="nc" id="L3944">                             Boolean.toString(isSender()));</span>
<span class="nc" id="L3945">    WaarpStringUtils.replace(builder, &quot;XXXisMovXXX&quot;,</span>
<span class="nc" id="L3946">                             Boolean.toString(isFileMoved()));</span>
<span class="nc" id="L3947">    WaarpStringUtils.replace(builder, &quot;XXXModXXX&quot;,</span>
<span class="nc" id="L3948">                             TRANSFERMODE.values()[getMode()].toString());</span>
<span class="nc" id="L3949">    WaarpStringUtils.replaceAll(builder, &quot;XXXReqrXXX&quot;, getRequester());</span>
<span class="nc" id="L3950">    WaarpStringUtils.replaceAll(builder, &quot;XXXReqdXXX&quot;, getRequested());</span>
<span class="nc" id="L3951">    WaarpStringUtils.replace(builder, &quot;XXXStarXXX&quot;, getStart().toString());</span>
<span class="nc" id="L3952">    WaarpStringUtils.replace(builder, &quot;XXXStopXXX&quot;, getStop().toString());</span>
<span class="nc" id="L3953">    WaarpStringUtils.replace(builder, &quot;XXXBandXXX&quot;, bandwidthMB());</span>
<span class="nc" id="L3954">    WaarpStringUtils.replace(builder, &quot;XXXFreeXXX&quot;, Long.toString(freespace));</span>
<span class="nc" id="L3955">    return builder.toString();</span>
  }

  /**
   * @return True if the current host is the requested host but not requester
   *     (to prevent request to itself)
   */
  public final boolean isRequestOnRequested() {
<span class="fc bfc" id="L3963" title="All 2 branches covered.">    if (pojo.getRequested().equals(Configuration.configuration.getHostId()) ||</span>
<span class="fc" id="L3964">        pojo.getRequested()</span>
<span class="fc bfc" id="L3965" title="All 2 branches covered.">            .equals(Configuration.configuration.getHostSslId())) {</span>
      // check if not calling itself
<span class="fc" id="L3967">      return !pojo.getRequester()</span>
<span class="fc bfc" id="L3968" title="All 2 branches covered.">                  .equals(Configuration.configuration.getHostId()) &amp;&amp;</span>
<span class="fc" id="L3969">             !pojo.getRequester()</span>
<span class="fc bfc" id="L3970" title="All 2 branches covered.">                  .equals(Configuration.configuration.getHostSslId());</span>
    }
<span class="fc" id="L3972">    return false;</span>
  }

  /**
   * @return True if this is a self request and current action is on Requested
   */
  public final boolean shallIgnoreSave() {
<span class="fc bfc" id="L3979" title="All 6 branches covered.">    return isSelfRequest() &amp;&amp; (isSessionSender() &amp;&amp; getRule().isSendMode() ||</span>
<span class="fc bfc" id="L3980" title="All 4 branches covered.">                               !isSessionSender() &amp;&amp; getRule().isRecvMode());</span>
  }

  /**
   * @return True if the request is a self request (same host on both side)
   */
  public final boolean isSelfRequest() {
<span class="fc" id="L3987">    return</span>
<span class="fc bfc" id="L3988" title="All 2 branches covered.">        (pojo.getRequested().equals(Configuration.configuration.getHostId()) ||</span>
<span class="fc" id="L3989">         pojo.getRequested()</span>
<span class="fc bfc" id="L3990" title="All 2 branches covered.">             .equals(Configuration.configuration.getHostSslId())) &amp;&amp;</span>
<span class="fc bfc" id="L3991" title="All 2 branches covered.">        (pojo.getRequester().equals(Configuration.configuration.getHostId()) ||</span>
<span class="fc" id="L3992">         pojo.getRequester()</span>
<span class="fc bfc" id="L3993" title="All 2 branches covered.">             .equals(Configuration.configuration.getHostSslId()));</span>
  }

  /**
   * @return the requested HostId
   */
  public final String getRequested() {
<span class="fc" id="L4000">    return pojo.getRequested();</span>
  }

  /**
   * @return the requester HostId
   */
  public final String getRequester() {
<span class="fc" id="L4007">    return pojo.getRequester();</span>
  }

  /**
   * @return the start
   */
  public final Timestamp getStart() {
<span class="fc" id="L4014">    return pojo.getStart();</span>
  }

  /**
   * @param start new Start time to apply when reschedule
   */
  public final void setStart(final Timestamp start) {
<span class="pc bpc" id="L4021" title="2 of 4 branches missed.">    if (pojo.getStart() == null || !pojo.getStart().equals(start)) {</span>
<span class="fc" id="L4022">      pojo.setStart(start);</span>
<span class="fc" id="L4023">      isOtherThanStatus = true;</span>
<span class="fc" id="L4024">      isSaved = false;</span>
    }
<span class="fc" id="L4026">  }</span>

  /**
   * @return the stop
   */
  public final Timestamp getStop() {
<span class="fc" id="L4032">    return pojo.getStop();</span>
  }

  public final void setStop(final Timestamp stop) {
<span class="nc bnc" id="L4036" title="All 4 branches missed.">    if (pojo.getStop() == null || !pojo.getStop().equals(stop)) {</span>
<span class="nc" id="L4037">      pojo.setStop(stop);</span>
<span class="nc" id="L4038">      isSaved = false;</span>
    }
<span class="nc" id="L4040">  }</span>

  /**
   * @return the associated request
   */
  public final RequestPacket getRequest() {
    final String sep;
<span class="fc bfc" id="L4047" title="All 2 branches covered.">    if (pojo.getRequested().equals(Configuration.configuration.getHostId()) ||</span>
<span class="fc" id="L4048">        pojo.getRequested()</span>
<span class="fc bfc" id="L4049" title="All 2 branches covered.">            .equals(Configuration.configuration.getHostSslId())) {</span>
<span class="fc" id="L4050">      sep = PartnerConfiguration.getSeparator(pojo.getRequester());</span>
    } else {
<span class="fc" id="L4052">      sep = PartnerConfiguration.getSeparator(pojo.getRequested());</span>
    }
<span class="fc" id="L4054">    return new RequestPacket(pojo.getRule(), pojo.getTransferMode(),</span>
<span class="fc" id="L4055">                             pojo.getOriginalName(), pojo.getBlockSize(),</span>
<span class="fc" id="L4056">                             pojo.getRank(), pojo.getId(), pojo.getFileInfo(),</span>
                             originalSize, sep);
  }

  /**
   * Used internally
   *
   * @return a Key representing the primary key as a unique string
   */
  public final String getKey() {
<span class="fc" id="L4066">    return pojo.getRequested() + ' ' + pojo.getRequester() + ' ' + pojo.getId();</span>
  }

  /**
   * Construct a new Element with value
   *
   * @param name
   * @param value
   *
   * @return the new Element
   */
  private static Element newElement(final String name, final String value) {
<span class="fc" id="L4078">    final Element node = new DefaultElement(name);</span>
<span class="pc bpc" id="L4079" title="1 of 2 branches missed.">    if (value != null) {</span>
<span class="fc" id="L4080">      node.addText(value);</span>
    }
<span class="fc" id="L4082">    return node;</span>
  }

  private static Object getValue(final DbTaskRunner runner,
                                 final String field) {
<span class="fc" id="L4087">    final Columns column = Columns.valueOf(field.toUpperCase());</span>
<span class="pc bpc" id="L4088" title="3 of 23 branches missed.">    switch (column) {</span>
      case GLOBALSTEP:
<span class="fc" id="L4090">        return runner.pojo.getGlobalStep().ordinal();</span>
      case GLOBALLASTSTEP:
<span class="fc" id="L4092">        return runner.pojo.getLastGlobalStep().ordinal();</span>
      case STEP:
<span class="fc" id="L4094">        return runner.pojo.getStep();</span>
      case RANK:
<span class="fc" id="L4096">        return runner.pojo.getRank();</span>
      case STEPSTATUS:
<span class="fc" id="L4098">        return runner.pojo.getStepStatus().getCode();</span>
      case RETRIEVEMODE:
<span class="fc" id="L4100">        return runner.pojo.getRetrieveMode();</span>
      case FILENAME:
<span class="fc" id="L4102">        return runner.pojo.getFilename();</span>
      case ISMOVED:
<span class="fc" id="L4104">        return runner.pojo.getIsMoved();</span>
      case IDRULE:
<span class="fc" id="L4106">        return runner.pojo.getRule();</span>
      case BLOCKSZ:
<span class="fc" id="L4108">        return runner.pojo.getBlockSize();</span>
      case ORIGINALNAME:
<span class="fc" id="L4110">        return runner.pojo.getOriginalName();</span>
      case FILEINFO:
<span class="fc" id="L4112">        return runner.pojo.getFileInfo();</span>
      case TRANSFERINFO:
<span class="nc" id="L4114">        return runner.getTransferInfo();</span>
      case MODETRANS:
<span class="fc" id="L4116">        return runner.pojo.getTransferMode();</span>
      case STARTTRANS:
<span class="fc" id="L4118">        return runner.pojo.getStart();</span>
      case STOPTRANS:
<span class="fc" id="L4120">        return runner.pojo.getStop();</span>
      case INFOSTATUS:
<span class="fc" id="L4122">        return runner.pojo.getInfoStatus().getCode();</span>
      case UPDATEDINFO:
<span class="nc" id="L4124">        return runner.pojo.getUpdatedInfo().ordinal();</span>
      case OWNERREQ:
<span class="fc" id="L4126">        return runner.pojo.getOwnerRequest();</span>
      case REQUESTER:
<span class="fc" id="L4128">        return runner.pojo.getRequester();</span>
      case REQUESTED:
<span class="fc" id="L4130">        return runner.pojo.getRequested();</span>
      case SPECIALID:
<span class="fc" id="L4132">        return runner.pojo.getId();</span>
      default:
<span class="nc" id="L4134">        throw new IllegalArgumentException(&quot;Field unknown: &quot; + column.name());</span>
    }
  }

  /**
   * Need to call 'setToArray' before
   *
   * @param runner
   *
   * @return The Element representing the given Runner
   */
  private static Element getElementFromRunner(final DbTaskRunner runner) {
<span class="fc" id="L4146">    final Element root = new DefaultElement(XMLRUNNER);</span>
<span class="fc bfc" id="L4147" title="All 2 branches covered.">    for (final Columns column : Columns.values()) {</span>
<span class="fc bfc" id="L4148" title="All 2 branches covered.">      if (column.name().equals(Columns.UPDATEDINFO.name()) ||</span>
<span class="fc bfc" id="L4149" title="All 2 branches covered.">          column.name().equals(Columns.TRANSFERINFO.name())) {</span>
<span class="fc" id="L4150">        continue;</span>
      }
<span class="fc" id="L4152">      root.add(newElement(column.name().toLowerCase(),</span>
<span class="fc" id="L4153">                          getValue(runner, column.name()).toString()));</span>
    }
<span class="fc" id="L4155">    return root;</span>
  }

  /**
   * Write the selected TaskRunners from PrepareStatement to a XMLWriter
   *
   * @param preparedStatement ready to be executed
   * @param xmlWriter
   *
   * @return the NbAndSpecialId for the number of transfer and higher rank
   *     found
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   * @throws OpenR66ProtocolBusinessException
   */
  public static NbAndSpecialId writeXML(
      final DbPreparedStatement preparedStatement, final XMLWriter xmlWriter)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException,
             OpenR66ProtocolBusinessException {
<span class="fc" id="L4175">    final Element root = new DefaultElement(XMLRUNNERS);</span>
<span class="fc" id="L4176">    final NbAndSpecialId nbAndSpecialId = new NbAndSpecialId();</span>
    try {
<span class="fc" id="L4178">      xmlWriter.writeOpen(root);</span>
      Element node;
<span class="fc bfc" id="L4180" title="All 2 branches covered.">      while (preparedStatement.getNext()) {</span>
<span class="fc" id="L4181">        final DbTaskRunner runner = getFromStatementNoRule(preparedStatement);</span>
<span class="fc bfc" id="L4182" title="All 2 branches covered.">        if (nbAndSpecialId.higherSpecialId &lt; runner.getSpecialId()) {</span>
<span class="fc" id="L4183">          nbAndSpecialId.higherSpecialId = runner.getSpecialId();</span>
        }
<span class="fc" id="L4185">        node = getElementFromRunner(runner);</span>
<span class="fc" id="L4186">        xmlWriter.write(node);</span>
<span class="fc" id="L4187">        xmlWriter.flush();</span>
<span class="fc" id="L4188">        nbAndSpecialId.nb++;</span>
<span class="fc" id="L4189">      }</span>
<span class="fc" id="L4190">      xmlWriter.writeClose(root);</span>
<span class="nc" id="L4191">    } catch (final IOException e) {</span>
<span class="nc" id="L4192">      logger.error(CANNOT_WRITE_XML_FILE + &quot;: {}&quot;, e.getMessage());</span>
<span class="nc" id="L4193">      throw new OpenR66ProtocolBusinessException(</span>
<span class="nc" id="L4194">          &quot;Cannot write file: &quot; + e.getMessage());</span>
<span class="fc" id="L4195">    }</span>
<span class="fc" id="L4196">    return nbAndSpecialId;</span>
  }

  /**
   * Write selected TaskRunners to a Json String
   *
   * @param preparedStatement
   *
   * @return the associated Json String
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   */
  public static String getJson(final DbPreparedStatement preparedStatement,
                               final int limit)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
<span class="fc" id="L4212">    final ArrayNode arrayNode = JsonHandler.createArrayNode();</span>
    try {
<span class="fc" id="L4214">      preparedStatement.executeQuery();</span>
<span class="fc" id="L4215">      final LocalTransaction localTransaction =</span>
<span class="fc" id="L4216">          Configuration.configuration.getLocalTransaction();</span>
<span class="fc" id="L4217">      int nb = 0;</span>
<span class="fc bfc" id="L4218" title="All 2 branches covered.">      while (preparedStatement.getNext()) {</span>
<span class="fc" id="L4219">        final DbTaskRunner runner = getFromStatementNoRule(preparedStatement);</span>
<span class="fc" id="L4220">        final ObjectNode node = runner.getJson();</span>
<span class="fc" id="L4221">        node.put(Columns.SPECIALID.name(),</span>
<span class="fc" id="L4222">                 Long.toString(runner.getSpecialId()));</span>
<span class="pc bpc" id="L4223" title="1 of 2 branches missed.">        if (localTransaction == null) {</span>
<span class="nc" id="L4224">          node.put(&quot;Running&quot;, false);</span>
        } else {
<span class="fc" id="L4226">          node.put(&quot;Running&quot;, localTransaction.contained(runner.getKey()));</span>
        }
<span class="fc" id="L4228">        arrayNode.add(node);</span>
<span class="fc" id="L4229">        nb++;</span>
<span class="pc bpc" id="L4230" title="1 of 2 branches missed.">        if (nb &gt;= limit) {</span>
<span class="nc" id="L4231">          break;</span>
        }
<span class="fc" id="L4233">      }</span>
    } finally {
<span class="fc" id="L4235">      preparedStatement.realClose();</span>
    }
<span class="fc" id="L4237">    return WaarpStringUtils.cleanJsonForHtml(</span>
<span class="fc" id="L4238">        JsonHandler.writeAsString(arrayNode)</span>
<span class="fc" id="L4239">                   .replaceAll(&quot;(\\\&quot;\\{)([^}]+)(\\}\\\&quot;)&quot;, &quot;\&quot;{$2}\&quot;&quot;)</span>
<span class="fc" id="L4240">                   .replaceAll(&quot;([^\\\\])(\\\\\&quot;)([a-zA-Z_0-9]+)(\\\\\&quot;)&quot;,</span>
                               &quot;$1\\\\\&quot;$3\\\\\&quot;&quot;));
  }

  /**
   * Write selected TaskRunners to an XML file using an XMLWriter
   *
   * @param preparedStatement
   * @param filename
   *
   * @return the NbAndSpecialId for the number of transfer and higher rank
   *     found
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   * @throws OpenR66ProtocolBusinessException
   */
  public static NbAndSpecialId writeXMLWriter(
      final DbPreparedStatement preparedStatement, final String filename)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException,
             OpenR66ProtocolBusinessException {
    NbAndSpecialId nbAndSpecialId;
<span class="fc" id="L4262">    OutputStream outputStream = null;</span>
<span class="fc" id="L4263">    XMLWriter xmlWriter = null;</span>
<span class="fc" id="L4264">    boolean isOk = false;</span>
    try {
<span class="fc" id="L4266">      outputStream = new FileOutputStream(filename);</span>
<span class="fc" id="L4267">      final OutputFormat format = OutputFormat.createPrettyPrint();</span>
<span class="fc" id="L4268">      format.setEncoding(WaarpStringUtils.UTF_8);</span>
<span class="fc" id="L4269">      xmlWriter = new XMLWriter(outputStream, format);</span>
<span class="fc" id="L4270">      preparedStatement.executeQuery();</span>
<span class="fc" id="L4271">      nbAndSpecialId = writeXML(preparedStatement, xmlWriter);</span>
<span class="fc" id="L4272">      isOk = true;</span>
<span class="nc" id="L4273">    } catch (final FileNotFoundException e) {</span>
<span class="nc" id="L4274">      logger.error(CANNOT_WRITE_XML_FILE + &quot;: {}&quot;, e.getMessage());</span>
<span class="nc" id="L4275">      throw new OpenR66ProtocolBusinessException(&quot;File not found&quot;);</span>
<span class="nc" id="L4276">    } catch (final UnsupportedEncodingException e) {</span>
<span class="nc" id="L4277">      logger.error(CANNOT_WRITE_XML_FILE + &quot;: {}&quot;, e.getMessage());</span>
<span class="nc" id="L4278">      throw new OpenR66ProtocolBusinessException(UNSUPPORTED_ENCODING);</span>
    } finally {
<span class="pc bpc" id="L4280" title="1 of 2 branches missed.">      if (xmlWriter != null) {</span>
        try {
<span class="fc" id="L4282">          xmlWriter.endDocument();</span>
<span class="fc" id="L4283">          xmlWriter.flush();</span>
<span class="fc" id="L4284">          xmlWriter.close();</span>
<span class="nc" id="L4285">        } catch (final SAXException e) {</span>
<span class="nc" id="L4286">          FileUtils.close(outputStream);</span>
<span class="nc" id="L4287">          final File file = new File(filename);</span>
<span class="nc bnc" id="L4288" title="All 2 branches missed.">          if (!file.delete()) {</span>
<span class="nc" id="L4289">            logger.info(CANNOT_DELETE_WRONG_XML_FILE);</span>
          }
<span class="nc" id="L4291">          logger.error(CANNOT_WRITE_XML_FILE + &quot;: {}&quot;, e.getMessage());</span>
<span class="nc" id="L4292">          throw new OpenR66ProtocolBusinessException(//NOSONAR</span>
                                                     UNSUPPORTED_ENCODING);//NOSONAR
<span class="nc" id="L4294">        } catch (final IOException e) {</span>
<span class="nc" id="L4295">          FileUtils.close(outputStream);</span>
<span class="nc" id="L4296">          final File file = new File(filename);</span>
<span class="nc bnc" id="L4297" title="All 2 branches missed.">          if (!file.delete()) {</span>
<span class="nc" id="L4298">            logger.info(CANNOT_DELETE_WRONG_XML_FILE);</span>
          }
<span class="nc" id="L4300">          logger.error(CANNOT_WRITE_XML_FILE + &quot;: {}&quot;, e.getMessage());</span>
<span class="nc" id="L4301">          throw new OpenR66ProtocolBusinessException(//NOSONAR</span>
                                                     UNSUPPORTED_ENCODING);//NOSONAR
<span class="fc" id="L4303">        }</span>
<span class="pc bpc" id="L4304" title="1 of 2 branches missed.">        if (!isOk) {</span>
<span class="nc" id="L4305">          FileUtils.close(outputStream);</span>
<span class="nc" id="L4306">          final File file = new File(filename);</span>
<span class="nc bnc" id="L4307" title="All 2 branches missed.">          if (!file.delete()) {</span>
<span class="nc" id="L4308">            logger.info(&quot;Cannot delete wrong  XML file&quot;);</span>
          }
<span class="nc" id="L4310">        }</span>
<span class="nc bnc" id="L4311" title="All 2 branches missed.">      } else if (outputStream != null) {</span>
<span class="nc" id="L4312">        FileUtils.close(outputStream);</span>
<span class="nc" id="L4313">        final File file = new File(filename);</span>
<span class="nc bnc" id="L4314" title="All 2 branches missed.">        if (!file.delete()) {</span>
<span class="nc" id="L4315">          logger.debug(&quot;Cannot delete not written XML file&quot;);</span>
        }
      }
    }
<span class="fc" id="L4319">    return nbAndSpecialId;</span>
  }

  /**
   * Write all TaskRunners to an XML file using an XMLWriter
   *
   * @param filename
   *
   * @throws WaarpDatabaseNoConnectionException
   * @throws WaarpDatabaseSqlException
   * @throws OpenR66ProtocolBusinessException
   */
  public static void writeXMLWriter(final String filename)
      throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException,
             OpenR66ProtocolBusinessException {
<span class="nc" id="L4334">    final String request =</span>
        &quot;SELECT &quot; + selectAllFields + &quot; FROM &quot; + table + &quot; WHERE &quot; +
<span class="nc" id="L4336">        getLimitWhereCondition();</span>
<span class="nc" id="L4337">    DbPreparedStatement preparedStatement = null;</span>
    try {
<span class="nc" id="L4339">      preparedStatement = new DbPreparedStatement(admin.getSession());</span>
<span class="nc" id="L4340">      preparedStatement.createPrepareStatement(request);</span>
<span class="nc" id="L4341">      writeXMLWriter(preparedStatement, filename);</span>
    } finally {
<span class="nc bnc" id="L4343" title="All 2 branches missed.">      if (preparedStatement != null) {</span>
<span class="nc" id="L4344">        preparedStatement.realClose();</span>
      }
    }
<span class="nc" id="L4347">  }</span>

  /**
   * @return the backend XML filename for the current TaskRunner in NoDb
   *     Client mode
   */
  public final String backendXmlFilename() {
<span class="nc" id="L4354">    return Configuration.configuration.getBaseDirectory() +</span>
<span class="nc" id="L4355">           Configuration.configuration.getArchivePath() +</span>
<span class="nc" id="L4356">           DirInterface.SEPARATOR + pojo.getRequester() + '_' +</span>
<span class="nc" id="L4357">           pojo.getRequested() + '_' + pojo.getId() + XMLEXTENSION;</span>
  }

  /**
   * @return the runner as XML
   */
  public final String asXML() {
<span class="fc" id="L4364">    final Element node = getElementFromRunner(this);</span>
<span class="fc" id="L4365">    return node.asXML();</span>
  }

  @Override
  public final ObjectNode getJson() {
<span class="fc" id="L4370">    final String nomap = pojo.getTransferInfo();</span>
<span class="fc" id="L4371">    pojo.setTransferInfo(getTransferInfo());</span>
<span class="fc" id="L4372">    final ObjectNode node = super.getJson();</span>
<span class="fc" id="L4373">    pojo.setTransferInfo(nomap);</span>
<span class="fc" id="L4374">    JsonNode value = node.get(Columns.FILEINFO.name());</span>
<span class="fc" id="L4375">    node.put(Columns.FILEINFO.name(), value.asText().replaceAll(&quot;[\\\\]+&quot;, &quot;&quot;));</span>
<span class="fc" id="L4376">    value = node.get(Columns.TRANSFERINFO.name());</span>
<span class="fc" id="L4377">    node.put(Columns.TRANSFERINFO.name(),</span>
<span class="fc" id="L4378">             value.asText().replaceAll(&quot;[\\\\]+&quot;, &quot;&quot;));</span>
<span class="pc bpc" id="L4379" title="1 of 2 branches missed.">    if (rescheduledTransfer) {</span>
<span class="nc" id="L4380">      node.put(JSON_RESCHEDULE, true);</span>
    }
<span class="pc bpc" id="L4382" title="2 of 4 branches missed.">    if (isRecvThrough || isSendThrough) {</span>
<span class="nc" id="L4383">      node.put(JSON_THROUGHMODE, true);</span>
    }
<span class="fc" id="L4385">    node.put(JSON_ORIGINALSIZE, originalSize);</span>
<span class="fc" id="L4386">    final String followId = getFollowId();</span>
<span class="fc bfc" id="L4387" title="All 2 branches covered.">    if (followId != null) {</span>
<span class="fc" id="L4388">      node.put(FOLLOW_JSON_KEY, followId);</span>
    } else {
<span class="fc" id="L4390">      node.put(FOLLOW_JSON_KEY, &quot;&quot;);</span>
    }
<span class="fc" id="L4392">    return node;</span>
  }

  @Override
  protected final void setFromJson(final String field, final JsonNode value) {
<span class="pc bpc" id="L4397" title="1 of 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L4398">      return;</span>
    }
<span class="fc" id="L4400">    isSaved = false;</span>
<span class="fc" id="L4401">    isOtherThanStatus = true;</span>
<span class="fc bfc" id="L4402" title="All 2 branches covered.">    for (final Columns column : Columns.values()) {</span>
<span class="fc bfc" id="L4403" title="All 2 branches covered.">      if (column.name().equalsIgnoreCase(field)) {</span>
<span class="pc bpc" id="L4404" title="3 of 23 branches missed.">        switch (column) {</span>
          case BLOCKSZ:
<span class="fc" id="L4406">            pojo.setBlockSize(value.asInt());</span>
<span class="fc" id="L4407">            break;</span>
          case FILEINFO:
<span class="fc" id="L4409">            pojo.setFileInfo(value.asText());</span>
<span class="fc" id="L4410">            break;</span>
          case FILENAME:
<span class="fc" id="L4412">            pojo.setFilename(value.asText());</span>
<span class="fc" id="L4413">            break;</span>
          case GLOBALLASTSTEP:
<span class="fc" id="L4415">            pojo.setLastGlobalStep(Transfer.TASKSTEP.valueOf(value.asInt()));</span>
<span class="fc" id="L4416">            break;</span>
          case GLOBALSTEP:
<span class="fc" id="L4418">            pojo.setGlobalStep(Transfer.TASKSTEP.valueOf(value.asInt()));</span>
<span class="fc" id="L4419">            break;</span>
          case IDRULE:
<span class="fc" id="L4421">            pojo.setRule(value.asText());</span>
<span class="fc" id="L4422">            break;</span>
          case INFOSTATUS:
<span class="fc" id="L4424">            pojo.setInfoStatus(ErrorCode.getFromCode(value.asText()));</span>
<span class="fc" id="L4425">            break;</span>
          case ISMOVED:
<span class="fc" id="L4427">            pojo.setIsMoved(value.asBoolean());</span>
<span class="fc" id="L4428">            break;</span>
          case MODETRANS:
<span class="fc" id="L4430">            pojo.setTransferMode(value.asInt());</span>
<span class="fc" id="L4431">            break;</span>
          case ORIGINALNAME:
<span class="fc" id="L4433">            pojo.setOriginalName(value.asText());</span>
<span class="fc" id="L4434">            break;</span>
          case OWNERREQ:
<span class="fc" id="L4436">            String owner = value.asText();</span>
<span class="pc bpc" id="L4437" title="1 of 2 branches missed.">            if (ParametersChecker.isEmpty(owner)) {</span>
<span class="nc" id="L4438">              owner = Configuration.configuration.getHostId();</span>
            }
<span class="fc" id="L4440">            pojo.setOwnerRequest(owner);</span>
<span class="fc" id="L4441">            break;</span>
          case RANK:
<span class="fc" id="L4443">            pojo.setRank(value.asInt());</span>
<span class="fc" id="L4444">            break;</span>
          case REQUESTED:
<span class="fc" id="L4446">            pojo.setRequested(value.asText());</span>
<span class="fc" id="L4447">            break;</span>
          case REQUESTER:
<span class="fc" id="L4449">            pojo.setRequester(value.asText());</span>
<span class="fc" id="L4450">            break;</span>
          case RETRIEVEMODE:
<span class="fc" id="L4452">            pojo.setRetrieveMode(value.asBoolean());</span>
<span class="fc" id="L4453">            break;</span>
          case SPECIALID:
<span class="fc" id="L4455">            pojo.setId(value.asLong());</span>
<span class="fc" id="L4456">            break;</span>
          case STARTTRANS:
<span class="fc" id="L4458">            long start = value.asLong();</span>
<span class="pc bpc" id="L4459" title="1 of 2 branches missed.">            if (start == 0) {</span>
<span class="fc" id="L4460">              start = System.currentTimeMillis();</span>
            }
<span class="fc" id="L4462">            pojo.setStart(new Timestamp(start));</span>
<span class="fc" id="L4463">            break;</span>
          case STEP:
<span class="fc" id="L4465">            pojo.setStep(value.asInt());</span>
<span class="fc" id="L4466">            break;</span>
          case STEPSTATUS:
<span class="fc" id="L4468">            pojo.setStepStatus(ErrorCode.getFromCode(value.asText()));</span>
<span class="fc" id="L4469">            break;</span>
          case STOPTRANS:
<span class="fc" id="L4471">            long stop = value.asLong();</span>
<span class="pc bpc" id="L4472" title="1 of 2 branches missed.">            if (stop == 0) {</span>
<span class="fc" id="L4473">              stop = System.currentTimeMillis();</span>
            }
<span class="fc" id="L4475">            pojo.setStop(new Timestamp(stop));</span>
<span class="fc" id="L4476">            break;</span>
          case TRANSFERINFO: {
<span class="nc" id="L4478">            String text = value.asText().trim();</span>
<span class="nc bnc" id="L4479" title="All 2 branches missed.">            if (text.isEmpty()) {</span>
<span class="nc" id="L4480">              text = &quot;{}&quot;;</span>
<span class="nc bnc" id="L4481" title="All 2 branches missed.">              if (transferMap != null) {</span>
<span class="nc" id="L4482">                transferMap.clear();</span>
              }
<span class="nc" id="L4484">              transferMap = null;</span>
            }
<span class="nc" id="L4486">            pojo.setTransferInfo(text);</span>
<span class="nc" id="L4487">            break;</span>
          }
          case UPDATEDINFO:
<span class="nc" id="L4490">            pojo.setUpdatedInfo(</span>
<span class="nc" id="L4491">                org.waarp.openr66.pojo.UpdatedInfo.valueOf(value.asInt()));</span>
            break;
        }
      }
    }
<span class="fc" id="L4496">    setMapFromFileInfo();</span>
<span class="fc" id="L4497">  }</span>

  /**
   * @return the Json string for this
   */
  public final String getJsonAsString() {
<span class="nc" id="L4503">    final ObjectNode node = getJson();</span>
<span class="nc" id="L4504">    node.put(Columns.SPECIALID.name(), Long.toString(pojo.getId()));</span>
<span class="nc" id="L4505">    final LocalTransaction localTransaction =</span>
<span class="nc" id="L4506">        Configuration.configuration.getLocalTransaction();</span>
<span class="nc bnc" id="L4507" title="All 2 branches missed.">    if (localTransaction == null) {</span>
<span class="nc" id="L4508">      node.put(&quot;Running&quot;, false);</span>
    } else {
<span class="nc" id="L4510">      node.put(&quot;Running&quot;, localTransaction.contained(getKey()));</span>
    }
<span class="nc" id="L4512">    return WaarpStringUtils.cleanJsonForHtml(JsonHandler.writeAsString(node));</span>
  }

  /**
   * Set the given runner from the root element of the runner itself
   * (XMLRUNNER but not XMLRUNNERS).
   *
   * @param runner
   * @param root
   */
  private static void setRunnerFromElementNoException(final DbTaskRunner runner,
                                                      final Element root) {
<span class="fc" id="L4524">    final ObjectNode node = JsonHandler.createObjectNode();</span>
<span class="fc bfc" id="L4525" title="All 2 branches covered.">    for (final Columns column : Columns.values()) {</span>
<span class="fc bfc" id="L4526" title="All 2 branches covered.">      if (column.name().equals(Columns.UPDATEDINFO.name()) ||</span>
<span class="fc bfc" id="L4527" title="All 2 branches covered.">          column.name().equals(Columns.TRANSFERINFO.name())) {</span>
<span class="fc" id="L4528">        continue;</span>
      }
<span class="fc" id="L4530">      final Element elt =</span>
<span class="fc" id="L4531">          (Element) root.selectSingleNode(column.name().toLowerCase());</span>
<span class="pc bpc" id="L4532" title="1 of 2 branches missed.">      if (elt != null) {</span>
<span class="fc" id="L4533">        final String newValue = elt.getText();</span>
<span class="fc" id="L4534">        node.put(column.name(), newValue);</span>
<span class="fc" id="L4535">        runner.setFromJson(column.name(), node.findValue(column.name()));</span>
<span class="fc" id="L4536">        node.removeAll();</span>
      }
    }
<span class="fc" id="L4539">    runner.pojo.setTransferInfo(&quot;{}&quot;);</span>
<span class="pc bpc" id="L4540" title="1 of 2 branches missed.">    if (runner.transferMap != null) {</span>
<span class="fc" id="L4541">      runner.transferMap.clear();</span>
    }
<span class="fc" id="L4543">    runner.transferMap = null;</span>
<span class="fc" id="L4544">    runner.isOtherThanStatus = true;</span>
<span class="fc" id="L4545">    runner.isSaved = false;</span>
<span class="fc" id="L4546">  }</span>

  /**
   * Reload a to submitted runner from a remote partner's log (so reversing
   * isSender should be true)
   *
   * @param xml
   * @param reverse
   *
   * @return the TaskRunner from the XML source element
   *
   * @throws OpenR66ProtocolBusinessException
   */
  public static DbTaskRunner fromStringXml(final String xml,
                                           final boolean reverse)
      throws OpenR66ProtocolBusinessException {
    final Document document;
    try {
<span class="fc" id="L4564">      document = DocumentHelper.parseText(xml);</span>
<span class="nc" id="L4565">    } catch (final DocumentException e1) {</span>
<span class="nc" id="L4566">      logger.warn(&quot;Cant parse XML&quot; + &quot; : {}&quot;, e1.getMessage());</span>
<span class="nc" id="L4567">      throw new OpenR66ProtocolBusinessException(&quot;Cannot parse the XML input&quot;);</span>
<span class="fc" id="L4568">    }</span>
<span class="fc" id="L4569">    final DbTaskRunner runner = new DbTaskRunner();</span>
<span class="fc" id="L4570">    setRunnerFromElementNoException(runner, document.getRootElement());</span>
<span class="fc" id="L4571">    runner.pojo.setOwnerRequest(Configuration.configuration.getHostId());</span>
<span class="fc bfc" id="L4572" title="All 2 branches covered.">    if (reverse) {</span>
<span class="pc bpc" id="L4573" title="1 of 2 branches missed.">      runner.setSender(!runner.isSender());</span>
<span class="pc bpc" id="L4574" title="1 of 2 branches missed.">      if (runner.isSender()) {</span>
<span class="fc" id="L4575">        runner.setFilename(runner.getOriginalFilename());</span>
      }
    }
<span class="fc" id="L4578">    return runner;</span>
  }

  /**
   * Special function for save or update for Log Import
   *
   * @throws WaarpDatabaseException
   */
  private void insertOrUpdateForLogsImport() throws WaarpDatabaseException {
<span class="nc bnc" id="L4587" title="All 2 branches missed.">    if (dbSession == null) {</span>
<span class="nc" id="L4588">      return;</span>
    }
<span class="nc bnc" id="L4590" title="All 2 branches missed.">    if (exist()) {</span>
<span class="nc" id="L4591">      final String nomap = pojo.getTransferInfo();</span>
<span class="nc" id="L4592">      pojo.setTransferInfo(getTransferInfo());</span>
<span class="nc" id="L4593">      super.update();</span>
<span class="nc" id="L4594">      pojo.setTransferInfo(nomap);</span>
<span class="nc" id="L4595">    } else {</span>
<span class="nc" id="L4596">      insert();</span>
    }
<span class="nc" id="L4598">  }</span>

  /**
   * Method to load several DbTaskRunner from File logs.
   *
   * @param logsFile File containing logs from export function
   *
   * @throws OpenR66ProtocolBusinessException
   */
  public static void loadXml(final File logsFile)
      throws OpenR66ProtocolBusinessException {
<span class="nc bnc" id="L4609" title="All 2 branches missed.">    if (!logsFile.canRead()) {</span>
<span class="nc" id="L4610">      throw new OpenR66ProtocolBusinessException(&quot;XML file cannot be read&quot;);</span>
    }
<span class="nc" id="L4612">    final SAXReader reader = XmlUtil.getNewSaxReader();</span>
    final Document document;
    try {
<span class="nc" id="L4615">      document = reader.read(logsFile);</span>
<span class="nc" id="L4616">    } catch (final DocumentException e) {</span>
<span class="nc" id="L4617">      throw new OpenR66ProtocolBusinessException(</span>
          &quot;XML file cannot be read as an XML file&quot;, e);
<span class="nc" id="L4619">    }</span>
<span class="nc" id="L4620">    final List&lt;Node&gt; elts =</span>
<span class="nc" id="L4621">        document.selectNodes('/' + XMLRUNNERS + '/' + XMLRUNNER);</span>
<span class="nc" id="L4622">    boolean error = false;</span>
<span class="nc" id="L4623">    Exception one = null;</span>
<span class="nc bnc" id="L4624" title="All 2 branches missed.">    for (final Node element : elts) {</span>
<span class="nc" id="L4625">      final DbTaskRunner runnerlog = new DbTaskRunner();</span>
      try {
<span class="nc" id="L4627">        setRunnerFromElementNoException(runnerlog, (Element) element);</span>
<span class="nc" id="L4628">        runnerlog.insertOrUpdateForLogsImport();</span>
<span class="nc" id="L4629">      } catch (final WaarpDatabaseSqlException e) {</span>
<span class="nc" id="L4630">        error = true;</span>
<span class="nc" id="L4631">        one = e;</span>
<span class="nc" id="L4632">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L4633">        error = true;</span>
<span class="nc" id="L4634">        one = e;</span>
<span class="nc" id="L4635">      }</span>
<span class="nc" id="L4636">    }</span>
<span class="nc bnc" id="L4637" title="All 2 branches missed.">    if (error) {</span>
<span class="nc" id="L4638">      throw new OpenR66ProtocolBusinessException(</span>
          &quot;Backend XML file is not conform to the model&quot;, one);
    }
<span class="nc" id="L4641">  }</span>

  /**
   * Utility for &quot;self request&quot; mode only
   *
   * @param sender
   */
  public final void setSender(final boolean sender) {
<span class="fc bfc" id="L4649" title="All 2 branches covered.">    if (pojo.getRetrieveMode() != sender) {</span>
<span class="fc" id="L4650">      pojo.setRetrieveMode(sender);</span>
<span class="fc" id="L4651">      isOtherThanStatus = true;</span>
<span class="fc" id="L4652">      isSaved = false;</span>
    }
<span class="fc" id="L4654">  }</span>

  /**
   * Helper
   *
   * @param request
   *
   * @return isSender according to request
   */
  public static boolean getSenderByRequestPacket(final RequestPacket request) {
<span class="fc bfc" id="L4664" title="All 2 branches covered.">    if (request.isToValidate()) {</span>
<span class="fc" id="L4665">      return RequestPacket.isRecvMode(request.getMode());</span>
    }
<span class="fc bfc" id="L4667" title="All 2 branches covered.">    return !RequestPacket.isRecvMode(request.getMode());</span>
  }

  /**
   * Utility for &quot;self request&quot;
   *
   * @param requestToValidate
   */
  public final void setSenderByRequestToValidate(
      final boolean requestToValidate) {
<span class="fc" id="L4677">    final boolean oldValue = pojo.getRetrieveMode();</span>
<span class="fc" id="L4678">    pojo.setRetrieveMode(RequestPacket.isRecvMode(pojo.getTransferMode()));</span>
<span class="pc bpc" id="L4679" title="1 of 2 branches missed.">    if (!requestToValidate) {</span>
<span class="fc bfc" id="L4680" title="All 2 branches covered.">      pojo.setRetrieveMode(!pojo.getRetrieveMode());</span>
    }
<span class="pc bpc" id="L4682" title="1 of 2 branches missed.">    if (oldValue != pojo.getRetrieveMode()) {</span>
<span class="fc" id="L4683">      isOtherThanStatus = true;</span>
<span class="fc" id="L4684">      isSaved = false;</span>
    }
<span class="fc" id="L4686">  }</span>

  /**
   * Utility to force &quot;update&quot;
   */
  private void setSenderForUpdate() {
<span class="fc bfc" id="L4692" title="All 2 branches covered.">    if (isSelfRequest()) {</span>
<span class="fc" id="L4693">      final boolean oldValue = pojo.getRetrieveMode();</span>
<span class="fc" id="L4694">      pojo.setRetrieveMode(RequestPacket.isRecvMode(pojo.getTransferMode()));</span>
<span class="pc bpc" id="L4695" title="1 of 2 branches missed.">      if (oldValue != pojo.getRetrieveMode()) {</span>
<span class="fc" id="L4696">        isSaved = false;</span>
<span class="fc" id="L4697">        isOtherThanStatus = true;</span>
      }
    }
<span class="fc" id="L4700">  }</span>

  /**
   * @return the originalSize
   */
  public final long getOriginalSize() {
<span class="fc" id="L4706">    return originalSize;</span>
  }

  /**
   * @param originalSize the originalSize to set
   */
  public final void setOriginalSize(final long originalSize) {
<span class="fc" id="L4713">    this.originalSize = originalSize;</span>
<span class="fc" id="L4714">    setOriginalSizeTransferMap(originalSize);</span>
<span class="fc" id="L4715">  }</span>

  /**
   * @return the full path for the current file
   *
   * @throws CommandAbstractException
   */
  public final String getFullFilePath() throws CommandAbstractException {
<span class="pc bpc" id="L4723" title="1 of 2 branches missed.">    if (isFileMoved()) {</span>
<span class="nc" id="L4724">      return getFilename();</span>
    } else {
<span class="fc" id="L4726">      final R66File file =</span>
<span class="fc" id="L4727">          new R66File(session, session.getDir(), getFilename(), false);</span>
<span class="fc" id="L4728">      return file.getTrueFile().getAbsolutePath();</span>
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>