<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ClientRunner.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Gateway Ftp</a> &gt; <a href="../index.html" class="el_bundle">WaarpR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.commander</a> &gt; <span class="el_source">ClientRunner.java</span></div><h1>ClientRunner.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.openr66.commander;

import org.waarp.common.command.exception.CommandAbstractException;
import org.waarp.common.database.data.AbstractDbData;
import org.waarp.common.database.data.AbstractDbData.UpdatedInfo;
import org.waarp.common.database.exception.WaarpDatabaseException;
import org.waarp.common.logging.SysErrLogger;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.openr66.client.RecvThroughHandler;
import org.waarp.openr66.context.ErrorCode;
import org.waarp.openr66.context.R66FiniteDualStates;
import org.waarp.openr66.context.R66Result;
import org.waarp.openr66.context.R66Session;
import org.waarp.openr66.context.task.exception.OpenR66RunnerErrorException;
import org.waarp.openr66.database.DbConstantR66;
import org.waarp.openr66.database.data.DbHostAuth;
import org.waarp.openr66.database.data.DbTaskRunner;
import org.waarp.openr66.database.data.DbTaskRunner.TASKSTEP;
import org.waarp.openr66.protocol.configuration.Configuration;
import org.waarp.openr66.protocol.configuration.Messages;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNoConnectionException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNoSslException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNotAuthenticatedException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNotYetConnectionException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolPacketException;
import org.waarp.openr66.protocol.localhandler.LocalChannelReference;
import org.waarp.openr66.protocol.localhandler.packet.RequestPacket;
import org.waarp.openr66.protocol.networkhandler.NetworkTransaction;
import org.waarp.openr66.protocol.utils.ChannelUtils;
import org.waarp.openr66.protocol.utils.R66Future;
import org.waarp.openr66.protocol.utils.TransferUtils;

import java.io.File;
import java.net.SocketAddress;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * Client Runner from a TaskRunner
 */
public class ClientRunner extends Thread {
  private static final String CANNOT_CONNECT_TO_SERVER =
      &quot;Cannot connect to server &quot;;

  private static final String REQUEST_INFORMATION_FAILURE =
      &quot;RequestInformation.Failure&quot;;

  private static final String REQUEST_INFORMATION_SUCCESS =
      &quot;RequestInformation.Success&quot;;

  private static final String TRANSFER_STATUS = &quot;Transfer.Status&quot;;

  /**
   * Internal Logger
   */
<span class="fc" id="L76">  private static final WaarpLogger logger =</span>
<span class="fc" id="L77">      WaarpLoggerFactory.getLogger(ClientRunner.class);</span>

  private static final ConcurrentHashMap&lt;String, Integer&gt;
<span class="fc" id="L80">      taskRunnerRetryHashMap = new ConcurrentHashMap&lt;String, Integer&gt;();</span>

  public static ConcurrentLinkedQueue&lt;ClientRunner&gt; activeRunners;

  private final NetworkTransaction networkTransaction;

  private final DbTaskRunner taskRunner;

  private final R66Future futureRequest;

  private RecvThroughHandler handler;

  private boolean isSendThroughMode;

  private LocalChannelReference localChannelReference;

  private final String nameTask;

<span class="fc" id="L98">  private boolean limitRetryConnection = true;</span>

  public ClientRunner(final NetworkTransaction networkTransaction,
                      final DbTaskRunner taskRunner,
<span class="fc" id="L102">                      final R66Future futureRequest) {</span>
<span class="fc" id="L103">    this.networkTransaction = networkTransaction;</span>
<span class="fc" id="L104">    this.taskRunner = taskRunner;</span>
<span class="fc" id="L105">    this.futureRequest = futureRequest;</span>
<span class="fc" id="L106">    setDaemon(true);</span>
<span class="fc" id="L107">    nameTask = &quot;Client_Runner_&quot; + taskRunner.getKey();</span>
<span class="fc" id="L108">    setName(nameTask);</span>
<span class="fc" id="L109">  }</span>

  public static String hashStatus() {
<span class="nc" id="L112">    return &quot;ClientRunner: [taskRunnerRetryHashMap: &quot; +</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">           taskRunnerRetryHashMap.size() + &quot; activeRunners: &quot; +</span>
<span class="nc" id="L114">           (activeRunners != null? activeRunners.size() :</span>
<span class="nc" id="L115">               Configuration.configuration.getInternalRunner()</span>
<span class="nc" id="L116">                                          .nbInternalRunner()) + &quot;] &quot;;</span>
  }

  /**
   * @return the networkTransaction
   */
  public NetworkTransaction getNetworkTransaction() {
<span class="nc" id="L123">    return networkTransaction;</span>
  }

  /**
   * @return the taskRunner
   */
  public DbTaskRunner getTaskRunner() {
<span class="nc" id="L130">    return taskRunner;</span>
  }

  /**
   * @return the localChannelReference
   */
  public LocalChannelReference getLocalChannelReference() {
<span class="fc" id="L137">    return localChannelReference;</span>
  }

  @Override
  public void run() {
<span class="pc bpc" id="L142" title="2 of 4 branches missed.">    if (Configuration.configuration.isShutdown() || Thread.interrupted()) {</span>
<span class="nc" id="L143">      taskRunner.changeUpdatedInfo(UpdatedInfo.TOSUBMIT);</span>
<span class="nc" id="L144">      taskRunner.forceSaveStatus();</span>
<span class="nc" id="L145">      return;</span>
    }
    try {
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">      if (activeRunners != null) {</span>
<span class="nc" id="L149">        activeRunners.add(this);</span>
      }
      // fix for SelfRequest
<span class="fc bfc" id="L152" title="All 2 branches covered.">      if (taskRunner.isSelfRequest()) {</span>
<span class="fc" id="L153">        taskRunner.setSenderByRequestToValidate(false);</span>
      }
      // Try to check if file still exists in send not self not through mode
<span class="fc bfc" id="L156" title="All 4 branches covered.">      if (taskRunner.isSender() &amp;&amp; !taskRunner.isSelfRequest() &amp;&amp;</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">          !taskRunner.isSendThrough()) {</span>
        try {
<span class="fc" id="L159">          final R66Session session = new R66Session();</span>
<span class="fc" id="L160">          session.setReady(true);</span>
<span class="fc" id="L161">          final boolean ssl = Configuration.configuration.isUseSSL();</span>
<span class="fc" id="L162">          session.getAuth().specialNoSessionAuth(ssl,</span>
                                                 Configuration.configuration
<span class="fc" id="L164">                                                     .getHostId(ssl));</span>
<span class="fc" id="L165">          final DbTaskRunner reloaded =</span>
<span class="fc" id="L166">              new DbTaskRunner(session, taskRunner.getRule(),</span>
<span class="fc" id="L167">                               taskRunner.getSpecialId(),</span>
<span class="fc" id="L168">                               taskRunner.getRequester(),</span>
<span class="fc" id="L169">                               taskRunner.getRequested());</span>
<span class="fc" id="L170">          reloaded.setSender(taskRunner.isSender());</span>
<span class="fc" id="L171">          session.setRunner(reloaded);</span>
<span class="fc" id="L172">          final File file = new File(reloaded.getFullFilePath());</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">          if (!file.isFile()) {</span>
<span class="fc" id="L174">            logger.warn(&quot;File not found: {}&quot;, file.getAbsolutePath());</span>
            // File does no more exist =&gt; error
<span class="fc" id="L176">            reloaded.changeUpdatedInfo(UpdatedInfo.INERROR);</span>
<span class="fc" id="L177">            reloaded.setErrorExecutionStatus(ErrorCode.FileNotFound);</span>
<span class="fc" id="L178">            logger</span>
<span class="fc" id="L179">                .error(&quot;Runner Error: {} {}&quot;, ErrorCode.FileNotFound.getMesg(),</span>
<span class="fc" id="L180">                       taskRunner.toShortString());</span>
<span class="fc" id="L181">            reloaded.setErrorTask();</span>
<span class="fc" id="L182">            reloaded.update();</span>
<span class="fc" id="L183">            return;</span>
          }
<span class="nc" id="L185">        } catch (final CommandAbstractException e) {</span>
          // Wrong path? Ignore
<span class="nc" id="L187">          logger.warn(e);</span>
<span class="nc" id="L188">        } catch (final OpenR66RunnerErrorException e) {</span>
          // Wrong run error? Ignore
<span class="nc" id="L190">          logger.warn(e);</span>
<span class="nc" id="L191">        } catch (final WaarpDatabaseException e) {</span>
          // Wrong dbtask? Ignore
<span class="nc" id="L193">          logger.warn(e);</span>
<span class="nc" id="L194">        } catch (final OpenR66ProtocolNoSslException e) {</span>
          // Wrong ssl? Ignore
<span class="nc" id="L196">          logger.warn(e);</span>
<span class="pc" id="L197">        }</span>
      }
      final R66Future transfer;
      try {
<span class="fc" id="L201">        transfer = runTransfer();</span>
<span class="nc" id="L202">      } catch (final OpenR66RunnerErrorException e) {</span>
<span class="nc" id="L203">        logger.error(&quot;Runner Error: {} {}&quot;, e.getMessage(),</span>
<span class="nc" id="L204">                     taskRunner.toShortString());</span>
<span class="nc" id="L205">        return;</span>
<span class="fc" id="L206">      } catch (final OpenR66ProtocolNoConnectionException e) {</span>
<span class="fc" id="L207">        logger.error(&quot;No connection Error {}&quot;, e.getMessage());</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        if (localChannelReference != null) {</span>
<span class="nc" id="L209">          localChannelReference</span>
<span class="nc" id="L210">              .setErrorMessage(ErrorCode.ConnectionImpossible.getMesg(),</span>
                               ErrorCode.ConnectionImpossible);
        }
<span class="fc" id="L213">        taskRunner.setErrorTask();</span>
        try {
<span class="fc" id="L215">          taskRunner.forceSaveStatus();</span>
<span class="fc" id="L216">          taskRunner.run();</span>
<span class="nc" id="L217">        } catch (final OpenR66RunnerErrorException e1) {</span>
<span class="nc" id="L218">          changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ConnectionImpossible,</span>
                            true);
<span class="fc" id="L220">        }</span>
<span class="fc" id="L221">        return;</span>
<span class="nc" id="L222">      } catch (final OpenR66ProtocolPacketException e) {</span>
<span class="nc" id="L223">        logger.error(&quot;Protocol Error&quot;, e);</span>
<span class="nc" id="L224">        return;</span>
<span class="fc" id="L225">      } catch (final OpenR66ProtocolNotYetConnectionException e) {</span>
<span class="fc" id="L226">        logger.warn(&quot;No connection warning {}&quot;, e.getMessage());</span>
<span class="fc" id="L227">        return;</span>
<span class="fc" id="L228">      }</span>
<span class="fc" id="L229">      final R66Result result = transfer.getResult();</span>
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">      if (result != null) {</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        if (result.getCode() == ErrorCode.QueryAlreadyFinished) {</span>
<span class="nc" id="L232">          logger.warn(Messages.getString(TRANSFER_STATUS) +</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">                      (transfer.isSuccess()?</span>
<span class="nc" id="L234">                          Messages.getString(REQUEST_INFORMATION_SUCCESS) :</span>
<span class="nc" id="L235">                          Messages.getString(REQUEST_INFORMATION_FAILURE)) +</span>
<span class="nc" id="L236">                      &quot;     &quot; + ErrorCode.QueryAlreadyFinished.getMesg() + ':' +</span>
<span class="nc" id="L237">                      result.toString());</span>
        } else {
<span class="fc bfc" id="L239" title="All 2 branches covered.">          if (transfer.isSuccess()) {</span>
<span class="fc" id="L240">            logger.info(&quot;{}{}     {}&quot;, Messages.getString(TRANSFER_STATUS),</span>
<span class="fc" id="L241">                        Messages.getString(REQUEST_INFORMATION_SUCCESS),</span>
                        result);
          } else {
<span class="fc" id="L244">            logger.error(Messages.getString(TRANSFER_STATUS) +</span>
<span class="fc" id="L245">                         Messages.getString(REQUEST_INFORMATION_FAILURE) +</span>
<span class="fc" id="L246">                         &quot;     &quot; + result.toString());</span>
          }
        }
      } else {
<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (transfer.isSuccess()) {</span>
<span class="nc" id="L251">          logger.warn(Messages.getString(TRANSFER_STATUS) +</span>
<span class="nc" id="L252">                      Messages.getString(REQUEST_INFORMATION_SUCCESS) +</span>
                      &quot;     no result&quot;);
        } else {
<span class="nc" id="L255">          logger.error(Messages.getString(TRANSFER_STATUS) +</span>
<span class="nc" id="L256">                       Messages.getString(REQUEST_INFORMATION_FAILURE) +</span>
                       &quot;     no result&quot;);
        }
      }
    } finally {
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">      if (activeRunners != null) {</span>
<span class="nc" id="L262">        activeRunners.remove(this);</span>
      }
<span class="fc" id="L264">      setName(&quot;Finished_&quot; + nameTask);</span>
    }
<span class="fc" id="L266">  }</span>

  /**
   * @param runner
   * @param limit
   *
   * @return True if the task was run less than limit, else False
   */
  public boolean incrementTaskRunnerTry(final DbTaskRunner runner,
                                        final int limit) {
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">    if (!isLimitRetryConnection()) {</span>
<span class="nc" id="L277">      return true;</span>
    }
<span class="fc" id="L279">    final String key = runner.getKey();</span>
<span class="fc" id="L280">    Integer tries = taskRunnerRetryHashMap.get(key);</span>
<span class="fc" id="L281">    logger.debug(&quot;try to find integer: {}&quot;, tries);</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">    if (tries == null) {</span>
<span class="fc" id="L283">      tries = 1;</span>
    } else {
<span class="fc" id="L285">      tries += 1;</span>
    }
<span class="fc bfc" id="L287" title="All 2 branches covered.">    logger.debug(&quot;Check: {} vs {}: {}&quot;, tries, limit, limit &lt;= tries);</span>
<span class="pc bpc" id="L288" title="1 of 4 branches missed.">    if (limit &lt;= tries || Thread.interrupted()) {</span>
<span class="fc" id="L289">      taskRunnerRetryHashMap.remove(key);</span>
<span class="fc" id="L290">      return false;</span>
    } else {
<span class="fc" id="L292">      taskRunnerRetryHashMap.put(key, tries);</span>
<span class="fc" id="L293">      return true;</span>
    }
  }

  /**
   * True transfer run (can be called directly to enable exception outside any
   * executors)
   *
   * @return The R66Future of the transfer operation
   *
   * @throws OpenR66RunnerErrorException
   * @throws OpenR66ProtocolNoConnectionException
   * @throws OpenR66ProtocolPacketException
   * @throws OpenR66ProtocolNotYetConnectionException
   */
  public R66Future runTransfer()
      throws OpenR66RunnerErrorException, OpenR66ProtocolNoConnectionException,
             OpenR66ProtocolPacketException,
             OpenR66ProtocolNotYetConnectionException {
<span class="fc" id="L312">    logger.debug(&quot;Start attempt Transfer&quot;);</span>
<span class="fc" id="L313">    localChannelReference = initRequest();</span>
<span class="fc" id="L314">    localChannelReference.getFutureValidRequest().awaitOrInterruptible(</span>
<span class="fc" id="L315">        Configuration.configuration.getTimeoutCon());</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">    if (localChannelReference.getFutureValidRequest().isSuccess()) {</span>
<span class="fc" id="L317">      return finishTransfer(localChannelReference);</span>
<span class="fc" id="L318">    } else if (</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">        localChannelReference.getFutureValidRequest().getResult() != null &amp;&amp;</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">        localChannelReference.getFutureValidRequest().getResult().getCode() ==</span>
        ErrorCode.ServerOverloaded) {
<span class="nc" id="L322">      return tryAgainTransferOnOverloaded(true, localChannelReference);</span>
    } else {
<span class="fc" id="L324">      return finishTransfer(localChannelReference);</span>
    }
  }

  /**
   * In case an overloaded signal is returned by the requested
   *
   * @param retry if True, it will retry in case of overloaded remote
   *     server, else it just stops
   * @param localChannelReference
   *
   * @return The R66Future of the transfer operation
   *
   * @throws OpenR66RunnerErrorException
   * @throws OpenR66ProtocolNoConnectionException
   * @throws OpenR66ProtocolPacketException
   * @throws OpenR66ProtocolNotYetConnectionException
   */
  public R66Future tryAgainTransferOnOverloaded(final boolean retry,
                                                final LocalChannelReference localChannelReference)
      throws OpenR66RunnerErrorException, OpenR66ProtocolNoConnectionException,
             OpenR66ProtocolPacketException,
             OpenR66ProtocolNotYetConnectionException {
<span class="nc bnc" id="L347" title="All 2 branches missed.">    if (this.localChannelReference == null) {</span>
<span class="nc" id="L348">      this.localChannelReference = localChannelReference;</span>
    }
<span class="nc" id="L350">    final boolean incRetry =</span>
<span class="nc" id="L351">        incrementTaskRunnerTry(taskRunner, Configuration.RETRYNB);</span>
<span class="nc" id="L352">    logger.debug(&quot;tryAgainTransferOnOverloaded: {}:{}&quot;, retry, incRetry);</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">    switch (taskRunner.getUpdatedInfo()) {</span>
      case DONE:
      case INERROR:
      case INTERRUPTED:
<span class="nc" id="L357">        break;</span>
      default:
<span class="nc" id="L359">        changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ServerOverloaded,</span>
                          true);
    }
    // redo if possible
<span class="nc bnc" id="L363" title="All 4 branches missed.">    if (retry &amp;&amp; incRetry) {</span>
      try {
<span class="nc" id="L365">        Thread.sleep(Configuration.configuration.getConstraintLimitHandler()</span>
<span class="nc" id="L366">                                                .getSleepTime());</span>
<span class="nc" id="L367">      } catch (final InterruptedException e) {//NOSONAR</span>
<span class="nc" id="L368">        SysErrLogger.FAKE_LOGGER.ignoreLog(e);</span>
<span class="nc" id="L369">      }</span>
<span class="nc" id="L370">      return runTransfer();</span>
    } else {
<span class="nc bnc" id="L372" title="All 2 branches missed.">      if (localChannelReference == null) {</span>
<span class="nc" id="L373">        taskRunner.setLocalChannelReference(new LocalChannelReference());</span>
      }
<span class="nc" id="L375">      taskRunner.getLocalChannelReference()</span>
<span class="nc" id="L376">                .setErrorMessage(ErrorCode.ConnectionImpossible.getMesg(),</span>
                                 ErrorCode.ConnectionImpossible);
<span class="nc" id="L378">      taskRunner.setErrorTask();</span>
<span class="nc" id="L379">      taskRunner.run();</span>
<span class="nc" id="L380">      throw new OpenR66ProtocolNoConnectionException(</span>
          &quot;End of retry on ServerOverloaded&quot;);
    }
  }

  /**
   * Finish the transfer (called at the end of runTransfer)
   *
   * @param localChannelReference
   *
   * @return The R66Future of the transfer operation
   */
  public R66Future finishTransfer(
      final LocalChannelReference localChannelReference) {
<span class="fc bfc" id="L394" title="All 2 branches covered.">    if (this.localChannelReference == null) {</span>
<span class="fc" id="L395">      this.localChannelReference = localChannelReference;</span>
    }
<span class="fc" id="L397">    final R66Future transfer = localChannelReference.getFutureRequest();</span>
<span class="fc" id="L398">    transfer.awaitOrInterruptible();</span>
<span class="fc" id="L399">    taskRunnerRetryHashMap.remove(taskRunner.getKey());</span>
<span class="fc" id="L400">    logger.info(&quot;Request done with {}&quot;,</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">                transfer.isSuccess()? &quot;success&quot; : &quot;error&quot;);</span>
<span class="fc" id="L402">    localChannelReference.close();</span>
    // now reload TaskRunner if it still exists (light client can forget it)
<span class="fc" id="L404">    final boolean isSender = taskRunner.isSender();</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">    if (transfer.isSuccess()) {</span>
      try {
<span class="fc" id="L407">        taskRunner.select();</span>
<span class="nc" id="L408">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L409">        logger.debug(&quot;Not a problem but cannot find at the end the task&quot;, e);</span>
<span class="nc" id="L410">        taskRunner.setFrom(transfer.getRunner());</span>
<span class="fc" id="L411">      }</span>
<span class="fc" id="L412">      taskRunner.setSender(isSender);</span>
<span class="fc" id="L413">      changeUpdatedInfo(UpdatedInfo.DONE, ErrorCode.CompleteOk, false);</span>
    } else {
      try {
<span class="fc" id="L416">        taskRunner.select();</span>
<span class="nc" id="L417">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L418">        logger.debug(&quot;Not a problem but cannot find at the end the task&quot;);</span>
<span class="nc" id="L419">        taskRunner.setFrom(transfer.getRunner());</span>
<span class="fc" id="L420">      }</span>
<span class="fc" id="L421">      taskRunner.setSender(isSender);</span>
      // Case when we were interrupted
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">      if (transfer.getResult() == null) {</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">        switch (taskRunner.getUpdatedInfo()) {</span>
          case DONE:
<span class="nc" id="L426">            final R66Result ok =</span>
                new R66Result(null, true, ErrorCode.CompleteOk, taskRunner);
<span class="nc" id="L428">            transfer.setResult(ok);</span>
<span class="nc" id="L429">            transfer.setSuccess();</span>
<span class="nc" id="L430">            changeUpdatedInfo(UpdatedInfo.DONE, ErrorCode.CompleteOk, false);</span>
<span class="nc" id="L431">            break;</span>
          case INERROR:
          case INTERRUPTED:
          default:
<span class="nc" id="L435">            final R66Result error =</span>
                new R66Result(null, true, ErrorCode.Internal, taskRunner);
<span class="nc" id="L437">            transfer.setResult(error);</span>
<span class="nc" id="L438">            transfer.cancel();</span>
<span class="nc" id="L439">            changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.Internal, false);</span>
        }
<span class="nc" id="L441">        return transfer;</span>
      }
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">      if (transfer.getResult().getCode() == ErrorCode.QueryAlreadyFinished) {</span>
        // check if post task to execute
<span class="nc" id="L445">        logger.warn(&quot;WARN QueryAlreadyFinished:     &quot; + transfer + &quot;     &quot; +</span>
<span class="nc" id="L446">                    taskRunner.toShortString());</span>
        try {
<span class="nc" id="L448">          TransferUtils</span>
<span class="nc" id="L449">              .finalizeTaskWithNoSession(taskRunner, localChannelReference);</span>
<span class="nc" id="L450">        } catch (final OpenR66RunnerErrorException e) {</span>
<span class="nc" id="L451">          taskRunner.changeUpdatedInfo(UpdatedInfo.INERROR);</span>
<span class="nc" id="L452">          taskRunner.forceSaveStatus();</span>
<span class="nc" id="L453">        }</span>
      } else {
<span class="fc bfc" id="L455" title="All 2 branches covered.">        switch (taskRunner.getUpdatedInfo()) {</span>
          case DONE:
          case INERROR:
          case INTERRUPTED:
          case TOSUBMIT:
<span class="fc" id="L460">            break;</span>
          default:
<span class="fc" id="L462">            changeUpdatedInfo(UpdatedInfo.INERROR,</span>
<span class="fc" id="L463">                              transfer.getResult().getCode(), false);</span>
        }
      }
    }
<span class="fc" id="L467">    return transfer;</span>
  }

  /**
   * Initialize the request
   *
   * @return the localChannelReference holding the transfer request
   *
   * @throws OpenR66ProtocolNoConnectionException
   * @throws OpenR66ProtocolPacketException
   * @throws OpenR66ProtocolNotYetConnectionException
   */
  public LocalChannelReference initRequest()
      throws OpenR66ProtocolNoConnectionException,
             OpenR66ProtocolPacketException,
             OpenR66ProtocolNotYetConnectionException {
<span class="fc" id="L483">    changeUpdatedInfo(UpdatedInfo.RUNNING, ErrorCode.Running, true);</span>
<span class="fc" id="L484">    final long id = taskRunner.getSpecialId();</span>
    final String tid;
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">    if (id == DbConstantR66.ILLEGALVALUE) {</span>
<span class="nc" id="L487">      tid = &quot;Runner_&quot; + taskRunner.getRuleId() + '_' + taskRunner.getMode() +</span>
            &quot;_NEWTRANSFER&quot;;
    } else {
<span class="fc" id="L490">      tid = &quot;Runner_&quot; + taskRunner.getRuleId() + '_' + taskRunner.getMode() +</span>
            '_' + id;
    }
<span class="fc" id="L493">    setName(tid);</span>
<span class="fc" id="L494">    logger.debug(&quot;Will run {}&quot;, taskRunner);</span>
<span class="fc" id="L495">    boolean restartPost = false;</span>
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">    if (taskRunner.getGloballaststep() == TASKSTEP.POSTTASK.ordinal()) {</span>
      // Send a validation to requested
<span class="nc bnc" id="L498" title="All 2 branches missed.">      if (!taskRunner.isSelfRequested()) {</span>
        // restart
<span class="nc" id="L500">        restartPost = true;</span>
      }
    }
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">    if (taskRunner.isSelfRequested()) {</span>
      // Don't have to restart a task for itself (or should use requester)
<span class="nc" id="L505">      logger.warn(&quot;Requested host cannot initiate itself the request&quot;);</span>
<span class="nc" id="L506">      changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.LoopSelfRequestedHost,</span>
                        true);
<span class="nc" id="L508">      throw new OpenR66ProtocolNoConnectionException(</span>
          &quot;Requested host cannot initiate itself the request&quot;);
    }
    final DbHostAuth host;
    try {
<span class="fc" id="L513">      host = new DbHostAuth(taskRunner.getRequested());</span>
<span class="nc" id="L514">    } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L515">      logger.error(</span>
<span class="nc" id="L516">          &quot;Requested host cannot be found: &quot; + taskRunner.getRequested());</span>
<span class="nc" id="L517">      changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.NotKnownHost, true);</span>
<span class="nc" id="L518">      throw new OpenR66ProtocolNoConnectionException(</span>
<span class="nc" id="L519">          &quot;Requested host cannot be found &quot; + taskRunner.getRequested());</span>
<span class="fc" id="L520">    }</span>
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">    if (host.isClient()) {</span>
<span class="nc" id="L522">      logger.warn(&quot;Cannot initiate a connection with a client: {}&quot;, host);</span>
<span class="nc" id="L523">      changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ConnectionImpossible,</span>
                        true);
<span class="nc" id="L525">      throw new OpenR66ProtocolNoConnectionException(</span>
          &quot;Cannot connect to client &quot; + host);
    }
<span class="fc" id="L528">    final SocketAddress socketAddress = host.getSocketAddress();</span>
<span class="fc" id="L529">    final boolean isSSL = host.isSsl();</span>

    final LocalChannelReference localChannelReferenceTemp;
    try {
<span class="fc" id="L533">      localChannelReferenceTemp = networkTransaction</span>
<span class="fc" id="L534">          .createConnectionWithRetryWithAuthenticationException(socketAddress,</span>
                                                                isSSL,
                                                                futureRequest);
<span class="fc" id="L537">    } catch (final OpenR66ProtocolNotAuthenticatedException e1) {</span>
<span class="fc" id="L538">      changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.BadAuthent, true);</span>
<span class="fc" id="L539">      taskRunner.setLocalChannelReference(new LocalChannelReference());</span>
<span class="fc" id="L540">      throw new OpenR66ProtocolNoConnectionException(</span>
          CANNOT_CONNECT_TO_SERVER + host +
          &quot; cannot be authenticated so stop retry here&quot;, e1);
<span class="fc" id="L543">    }</span>
<span class="fc" id="L544">    taskRunner.setLocalChannelReference(localChannelReferenceTemp);</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">    if (localChannelReferenceTemp == null) {</span>
      // propose to redo
      String retry;
<span class="fc bfc" id="L548" title="All 2 branches covered.">      if (incrementTaskRunnerTry(taskRunner, Configuration.RETRYNB)) {</span>

<span class="fc" id="L550">        logger.debug(&quot;Will retry since Cannot connect to {}&quot;, host);</span>
<span class="fc" id="L551">        retry = &quot; but will retry&quot;;</span>
        // now wait
        try {
<span class="fc" id="L554">          Thread.sleep(Configuration.configuration.getDelayRetry());</span>
<span class="nc" id="L555">        } catch (final InterruptedException e) {//NOSONAR</span>
<span class="nc" id="L556">          SysErrLogger.FAKE_LOGGER.ignoreLog(e);</span>
<span class="nc" id="L557">          logger.info(</span>
              &quot;Will not retry since an interruption occurs while connection to {}&quot;,
              host);
<span class="nc" id="L560">          retry = &quot; and retries gets an interruption so stop here&quot;;</span>
<span class="nc" id="L561">          changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ConnectionImpossible,</span>
                            true);
<span class="nc" id="L563">          taskRunner.setLocalChannelReference(new LocalChannelReference());</span>
<span class="nc" id="L564">          throw new OpenR66ProtocolNoConnectionException(</span>
              CANNOT_CONNECT_TO_SERVER + host + retry);
<span class="fc" id="L566">        }</span>
<span class="fc" id="L567">        changeUpdatedInfo(UpdatedInfo.TOSUBMIT, ErrorCode.ConnectionImpossible,</span>
                          true);
<span class="fc" id="L569">        throw new OpenR66ProtocolNotYetConnectionException(</span>
            CANNOT_CONNECT_TO_SERVER + host + retry);
      } else {
<span class="fc" id="L572">        logger.info(</span>
            &quot;Will not retry since limit of connection attemtps is reached for {}&quot;,
            host);
<span class="fc" id="L575">        retry = &quot; and retries reach step limit so stop here&quot;;</span>
<span class="fc" id="L576">        changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ConnectionImpossible,</span>
                          true);
<span class="fc" id="L578">        taskRunner.setLocalChannelReference(new LocalChannelReference());</span>
<span class="fc" id="L579">        throw new OpenR66ProtocolNoConnectionException(</span>
            CANNOT_CONNECT_TO_SERVER + host + retry);
      }
    }
<span class="fc bfc" id="L583" title="All 2 branches covered.">    if (handler != null) {</span>
<span class="fc" id="L584">      localChannelReferenceTemp.setRecvThroughHandler(handler);</span>
    }
<span class="fc" id="L586">    localChannelReferenceTemp.setSendThroughMode(isSendThroughMode);</span>
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">    if (restartPost) {</span>
<span class="nc" id="L588">      final RequestPacket request = taskRunner.getRequest();</span>
<span class="nc" id="L589">      logger.debug(&quot;Will send request {} &quot;, request);</span>
<span class="nc" id="L590">      localChannelReferenceTemp.setClientRunner(this);</span>
<span class="nc" id="L591">      localChannelReferenceTemp.sessionNewState(R66FiniteDualStates.REQUESTR);</span>
      try {
<span class="nc" id="L593">        ChannelUtils</span>
<span class="nc" id="L594">            .writeAbstractLocalPacket(localChannelReferenceTemp, request, true);</span>
<span class="nc" id="L595">      } catch (final OpenR66ProtocolPacketException e) {</span>
        // propose to redo
<span class="nc" id="L597">        logger.warn(&quot;Cannot transfer request to &quot; + host);</span>
<span class="nc" id="L598">        changeUpdatedInfo(UpdatedInfo.INTERRUPTED, ErrorCode.Internal, true);</span>
<span class="nc" id="L599">        localChannelReferenceTemp.close();</span>
<span class="nc" id="L600">        throw e;</span>
<span class="nc" id="L601">      }</span>
<span class="nc" id="L602">      logger.debug(&quot;Wait for request to {}&quot;, host);</span>
<span class="nc" id="L603">      return localChannelReferenceTemp;</span>
    }
    // If Requester is NOT Sender, and if TransferTask then decrease now if
    // possible the rank
<span class="fc bfc" id="L607" title="All 2 branches covered.">    if (!taskRunner.isSender() &amp;&amp;</span>
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">        taskRunner.getGloballaststep() == TASKSTEP.TRANSFERTASK.ordinal()) {</span>
<span class="nc" id="L609">      logger</span>
<span class="nc" id="L610">          .debug(&quot;Requester is not Sender so decrease if possible the rank {}&quot;,</span>
                 taskRunner);
<span class="nc" id="L612">      taskRunner.restartRank();</span>
<span class="nc" id="L613">      taskRunner.forceSaveStatus();</span>
<span class="nc" id="L614">      logger.info(&quot;Requester is not Sender so new rank is {} {}&quot;,</span>
<span class="nc" id="L615">                  taskRunner.getRank(), taskRunner);</span>
    }
<span class="fc" id="L617">    final RequestPacket request = taskRunner.getRequest();</span>
<span class="fc" id="L618">    request.setLimit(</span>
<span class="fc" id="L619">        localChannelReferenceTemp.getChannelLimit(taskRunner.isSender()));</span>
<span class="fc" id="L620">    localChannelReferenceTemp.setClientRunner(this);</span>
<span class="fc" id="L621">    logger.debug(&quot;Will send request {} {}&quot;, request, localChannelReferenceTemp);</span>
<span class="fc" id="L622">    localChannelReferenceTemp.sessionNewState(R66FiniteDualStates.REQUESTR);</span>
    try {
<span class="fc" id="L624">      ChannelUtils</span>
<span class="fc" id="L625">          .writeAbstractLocalPacket(localChannelReferenceTemp, request, true);</span>
<span class="nc" id="L626">    } catch (final OpenR66ProtocolPacketException e) {</span>
      // propose to redo
<span class="nc" id="L628">      logger.warn(&quot;Cannot transfer request to &quot; + host);</span>
<span class="nc" id="L629">      changeUpdatedInfo(UpdatedInfo.INTERRUPTED, ErrorCode.Internal, true);</span>
<span class="nc" id="L630">      localChannelReferenceTemp.close();</span>
<span class="nc" id="L631">      throw e;</span>
<span class="fc" id="L632">    }</span>
<span class="fc" id="L633">    logger</span>
<span class="fc" id="L634">        .debug(&quot;Wait for request to {} {} {}&quot;, host, localChannelReferenceTemp,</span>
               request);
<span class="fc" id="L636">    return localChannelReferenceTemp;</span>
  }

  /**
   * Change the UpdatedInfo of the current runner
   *
   * @param info
   */
  public void changeUpdatedInfo(final AbstractDbData.UpdatedInfo info,
                                final ErrorCode code, final boolean force) {
<span class="fc" id="L646">    taskRunner.changeUpdatedInfo(info);</span>
<span class="fc" id="L647">    taskRunner.setErrorExecutionStatus(code);</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">    if (force) {</span>
<span class="fc" id="L649">      taskRunner.forceSaveStatus();</span>
    } else {
      try {
<span class="fc" id="L652">        taskRunner.saveStatus();</span>
<span class="nc" id="L653">      } catch (final OpenR66RunnerErrorException ignored) {</span>
        // nothing
<span class="fc" id="L655">      }</span>
    }
<span class="fc" id="L657">  }</span>

  /**
   * @param handler the handler to set
   */
  public void setRecvThroughHandler(final RecvThroughHandler handler) {
<span class="fc" id="L663">    this.handler = handler;</span>
<span class="fc" id="L664">  }</span>

  public void setSendThroughMode() {
<span class="fc" id="L667">    isSendThroughMode = true;</span>
<span class="fc" id="L668">  }</span>

  public boolean getSendThroughMode() {
<span class="nc" id="L671">    return isSendThroughMode;</span>
  }

  public boolean isLimitRetryConnection() {
<span class="fc" id="L675">    return limitRetryConnection;</span>
  }

  public void setLimitRetryConnection(final boolean limitRetryConnection) {
<span class="fc" id="L679">    this.limitRetryConnection = limitRetryConnection;</span>
<span class="fc" id="L680">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>