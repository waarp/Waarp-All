<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>LocalExecServerHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Gateway Ftp</a> &gt; <a href="../index.html" class="el_bundle">WaarpExec</a> &gt; <a href="index.source.html" class="el_package">org.waarp.commandexec.server</a> &gt; <span class="el_source">LocalExecServerHandler.java</span></div><h1>LocalExecServerHandler.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.commandexec.server;

import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import org.apache.commons.exec.CommandLine;
import org.apache.commons.exec.DefaultExecutor;
import org.apache.commons.exec.ExecuteException;
import org.apache.commons.exec.ExecuteWatchdog;
import org.apache.commons.exec.PumpStreamHandler;
import org.waarp.commandexec.utils.LocalExecDefaultResult;
import org.waarp.common.crypto.ssl.WaarpSslUtility;
import org.waarp.common.file.FileUtils;
import org.waarp.common.logging.SysErrLogger;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.WaarpNettyUtil;
import org.waarp.common.utility.WaarpStringUtils;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.nio.channels.CancelledKeyException;
import java.nio.channels.ClosedChannelException;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.RejectedExecutionException;

/**
 * Handles a server-side channel for LocalExec.
 */
public class LocalExecServerHandler
    extends SimpleChannelInboundHandler&lt;String&gt; {
  private static final String EXCEPTION_WHILE_ANSWERED =
      &quot;Exception while answered: &quot;;
  private static final String EXEC_IN_ERROR_WITH = &quot; Exec in error with &quot;;
  private static final String EXCEPTION = &quot;Exception: &quot;;
  // Fixed delay, but could change if necessary at construction
<span class="fc" id="L61">  private long delay = LocalExecDefaultResult.MAXWAITPROCESS;</span>
  protected final LocalExecServerInitializer factory;
  protected static boolean isShutdown;

  /**
   * Internal Logger
   */
<span class="fc" id="L68">  private static final WaarpLogger logger =</span>
<span class="fc" id="L69">      WaarpLoggerFactory.getLogger(LocalExecServerHandler.class);</span>

  protected volatile boolean answered;

  /**
   * Is the Local Exec Server going Shutdown
   *
   * @param channel associated channel
   *
   * @return True if in Shutdown
   */
  public static boolean isShutdown(Channel channel) {
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">    if (isShutdown) {</span>
<span class="nc" id="L82">      channel.writeAndFlush(</span>
<span class="nc" id="L83">          LocalExecDefaultResult.ConnectionRefused.getStatus() + &quot; &quot; +</span>
<span class="nc" id="L84">          LocalExecDefaultResult.ConnectionRefused.getResult() + '\n');</span>
<span class="nc" id="L85">      WaarpNettyUtil.awaitOrInterrupted(</span>
<span class="nc" id="L86">          channel.writeAndFlush(LocalExecDefaultResult.ENDOFCOMMAND + '\n'),</span>
          30000);
<span class="nc" id="L88">      WaarpSslUtility.closingSslChannel(channel);</span>
<span class="nc" id="L89">      return true;</span>
    }
<span class="fc" id="L91">    return false;</span>
  }

  public static void junitSetNotShutdown() {
<span class="fc" id="L95">    isShutdown = false;</span>
<span class="fc" id="L96">  }</span>

  /**
   * Print stack trace
   *
   * @param thread
   * @param stacks
   */
  private static void printStackTrace(Thread thread,
                                      StackTraceElement[] stacks) {
<span class="nc" id="L106">    SysErrLogger.FAKE_LOGGER.syserrNoLn(thread + &quot; : &quot;);</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">    for (int i = 0; i &lt; stacks.length - 1; i++) {</span>
<span class="nc" id="L108">      SysErrLogger.FAKE_LOGGER.syserrNoLn(stacks[i] + &quot; &quot;);</span>
    }
<span class="nc bnc" id="L110" title="All 2 branches missed.">    if (stacks.length &gt; 0) {</span>
<span class="nc" id="L111">      SysErrLogger.FAKE_LOGGER.syserr(stacks[stacks.length - 1]);</span>
    } else {
<span class="nc" id="L113">      SysErrLogger.FAKE_LOGGER.syserr();</span>
    }
<span class="nc" id="L115">  }</span>

  /**
   * Shutdown thread
   */
  private static class GGLEThreadShutdown extends Thread {
    static final long DELAY = 3000;
    final LocalExecServerInitializer factory;

<span class="fc" id="L124">    private GGLEThreadShutdown(LocalExecServerInitializer factory) {</span>
<span class="fc" id="L125">      this.factory = factory;</span>
<span class="fc" id="L126">    }</span>

    @Override
    public void run() {
      Timer timer;
<span class="fc" id="L131">      timer = new Timer(true);</span>
<span class="fc" id="L132">      final GGLETimerTask ggleTimerTask = new GGLETimerTask();</span>
<span class="fc" id="L133">      timer.schedule(ggleTimerTask, DELAY);</span>
<span class="fc" id="L134">      factory.releaseResources();</span>
      //FBGEXIT DetectionUtils.SystemExit(0)
<span class="fc" id="L136">    }</span>

  }

  /**
   * TimerTask to terminate the server
   */
  private static class GGLETimerTask extends TimerTask {
    /**
     * Internal Logger
     */
<span class="fc" id="L147">    private static final WaarpLogger logger =</span>
<span class="fc" id="L148">        WaarpLoggerFactory.getLogger(GGLETimerTask.class);</span>

    @Override
    public void run() {
<span class="nc" id="L152">      logger.error(&quot;System will force EXIT&quot;);</span>
<span class="nc" id="L153">      final Map&lt;Thread, StackTraceElement[]&gt; map = Thread.getAllStackTraces();</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">      for (final Entry&lt;Thread, StackTraceElement[]&gt; entry : map.entrySet()) {</span>
        try {
<span class="nc" id="L156">          printStackTrace(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L157">        } catch (ArrayIndexOutOfBoundsException e) {</span>
          // ignore
<span class="nc" id="L159">        }</span>
<span class="nc" id="L160">      }</span>
      //FBGEXIT DetectionUtils.SystemExit(0)
<span class="nc" id="L162">    }</span>
  }

  /**
   * Constructor with a specific delay
   *
   * @param newdelay
   */
  public LocalExecServerHandler(LocalExecServerInitializer factory,
<span class="fc" id="L171">                                long newdelay) {</span>
<span class="fc" id="L172">    this.factory = factory;</span>
<span class="fc" id="L173">    delay = newdelay;</span>
<span class="fc" id="L174">  }</span>

  @Override
  public void channelActive(ChannelHandlerContext ctx) throws Exception {
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">    if (isShutdown(ctx.channel())) {</span>
<span class="nc" id="L179">      answered = true;</span>
<span class="nc" id="L180">      return;</span>
    }
<span class="fc" id="L182">    answered = false;</span>
<span class="fc" id="L183">    factory.addChannel(ctx.channel());</span>
<span class="fc" id="L184">  }</span>

  /**
   * Change the delay to the specific value. Need to be called before any
   * receive message.
   *
   * @param newdelay
   */
  public void setNewDelay(long newdelay) {
<span class="nc" id="L193">    delay = newdelay;</span>
<span class="nc" id="L194">  }</span>

  @Override
  protected void channelRead0(ChannelHandlerContext ctx, String msg)
      throws Exception {
<span class="fc" id="L199">    answered = false;</span>

    // Generate and write a response.
    String response;
<span class="fc" id="L203">    response = LocalExecDefaultResult.NoStatus.getStatus() + &quot; &quot; +</span>
<span class="fc" id="L204">               LocalExecDefaultResult.NoStatus.getResult();</span>
<span class="fc" id="L205">    ExecuteWatchdog watchdog = null;</span>
    try {
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">      if (msg.length() == 0) {</span>
        // No command
<span class="nc" id="L209">        response = LocalExecDefaultResult.NoCommand.getStatus() + &quot; &quot; +</span>
<span class="nc" id="L210">                   LocalExecDefaultResult.NoCommand.getResult();</span>
      } else {
<span class="fc" id="L212">        final String[] args = msg.split(&quot; &quot;);</span>
<span class="fc" id="L213">        int cpt = 0;</span>
        long tempDelay;
        try {
<span class="fc" id="L216">          tempDelay = Long.parseLong(args[0]);</span>
<span class="fc" id="L217">          cpt++;</span>
<span class="fc" id="L218">        } catch (final NumberFormatException e) {</span>
<span class="fc" id="L219">          tempDelay = delay;</span>
<span class="fc" id="L220">        }</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">        if (tempDelay &lt; 0) {</span>
          // Shutdown Order
<span class="fc" id="L223">          isShutdown = true;</span>
<span class="fc" id="L224">          logger.warn(&quot;Shutdown order received&quot;);</span>
<span class="fc" id="L225">          response = LocalExecDefaultResult.ShutdownOnGoing.getStatus() + &quot; &quot; +</span>
<span class="fc" id="L226">                     LocalExecDefaultResult.ShutdownOnGoing.getResult();</span>
<span class="fc" id="L227">          final Thread thread = new GGLEThreadShutdown(factory);</span>
<span class="fc" id="L228">          thread.start();</span>
<span class="fc" id="L229">          return;</span>
        }
<span class="fc" id="L231">        final String binary = args[cpt++];</span>
<span class="fc" id="L232">        final File exec = new File(binary);</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">        if (exec.isAbsolute()) {</span>
          // If true file, is it executable
<span class="nc bnc" id="L235" title="All 2 branches missed.">          if (!exec.canExecute()) {</span>
<span class="nc" id="L236">            logger.error(&quot;Exec command is not executable: &quot; + msg);</span>
<span class="nc" id="L237">            response = LocalExecDefaultResult.NotExecutable.getStatus() + &quot; &quot; +</span>
<span class="nc" id="L238">                       LocalExecDefaultResult.NotExecutable.getResult();</span>
<span class="nc" id="L239">            return;</span>
          }
        }
        // Create command with parameters
<span class="fc" id="L243">        final CommandLine commandLine = new CommandLine(binary);</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">        for (; cpt &lt; args.length; cpt++) {</span>
<span class="fc" id="L245">          commandLine.addArgument(args[cpt]);</span>
        }
<span class="fc" id="L247">        final DefaultExecutor defaultExecutor = new DefaultExecutor();</span>
        ByteArrayOutputStream outputStream;
<span class="fc" id="L249">        outputStream = new ByteArrayOutputStream();</span>
<span class="fc" id="L250">        final PumpStreamHandler pumpStreamHandler =</span>
            new PumpStreamHandler(outputStream);
<span class="fc" id="L252">        defaultExecutor.setStreamHandler(pumpStreamHandler);</span>
<span class="fc" id="L253">        final int[] correctValues = { 0, 1 };</span>
<span class="fc" id="L254">        defaultExecutor.setExitValues(correctValues);</span>
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        if (tempDelay &gt; 0) {</span>
          // If delay (max time), then setup Watchdog
<span class="fc" id="L257">          watchdog = new ExecuteWatchdog(tempDelay);</span>
<span class="fc" id="L258">          defaultExecutor.setWatchdog(watchdog);</span>
        }
<span class="fc" id="L260">        int status = -1;</span>
        try {
          // Execute the command
<span class="fc" id="L263">          status = defaultExecutor.execute(commandLine);//NOSONAR</span>
<span class="nc" id="L264">        } catch (final ExecuteException e) {</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">          if (e.getExitValue() == -559038737) {</span>
            // Cannot run immediately so retry once
            try {
<span class="nc" id="L268">              Thread.sleep(LocalExecDefaultResult.RETRYINMS);</span>
<span class="nc" id="L269">            } catch (final InterruptedException e1) {//NOSONAR</span>
<span class="nc" id="L270">              SysErrLogger.FAKE_LOGGER.ignoreLog(e1);</span>
<span class="nc" id="L271">            }</span>
            try {
<span class="nc" id="L273">              status = defaultExecutor.execute(commandLine);//NOSONAR</span>
<span class="nc" id="L274">            } catch (final ExecuteException e1) {</span>
              try {
<span class="nc" id="L276">                pumpStreamHandler.stop();</span>
<span class="nc" id="L277">              } catch (final IOException ignored) {</span>
                // nothing
<span class="nc" id="L279">              }</span>
<span class="nc" id="L280">              logger.error(EXCEPTION + e.getMessage() + EXEC_IN_ERROR_WITH +</span>
                           commandLine);
<span class="nc" id="L282">              response = LocalExecDefaultResult.BadExecution.getStatus() + &quot; &quot; +</span>
<span class="nc" id="L283">                         LocalExecDefaultResult.BadExecution.getResult();</span>
<span class="nc" id="L284">              FileUtils.close(outputStream);</span>
<span class="nc" id="L285">              return;</span>
<span class="nc" id="L286">            } catch (final IOException e1) {</span>
              try {
<span class="nc" id="L288">                pumpStreamHandler.stop();</span>
<span class="nc" id="L289">              } catch (final IOException ignored) {</span>
                // nothing
<span class="nc" id="L291">              }</span>
<span class="nc" id="L292">              logger.error(EXCEPTION + e.getMessage() + EXEC_IN_ERROR_WITH +</span>
                           commandLine);
<span class="nc" id="L294">              response = LocalExecDefaultResult.BadExecution.getStatus() + &quot; &quot; +</span>
<span class="nc" id="L295">                         LocalExecDefaultResult.BadExecution.getResult();</span>
<span class="nc" id="L296">              FileUtils.close(outputStream);</span>
<span class="nc" id="L297">              return;</span>
<span class="nc" id="L298">            }</span>
          } else {
            try {
<span class="nc" id="L301">              pumpStreamHandler.stop();</span>
<span class="nc" id="L302">            } catch (final IOException ignored) {</span>
              // nothing
<span class="nc" id="L304">            }</span>
<span class="nc" id="L305">            logger.error(</span>
<span class="nc" id="L306">                EXCEPTION + e.getMessage() + EXEC_IN_ERROR_WITH + commandLine);</span>
<span class="nc" id="L307">            response = LocalExecDefaultResult.BadExecution.getStatus() + &quot; &quot; +</span>
<span class="nc" id="L308">                       LocalExecDefaultResult.BadExecution.getResult();</span>
<span class="nc" id="L309">            FileUtils.close(outputStream);</span>
<span class="nc" id="L310">            return;</span>
          }
<span class="nc" id="L312">        } catch (final IOException e) {</span>
          try {
<span class="nc" id="L314">            pumpStreamHandler.stop();</span>
<span class="nc" id="L315">          } catch (final IOException ignored) {</span>
            // nothing
<span class="nc" id="L317">          }</span>
<span class="nc" id="L318">          logger.error(</span>
<span class="nc" id="L319">              EXCEPTION + e.getMessage() + EXEC_IN_ERROR_WITH + commandLine);</span>
<span class="nc" id="L320">          response = LocalExecDefaultResult.BadExecution.getStatus() + &quot; &quot; +</span>
<span class="nc" id="L321">                     LocalExecDefaultResult.BadExecution.getResult();</span>
<span class="nc" id="L322">          FileUtils.close(outputStream);</span>
<span class="nc" id="L323">          return;</span>
<span class="pc" id="L324">        }</span>
        try {
<span class="fc" id="L326">          pumpStreamHandler.stop();</span>
<span class="nc" id="L327">        } catch (final IOException ignored) {</span>
          // nothing
<span class="fc" id="L329">        }</span>
<span class="pc bpc" id="L330" title="3 of 4 branches missed.">        if (defaultExecutor.isFailure(status) &amp;&amp; watchdog != null &amp;&amp;</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">            watchdog.killedProcess()) {</span>
          // kill by the watchdoc (time out)
<span class="nc" id="L333">          logger.error(&quot;Exec is in Time Out&quot;);</span>
<span class="nc" id="L334">          response = LocalExecDefaultResult.TimeOutExecution.getStatus() + &quot; &quot; +</span>
<span class="nc" id="L335">                     LocalExecDefaultResult.TimeOutExecution.getResult();</span>
<span class="nc" id="L336">          FileUtils.close(outputStream);</span>
        } else {
          try {
<span class="fc" id="L339">            response = status + &quot; &quot; +</span>
<span class="fc" id="L340">                       outputStream.toString(WaarpStringUtils.UTF8.name());</span>
<span class="nc" id="L341">          } catch (final UnsupportedEncodingException e) {</span>
<span class="nc" id="L342">            response = status + &quot; &quot; + outputStream;</span>
<span class="fc" id="L343">          }</span>
<span class="fc" id="L344">          FileUtils.close(outputStream);</span>
        }
      }
    } finally {
      // We do not need to write a ByteBuf here.
      // We know the encoder inserted at LocalExecInitializer will do the
      // conversion.
<span class="fc" id="L351">      ctx.channel().writeAndFlush(response + '\n');</span>
<span class="fc" id="L352">      answered = true;</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">      if (watchdog != null) {</span>
<span class="fc" id="L354">        watchdog.stop();</span>
      }
<span class="fc" id="L356">      logger.info(&quot;End of Command: &quot; + msg + &quot; : &quot; + response);</span>
<span class="fc" id="L357">      ctx.channel().writeAndFlush(LocalExecDefaultResult.ENDOFCOMMAND + '\n');</span>
    }
<span class="fc" id="L359">  }</span>

  @Override
  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
      throws Exception {
<span class="nc bnc" id="L364" title="All 2 branches missed.">    if (!answered) {</span>
<span class="nc" id="L365">      logger.error(&quot;Unexpected exception from Outband while not answered.&quot;,</span>
                   cause);
    }
    // Look if Nothing to do since execution will stop later on and
    // an error will occur on client side
    // since no message arrived before close (or partially)
<span class="nc bnc" id="L371" title="All 2 branches missed.">    if (cause instanceof CancelledKeyException) {</span>
      // nothing
<span class="nc bnc" id="L373" title="All 2 branches missed.">    } else if (cause instanceof ClosedChannelException) {</span>
      // nothing
<span class="nc bnc" id="L375" title="All 2 branches missed.">    } else if (cause instanceof NullPointerException) {</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">      if (ctx.channel().isActive()) {</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (answered) {</span>
<span class="nc" id="L378">          logger.debug(EXCEPTION_WHILE_ANSWERED, cause);</span>
        }
<span class="nc" id="L380">        WaarpSslUtility.closingSslChannel(ctx.channel());</span>
      }
<span class="nc bnc" id="L382" title="All 2 branches missed.">    } else if (cause instanceof IOException) {</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">      if (ctx.channel().isActive()) {</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (answered) {</span>
<span class="nc" id="L385">          logger.debug(EXCEPTION_WHILE_ANSWERED, cause);</span>
        }
<span class="nc" id="L387">        WaarpSslUtility.closingSslChannel(ctx.channel());</span>
      }
<span class="nc bnc" id="L389" title="All 2 branches missed.">    } else if (cause instanceof RejectedExecutionException) {</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">      if (ctx.channel().isActive()) {</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">        if (answered) {</span>
<span class="nc" id="L392">          logger.debug(EXCEPTION_WHILE_ANSWERED, cause);</span>
        }
<span class="nc" id="L394">        WaarpSslUtility.closingSslChannel(ctx.channel());</span>
      }
    }
<span class="nc" id="L397">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>