<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WaarpR66S3Client.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Waarp Extensions for JRE 8 and greater</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.s3</a> &gt; <span class="el_source">WaarpR66S3Client.java</span></div><h1>WaarpR66S3Client.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.openr66.s3;

import com.google.common.base.Function;
import com.google.common.collect.Iterators;
import io.minio.BucketExistsArgs;
import io.minio.GetObjectArgs;
import io.minio.GetObjectRetentionArgs;
import io.minio.GetObjectTagsArgs;
import io.minio.ListObjectsArgs;
import io.minio.MakeBucketArgs;
import io.minio.MinioClient;
import io.minio.ObjectWriteResponse;
import io.minio.RemoveObjectArgs;
import io.minio.Result;
import io.minio.SetObjectRetentionArgs;
import io.minio.SetObjectTagsArgs;
import io.minio.UploadObjectArgs;
import io.minio.errors.MinioException;
import io.minio.messages.Item;
import io.minio.messages.Retention;
import io.minio.messages.RetentionMode;
import io.minio.messages.Tags;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.waarp.common.file.FileUtils;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.ParametersChecker;
import org.waarp.common.utility.SingletonUtils;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNetworkException;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.time.ZonedDateTime;
import java.util.Iterator;
import java.util.Map;

import static org.waarp.common.file.FileUtils.*;

/**
 * Waarp R66 S3 Client
 */
public class WaarpR66S3Client {
<span class="fc" id="L67">  private static final WaarpLogger logger =</span>
<span class="fc" id="L68">      WaarpLoggerFactory.getLogger(WaarpR66S3Client.class);</span>
  public static final String BUCKET_OR_TARGET_CANNOT_BE_NULL_OR_EMPTY =
      &quot;Bucket or Target cannot be null or empty&quot;;
  public static final String S_3_ISSUE = &quot;S3 issue: &quot;;
  public static final String BUCKET_OR_SOURCE_CANNOT_BE_NULL_OR_EMPTY =
      &quot;Bucket or Source cannot be null or empty&quot;;

<span class="fc" id="L75">  private static final Function&lt;Result&lt;Item&gt;, String&gt; function =</span>
<span class="fc" id="L76">      new Function&lt;Result&lt;Item&gt;, String&gt;() {</span>
        @Override
        public final @Nullable String apply(
            @Nullable final Result&lt;Item&gt; itemResult) {
          try {
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">            if (itemResult != null) {</span>
<span class="fc" id="L82">              final Item item = itemResult.get();</span>
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">              if (item != null) {</span>
<span class="fc" id="L84">                return item.objectName();</span>
              }
            }
<span class="nc" id="L87">            return null;</span>
<span class="nc" id="L88">          } catch (final MinioException | InvalidKeyException | IOException |</span>
                         NoSuchAlgorithmException e) {
<span class="nc" id="L90">            logger.error(e.getMessage());</span>
<span class="nc" id="L91">            return null;</span>
          }
        }
      };
  private final MinioClient minioClient;

  /**
   * Initialize context for S3 Client
   *
   * @param accessKey
   * @param secretKey
   * @param endPointS3
   */
  public WaarpR66S3Client(final String accessKey, final String secretKey,
<span class="fc" id="L105">                          final URL endPointS3) {</span>
<span class="fc" id="L106">    ParametersChecker.checkParameter(&quot;Parameters cannot be null or empty&quot;,</span>
                                     accessKey, secretKey, endPointS3);
    // Create a minioClient with the MinIO server playground, its access key and secret key.
<span class="fc" id="L109">    minioClient = MinioClient.builder().endpoint(endPointS3)</span>
<span class="fc" id="L110">                             .credentials(accessKey, secretKey).build();</span>
<span class="fc" id="L111">  }</span>

  /**
   * Create one file into S3 with optional Tags (null if none)
   *
   * @param bucketName
   * @param targetName
   * @param file
   * @param tags
   *
   * @return versionId
   *
   * @throws OpenR66ProtocolNetworkException
   */
  public final String createFile(final String bucketName,
                                 final String targetName, final File file,
                                 final Map&lt;String, String&gt; tags)
      throws OpenR66ProtocolNetworkException {
<span class="fc" id="L129">    ParametersChecker.checkParameter(BUCKET_OR_TARGET_CANNOT_BE_NULL_OR_EMPTY,</span>
                                     bucketName, targetName);
<span class="fc" id="L131">    ParametersChecker.checkParameter(&quot;File cannot be null&quot;, file);</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">    if (!file.canRead()) {</span>
<span class="nc" id="L133">      throw new IllegalArgumentException(</span>
<span class="nc" id="L134">          &quot;File cannot be read: &quot; + file.getAbsolutePath());</span>
    }
<span class="fc" id="L136">    boolean uploaded = false;</span>
<span class="fc" id="L137">    boolean error = false;</span>
    try {
      // Make bucketName bucket if not exist.
<span class="fc" id="L140">      final boolean found = minioClient.bucketExists(</span>
<span class="fc" id="L141">          BucketExistsArgs.builder().bucket(bucketName).build());</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">      if (!found) {</span>
        // Make a new bucket
<span class="fc" id="L144">        minioClient.makeBucket(</span>
<span class="fc" id="L145">            MakeBucketArgs.builder().bucket(bucketName).build());</span>
      } else {
<span class="fc" id="L147">        logger.info(&quot;Bucket {} already exists.&quot;, bucketName);</span>
      }
      // Upload file as object name targetName to bucket bucketName
<span class="fc" id="L150">      final ObjectWriteResponse response = minioClient.uploadObject(</span>
<span class="fc" id="L151">          UploadObjectArgs.builder().bucket(bucketName).object(targetName)</span>
<span class="fc" id="L152">                          .filename(file.getAbsolutePath()).build());</span>
<span class="fc" id="L153">      uploaded = true;</span>
<span class="fc" id="L154">      logger.info(&quot;{} is successfully uploaded as object {} to bucket {}.&quot;,</span>
<span class="fc" id="L155">                  file.getAbsolutePath(), targetName, bucketName);</span>
<span class="pc bpc" id="L156" title="1 of 4 branches missed.">      if (tags != null &amp;&amp; !tags.isEmpty()) {</span>
<span class="fc" id="L157">        minioClient.setObjectTags(</span>
<span class="fc" id="L158">            SetObjectTagsArgs.builder().bucket(bucketName).object(targetName)</span>
<span class="fc" id="L159">                             .tags(tags).build());</span>
      }
<span class="fc" id="L161">      logger.debug(&quot;Resp: {} {} {} {} {}&quot;, response.bucket(), response.object(),</span>
<span class="fc" id="L162">                   response.versionId(), response.etag(), response.region());</span>
<span class="fc" id="L163">      return response.versionId();</span>
<span class="nc" id="L164">    } catch (final MinioException | IOException | NoSuchAlgorithmException |</span>
                   InvalidKeyException e) {
<span class="nc" id="L166">      logger.error(e.getMessage());</span>
<span class="nc" id="L167">      error = true;</span>
<span class="nc" id="L168">      throw new OpenR66ProtocolNetworkException(S_3_ISSUE + e.getMessage(), e);</span>
    } finally {
<span class="pc bpc" id="L170" title="3 of 4 branches missed.">      if (error &amp;&amp; uploaded) {</span>
        // Clean incompletely object creation
        try {
<span class="nc" id="L173">          deleteFile(bucketName, targetName);</span>
<span class="nc" id="L174">        } catch (final Exception e) {</span>
<span class="nc" id="L175">          logger.warn(</span>
              &quot;Error while cleaning S3 file incompletely created&quot; + &quot; : {}&quot;,
<span class="nc" id="L177">              e.getMessage());</span>
<span class="nc" id="L178">        }</span>
      }
    }
  }

  /**
   * Set a Tags to S3
   *
   * @param bucketName
   * @param targetName
   * @param tags
   *
   * @throws OpenR66ProtocolNetworkException
   */
  public final void setTags(final String bucketName, final String targetName,
                            final Map&lt;String, String&gt; tags)
      throws OpenR66ProtocolNetworkException {
<span class="nc" id="L195">    ParametersChecker.checkParameter(BUCKET_OR_TARGET_CANNOT_BE_NULL_OR_EMPTY,</span>
                                     bucketName, targetName);
    try {
<span class="nc bnc" id="L198" title="All 4 branches missed.">      if (tags != null &amp;&amp; !tags.isEmpty()) {</span>
<span class="nc" id="L199">        minioClient.setObjectTags(</span>
<span class="nc" id="L200">            SetObjectTagsArgs.builder().bucket(bucketName).object(targetName)</span>
<span class="nc" id="L201">                             .tags(tags).build());</span>
      }
<span class="nc" id="L203">    } catch (final MinioException | IOException | NoSuchAlgorithmException |</span>
                   InvalidKeyException e) {
<span class="nc" id="L205">      logger.error(e.getMessage());</span>
<span class="nc" id="L206">      throw new OpenR66ProtocolNetworkException(S_3_ISSUE + e.getMessage(), e);</span>
<span class="nc" id="L207">    }</span>
<span class="nc" id="L208">  }</span>

  /**
   * Get the ZoneDateTime when this Object will be deleted
   *
   * @param bucketName
   * @param sourceName
   *
   * @return the ZoneDateTime
   *
   * @throws OpenR66ProtocolNetworkException
   */
  public final ZonedDateTime getObjectRetention(final String bucketName,
                                                final String sourceName)
      throws OpenR66ProtocolNetworkException {
<span class="nc" id="L223">    ParametersChecker.checkParameter(BUCKET_OR_TARGET_CANNOT_BE_NULL_OR_EMPTY,</span>
                                     bucketName, sourceName);
    try {
<span class="nc" id="L226">      final Retention retention = minioClient.getObjectRetention(</span>
<span class="nc" id="L227">          GetObjectRetentionArgs.builder().bucket(bucketName).object(bucketName)</span>
<span class="nc" id="L228">                                .build());</span>
<span class="nc" id="L229">      return retention.retainUntilDate();</span>
<span class="nc" id="L230">    } catch (final MinioException | InvalidKeyException | IOException |</span>
                   NoSuchAlgorithmException e) {
<span class="nc" id="L232">      logger.error(e.getMessage());</span>
<span class="nc" id="L233">      throw new OpenR66ProtocolNetworkException(S_3_ISSUE + e.getMessage(), e);</span>
    }
  }

  /**
   * Bypass the governance retention and set a specific validity time in the future
   *
   * @param bucketName
   * @param targetName
   * @param retentionUntil
   *
   * @throws OpenR66ProtocolNetworkException
   */
  public final void bypassObjectRetention(final String bucketName,
                                          final String targetName,
                                          final ZonedDateTime retentionUntil)
      throws OpenR66ProtocolNetworkException {
<span class="nc" id="L250">    ParametersChecker.checkParameter(BUCKET_OR_TARGET_CANNOT_BE_NULL_OR_EMPTY,</span>
                                     bucketName, targetName);
<span class="nc" id="L252">    ParametersChecker.checkParameter(&quot;Retention cannot be null&quot;,</span>
                                     retentionUntil);
<span class="nc bnc" id="L254" title="All 2 branches missed.">    if (retentionUntil.isBefore(ZonedDateTime.now())) {</span>
<span class="nc" id="L255">      logger.warn(&quot;Retention Date Time is before now&quot;);</span>
<span class="nc" id="L256">      throw new IllegalArgumentException(&quot;Retention Date Time is before now&quot;);</span>
    }
<span class="nc" id="L258">    final Retention config =</span>
        new Retention(RetentionMode.COMPLIANCE, retentionUntil);
    // Set object retention
    try {
<span class="nc" id="L262">      minioClient.setObjectRetention(</span>
<span class="nc" id="L263">          SetObjectRetentionArgs.builder().bucket(bucketName).object(targetName)</span>
<span class="nc" id="L264">                                .config(config).bypassGovernanceMode(true)</span>
<span class="nc" id="L265">                                .build());</span>
<span class="nc" id="L266">    } catch (final MinioException | InvalidKeyException | IOException |</span>
                   NoSuchAlgorithmException e) {
<span class="nc" id="L268">      logger.error(e.getMessage());</span>
<span class="nc" id="L269">      throw new OpenR66ProtocolNetworkException(S_3_ISSUE + e.getMessage(), e);</span>
<span class="nc" id="L270">    }</span>
<span class="nc" id="L271">  }</span>

  /**
   * Get a File from S3
   *
   * @param bucketName
   * @param sourceName
   * @param file
   * @param getTags if False, will return an empty Map
   *
   * @return the Tag as Map of Strings
   *
   * @throws OpenR66ProtocolNetworkException
   */
  public final Map&lt;String, String&gt; getFile(final String bucketName,
                                           final String sourceName,
                                           final File file,
                                           final boolean getTags)
      throws OpenR66ProtocolNetworkException {
<span class="fc" id="L290">    ParametersChecker.checkParameter(BUCKET_OR_SOURCE_CANNOT_BE_NULL_OR_EMPTY,</span>
                                     bucketName, sourceName);
<span class="fc" id="L292">    ParametersChecker.checkParameter(&quot;File cannot be null&quot;, file);</span>
<span class="fc" id="L293">    boolean downloaded = false;</span>
<span class="fc" id="L294">    boolean error = false;</span>
    // Get input stream
<span class="fc" id="L296">    try (final InputStream stream = minioClient.getObject(</span>
<span class="fc" id="L297">        GetObjectArgs.builder().bucket(bucketName).object(sourceName).build());</span>
<span class="fc" id="L298">         final FileOutputStream outputStream = new FileOutputStream(file)) {</span>
<span class="fc" id="L299">      final byte[] buf = new byte[ZERO_COPY_CHUNK_SIZE];</span>
      int bytesRead;
<span class="fc bfc" id="L301" title="All 2 branches covered.">      while ((bytesRead = stream.read(buf, 0, buf.length)) &gt;= 0) {</span>
<span class="fc" id="L302">        outputStream.write(buf, 0, bytesRead);</span>
      }
<span class="fc" id="L304">      FileUtils.close(outputStream);</span>
<span class="fc" id="L305">      FileUtils.close(stream);</span>
<span class="fc" id="L306">      downloaded = true;</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">      if (getTags) {</span>
<span class="fc" id="L308">        final Tags tags = minioClient.getObjectTags(</span>
<span class="fc" id="L309">            GetObjectTagsArgs.builder().bucket(bucketName).object(sourceName)</span>
<span class="fc" id="L310">                             .build());</span>
<span class="fc" id="L311">        return tags.get();</span>
      } else {
<span class="nc" id="L313">        return SingletonUtils.singletonMap();</span>
      }
<span class="nc" id="L315">    } catch (final MinioException | IOException | NoSuchAlgorithmException |</span>
                   InvalidKeyException e) {
<span class="nc" id="L317">      logger.info(e);</span>
<span class="nc" id="L318">      error = true;</span>
<span class="nc" id="L319">      throw new OpenR66ProtocolNetworkException(S_3_ISSUE + e.getMessage(), e);</span>
    } finally {
<span class="pc bpc" id="L321" title="3 of 4 branches missed.">      if (error &amp;&amp; downloaded) {</span>
        // Delete wrongly deleted file
<span class="nc" id="L323">        file.delete();</span>
      }
    }
  }

  /**
   * Get a Tags from S3
   *
   * @param bucketName
   * @param sourceName
   *
   * @return the Tag as Map of Strings
   *
   * @throws OpenR66ProtocolNetworkException
   */
  public final Map&lt;String, String&gt; getTags(final String bucketName,
                                           final String sourceName)
      throws OpenR66ProtocolNetworkException {
<span class="nc" id="L341">    ParametersChecker.checkParameter(BUCKET_OR_SOURCE_CANNOT_BE_NULL_OR_EMPTY,</span>
                                     bucketName, sourceName);
    try {
<span class="nc" id="L344">      final Tags tags = minioClient.getObjectTags(</span>
<span class="nc" id="L345">          GetObjectTagsArgs.builder().bucket(bucketName).object(sourceName)</span>
<span class="nc" id="L346">                           .build());</span>

<span class="nc" id="L348">      return tags.get();</span>
<span class="nc" id="L349">    } catch (final MinioException | IOException | NoSuchAlgorithmException |</span>
                   InvalidKeyException e) {
<span class="nc" id="L351">      logger.error(e.getMessage());</span>
<span class="nc" id="L352">      throw new OpenR66ProtocolNetworkException(S_3_ISSUE + e.getMessage(), e);</span>
    }
  }

  /**
   * Delete S3 source
   *
   * @param bucketName
   * @param sourceName
   *
   * @throws OpenR66ProtocolNetworkException
   */
  public final void deleteFile(final String bucketName, final String sourceName)
      throws OpenR66ProtocolNetworkException {
<span class="fc" id="L366">    ParametersChecker.checkParameter(BUCKET_OR_SOURCE_CANNOT_BE_NULL_OR_EMPTY,</span>
                                     bucketName, sourceName);
    try {
      // Remove object.
<span class="fc" id="L370">      minioClient.removeObject(</span>
<span class="fc" id="L371">          RemoveObjectArgs.builder().bucket(bucketName).object(sourceName)</span>
<span class="fc" id="L372">                          .build());</span>
<span class="nc" id="L373">    } catch (final MinioException | IOException | NoSuchAlgorithmException |</span>
                   InvalidKeyException e) {
<span class="nc" id="L375">      logger.error(e.getMessage());</span>
<span class="nc" id="L376">      throw new OpenR66ProtocolNetworkException(S_3_ISSUE + e.getMessage(), e);</span>
<span class="fc" id="L377">    }</span>
<span class="fc" id="L378">  }</span>

  /**
   * Get sourceNames from S3 from the bucketName specified, names optionally starting with a String, recursively or not,
   * and possibly unlimited (if limit is &lt;= 0)
   *
   * @param bucketName
   * @param optionalNameStartWith could be null or empty
   * @param recursively False only from main directory, True scanning also subdirectories
   * @param limit if &lt;= 0, unlimited
   *
   * @return the Iterator on found sourceNames
   *
   * @throws OpenR66ProtocolNetworkException
   */
  public final Iterator&lt;String&gt; listObjectsFromBucket(final String bucketName,
                                                      final String optionalNameStartWith,
                                                      final boolean recursively,
                                                      final int limit)
      throws OpenR66ProtocolNetworkException {
<span class="fc" id="L398">    ParametersChecker.checkParameter(&quot;Bucket cannot be null or empty&quot;,</span>
                                     bucketName);
    try {
      // List recursively
      final ListObjectsArgs.Builder builder =
<span class="fc" id="L403">          ListObjectsArgs.builder().bucket(bucketName).recursive(recursively);</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">      if (ParametersChecker.isNotEmpty(optionalNameStartWith)) {</span>
<span class="nc" id="L405">        builder.prefix(optionalNameStartWith);</span>
      }
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">      if (limit &gt; 0) {</span>
<span class="nc" id="L408">        builder.maxKeys(limit);</span>
      }
<span class="fc" id="L410">      final ListObjectsArgs args = builder.build();</span>
<span class="fc" id="L411">      final Iterable&lt;Result&lt;Item&gt;&gt; iterable = minioClient.listObjects(args);</span>
<span class="fc" id="L412">      return Iterators.transform(iterable.iterator(), function);</span>
<span class="nc" id="L413">    } catch (final Exception e) {</span>
<span class="nc" id="L414">      logger.error(e.getMessage());</span>
<span class="nc" id="L415">      throw new OpenR66ProtocolNetworkException(S_3_ISSUE + e.getMessage(), e);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>