<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>LocalExecClientHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Extensions for JRE 8 and greater</a> &gt; <a href="../index.html" class="el_bundle">WaarpExec</a> &gt; <a href="index.source.html" class="el_package">org.waarp.commandexec.client</a> &gt; <span class="el_source">LocalExecClientHandler.java</span></div><h1>LocalExecClientHandler.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.commandexec.client;

import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import org.waarp.commandexec.utils.LocalExecDefaultResult;
import org.waarp.commandexec.utils.LocalExecResult;
import org.waarp.common.crypto.ssl.WaarpSslUtility;
import org.waarp.common.future.WaarpFuture;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.WaarpNettyUtil;

/**
 * Handles a client-side channel for LocalExec
 */
public class LocalExecClientHandler
    extends SimpleChannelInboundHandler&lt;String&gt; {

  /**
   * Internal Logger
   */
<span class="fc" id="L42">  private static final WaarpLogger logger =</span>
<span class="fc" id="L43">      WaarpLoggerFactory.getLogger(LocalExecClientHandler.class);</span>

  protected LocalExecResult result;
  protected StringBuilder back;
<span class="fc" id="L47">  protected boolean firstMessage = true;</span>
  protected WaarpFuture future;
  protected final LocalExecClientInitializer factory;
  protected long delay;
  protected String command;
  protected Channel channel;
<span class="fc" id="L53">  protected final WaarpFuture ready = new WaarpFuture(true);</span>

  /**
   * Constructor
   */
<span class="fc" id="L58">  public LocalExecClientHandler(final LocalExecClientInitializer factory) {</span>
<span class="fc" id="L59">    this.factory = factory;</span>
<span class="fc" id="L60">  }</span>

  /**
   * Initialize the client status for a new execution
   *
   * @param delay
   * @param command
   */
  public final void initExecClient(final long delay, final String command) {
<span class="fc" id="L69">    result = new LocalExecResult(LocalExecDefaultResult.NoStatus);</span>
<span class="fc" id="L70">    back = new StringBuilder();</span>
<span class="fc" id="L71">    firstMessage = true;</span>
<span class="fc" id="L72">    future = new WaarpFuture(true);</span>
<span class="fc" id="L73">    this.delay = delay;</span>
<span class="fc" id="L74">    this.command = command;</span>
    // Sends the received line to the server.
<span class="pc bpc" id="L76" title="3 of 4 branches missed.">    if (!ready.awaitOrInterruptible() &amp;&amp; channel == null) {</span>
<span class="nc" id="L77">      throw new RuntimeException(&quot;Cannot get client connected&quot;);</span>
    }
<span class="fc" id="L79">    logger.debug(&quot;write command: {}&quot;, this.command);</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">    if (this.delay != 0) {</span>
<span class="fc" id="L81">      WaarpNettyUtil.awaitOrInterrupted(</span>
<span class="fc" id="L82">          channel.writeAndFlush(this.delay + &quot; &quot; + this.command + '\n'));</span>
    } else {
<span class="fc" id="L84">      WaarpNettyUtil.awaitOrInterrupted(</span>
<span class="fc" id="L85">          channel.writeAndFlush(this.command + '\n'));</span>
    }
<span class="fc" id="L87">  }</span>

  @Override
  public void channelActive(final ChannelHandlerContext ctx) throws Exception {
<span class="fc" id="L91">    channel = ctx.channel();</span>
<span class="fc" id="L92">    factory.addChannel(channel);</span>
<span class="fc" id="L93">    ready.setSuccess();</span>
<span class="fc" id="L94">    super.channelActive(ctx);</span>
<span class="fc" id="L95">  }</span>

  /**
   * When closed, &lt;br&gt;
   * If no messaged were received =&gt; NoMessage error is set to future&lt;br&gt;
   * Else if an error was detected =&gt; Set the future to error (with or without
   * exception)&lt;br&gt;
   * Else if no error occurs =&gt; Set success to the future&lt;br&gt;
   */
  @Override
  public void channelInactive(final ChannelHandlerContext ctx)
      throws Exception {
<span class="pc bpc" id="L107" title="2 of 4 branches missed.">    if (future == null || !future.isDone()) {</span>
      // Should not be
<span class="nc" id="L109">      finalizeMessage();</span>
    }
<span class="fc" id="L111">    super.channelInactive(ctx);</span>
<span class="fc" id="L112">  }</span>

  /**
   * Finalize a message
   */
  private void finalizeMessage() {
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">    if (result == null) {</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">      if (future != null) {</span>
<span class="nc" id="L120">        future.cancel();</span>
      }
<span class="nc" id="L122">      return;</span>
    }
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">    if (firstMessage) {</span>
<span class="nc" id="L125">      result.set(LocalExecDefaultResult.NoMessage);</span>
    } else {
<span class="fc" id="L127">      result.setResult(back.toString());</span>
    }
<span class="fc bfc" id="L129" title="All 2 branches covered.">    if (result.getStatus() &lt; 0) {</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">      if (result.getException() != null) {</span>
<span class="nc" id="L131">        future.setFailure(result.getException());</span>
      } else {
<span class="fc" id="L133">        future.cancel();</span>
      }
    } else {
<span class="fc" id="L136">      future.setSuccess();</span>
    }
<span class="fc" id="L138">  }</span>

  /**
   * Waiting for the close of the exec
   *
   * @return The LocalExecResult
   */
  public final LocalExecResult waitFor(final long delay) {
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">    if (delay &lt;= 0) {</span>
<span class="nc" id="L147">      future.awaitOrInterruptible();</span>
    } else {
<span class="fc" id="L149">      future.awaitOrInterruptible(delay);</span>
    }
<span class="fc" id="L151">    result.setSuccess(future.isSuccess());</span>
<span class="fc" id="L152">    return result;</span>
  }

  /**
   * Action to do before close
   */
  public final void actionBeforeClose(final Channel channel) {
    // here nothing to do
<span class="nc" id="L160">  }</span>

  @Override
  protected void channelRead0(final ChannelHandlerContext ctx, String mesg) {
    // Add the line received from the server.
    // If first message, then take the status and then the message
<span class="fc bfc" id="L166" title="All 2 branches covered.">    if (firstMessage) {</span>
<span class="fc" id="L167">      firstMessage = false;</span>
<span class="fc" id="L168">      final int pos = mesg.indexOf(' ');</span>
      try {
<span class="fc" id="L170">        result.setStatus(Integer.parseInt(mesg.substring(0, pos)));</span>
<span class="nc" id="L171">      } catch (final NumberFormatException e1) {</span>
        // Error
<span class="nc" id="L173">        logger.debug(</span>
            command + ':' + &quot;Bad Transmission: &quot; + mesg + &quot;\n\t&quot; + back);
<span class="nc" id="L175">        result.set(LocalExecDefaultResult.BadTransmition);</span>
<span class="nc" id="L176">        back.append(mesg);</span>
<span class="nc" id="L177">        actionBeforeClose(ctx.channel());</span>
<span class="nc" id="L178">        WaarpSslUtility.closingSslChannel(ctx.channel());</span>
<span class="nc" id="L179">        return;</span>
<span class="fc" id="L180">      }</span>
<span class="fc" id="L181">      mesg = mesg.substring(pos + 1);</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">      if (mesg.startsWith(LocalExecDefaultResult.ENDOFCOMMAND)) {</span>
<span class="nc" id="L183">        logger.debug(&quot;{}:Receive End of Command&quot;, command);</span>
<span class="nc" id="L184">        result.setResult(LocalExecDefaultResult.NoMessage.getResult());</span>
<span class="nc" id="L185">        back.append(result.getResult());</span>
<span class="nc" id="L186">        finalizeMessage();</span>
      } else {
<span class="fc" id="L188">        result.setResult(mesg);</span>
<span class="fc" id="L189">        back.append(mesg);</span>
      }
<span class="fc bfc" id="L191" title="All 2 branches covered.">    } else if (mesg.startsWith(LocalExecDefaultResult.ENDOFCOMMAND)) {</span>
<span class="fc" id="L192">      logger.debug(&quot;{}:Receive End of Command&quot;, command);</span>
<span class="fc" id="L193">      finalizeMessage();</span>
    } else {
<span class="fc" id="L195">      back.append('\n').append(mesg);</span>
    }
<span class="fc" id="L197">  }</span>

  @Override
  public void exceptionCaught(final ChannelHandlerContext ctx,
                              final Throwable cause) {
<span class="nc" id="L202">    logger.warn(command + ':' +</span>
                &quot;Unexpected exception from Outband while get information: &quot; +
                firstMessage, cause);
<span class="nc bnc" id="L205" title="All 2 branches missed.">    if (firstMessage) {</span>
<span class="nc" id="L206">      firstMessage = false;</span>
<span class="nc" id="L207">      result.set(LocalExecDefaultResult.BadTransmition);</span>
<span class="nc" id="L208">      result.setException((Exception) cause);</span>
<span class="nc" id="L209">      back = new StringBuilder(&quot;Error in LocalExec: &quot;).append(</span>
<span class="nc" id="L210">          result.getException().getMessage()).append('\n');</span>
    } else {
<span class="nc" id="L212">      back.append(&quot;\nERROR while receiving answer: &quot;);</span>
<span class="nc" id="L213">      result.setException((Exception) cause);</span>
<span class="nc" id="L214">      back.append(result.getException().getMessage()).append('\n');</span>
    }
<span class="nc" id="L216">    actionBeforeClose(ctx.channel());</span>
<span class="nc" id="L217">    WaarpSslUtility.closingSslChannel(ctx.channel());</span>
<span class="nc" id="L218">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>