<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ClientRunner.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Extensions for JRE 8 and greater</a> &gt; <a href="../index.html" class="el_bundle">WaarpR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.commander</a> &gt; <span class="el_source">ClientRunner.java</span></div><h1>ClientRunner.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.openr66.commander;

import org.waarp.common.command.exception.CommandAbstractException;
import org.waarp.common.database.data.AbstractDbData;
import org.waarp.common.database.data.AbstractDbData.UpdatedInfo;
import org.waarp.common.database.exception.WaarpDatabaseException;
import org.waarp.common.logging.SysErrLogger;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.openr66.client.RecvThroughHandler;
import org.waarp.openr66.context.ErrorCode;
import org.waarp.openr66.context.R66FiniteDualStates;
import org.waarp.openr66.context.R66Result;
import org.waarp.openr66.context.R66Session;
import org.waarp.openr66.context.task.exception.OpenR66RunnerErrorException;
import org.waarp.openr66.database.DbConstantR66;
import org.waarp.openr66.database.data.DbHostAuth;
import org.waarp.openr66.database.data.DbTaskRunner;
import org.waarp.openr66.database.data.DbTaskRunner.TASKSTEP;
import org.waarp.openr66.protocol.configuration.Configuration;
import org.waarp.openr66.protocol.configuration.Messages;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNoConnectionException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNoSslException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNotAuthenticatedException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNotYetConnectionException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolPacketException;
import org.waarp.openr66.protocol.localhandler.LocalChannelReference;
import org.waarp.openr66.protocol.localhandler.packet.RequestPacket;
import org.waarp.openr66.protocol.networkhandler.NetworkTransaction;
import org.waarp.openr66.protocol.utils.ChannelUtils;
import org.waarp.openr66.protocol.utils.R66Future;
import org.waarp.openr66.protocol.utils.TransferUtils;

import java.io.File;
import java.net.SocketAddress;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * Client Runner from a TaskRunner
 */
public class ClientRunner extends Thread {
  private static final String CANNOT_CONNECT_TO_SERVER =
      &quot;Cannot connect to server &quot;;

  private static final String REQUEST_INFORMATION_FAILURE =
      &quot;RequestInformation.Failure&quot;;

  private static final String REQUEST_INFORMATION_SUCCESS =
      &quot;RequestInformation.Success&quot;;

  private static final String TRANSFER_STATUS = &quot;Transfer.Status&quot;;

  /**
   * Internal Logger
   */
<span class="fc" id="L76">  private static final WaarpLogger logger =</span>
<span class="fc" id="L77">      WaarpLoggerFactory.getLogger(ClientRunner.class);</span>

  private static final ConcurrentHashMap&lt;String, Integer&gt;
<span class="fc" id="L80">      taskRunnerRetryHashMap = new ConcurrentHashMap&lt;String, Integer&gt;();</span>

<span class="fc" id="L82">  private static RecvThroughHandler staticRecvHandlerJunit = null;</span>

  public static ConcurrentLinkedQueue&lt;ClientRunner&gt; activeRunners;

  private final NetworkTransaction networkTransaction;

  private final DbTaskRunner taskRunner;

  private final R66Future futureRequest;

<span class="fc" id="L92">  private RecvThroughHandler handler = null;</span>

  private boolean isSendThroughMode;

  private LocalChannelReference localChannelReference;

  private final String nameTask;

<span class="fc" id="L100">  private boolean limitRetryConnection = true;</span>

  public static void setRecvHandlerJunit(final RecvThroughHandler handler) {
<span class="nc" id="L103">    staticRecvHandlerJunit = handler;</span>
<span class="nc" id="L104">  }</span>

  public static boolean isRecvHandlerJunit() {
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">    return staticRecvHandlerJunit != null;</span>
  }

  public ClientRunner(final NetworkTransaction networkTransaction,
                      final DbTaskRunner taskRunner,
<span class="fc" id="L112">                      final R66Future futureRequest) {</span>
<span class="fc" id="L113">    this.networkTransaction = networkTransaction;</span>
<span class="fc" id="L114">    this.taskRunner = taskRunner;</span>
<span class="fc" id="L115">    this.futureRequest = futureRequest;</span>
<span class="fc" id="L116">    setDaemon(true);</span>
<span class="fc" id="L117">    nameTask = &quot;Client_Runner_&quot; + taskRunner.getKey();</span>
<span class="fc" id="L118">    setName(nameTask);</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">    if (staticRecvHandlerJunit != null) {</span>
<span class="nc" id="L120">      this.handler = staticRecvHandlerJunit;</span>
    }
<span class="fc" id="L122">  }</span>

  public static String hashStatus() {
<span class="nc" id="L125">    return &quot;ClientRunner: [taskRunnerRetryHashMap: &quot; +</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">           taskRunnerRetryHashMap.size() + &quot; activeRunners: &quot; +</span>
<span class="nc" id="L127">           (activeRunners != null? activeRunners.size() :</span>
<span class="nc" id="L128">               Configuration.configuration.getInternalRunner()</span>
<span class="nc" id="L129">                                          .nbInternalRunner()) + &quot;] &quot;;</span>
  }

  /**
   * @return the networkTransaction
   */
  public final NetworkTransaction getNetworkTransaction() {
<span class="nc" id="L136">    return networkTransaction;</span>
  }

  /**
   * @return the taskRunner
   */
  public final DbTaskRunner getTaskRunner() {
<span class="nc" id="L143">    return taskRunner;</span>
  }

  /**
   * @return the localChannelReference
   */
  public final LocalChannelReference getLocalChannelReference() {
<span class="fc" id="L150">    return localChannelReference;</span>
  }

  @Override
  public void run() {
<span class="pc bpc" id="L155" title="2 of 4 branches missed.">    if (Configuration.configuration.isShutdown() || Thread.interrupted()) {</span>
<span class="nc" id="L156">      taskRunner.changeUpdatedInfo(UpdatedInfo.TOSUBMIT);</span>
<span class="nc" id="L157">      taskRunner.forceSaveStatus();</span>
<span class="nc" id="L158">      return;</span>
    }
<span class="fc" id="L160">    boolean status = false;</span>
    try {
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">      if (activeRunners != null) {</span>
<span class="nc" id="L163">        activeRunners.add(this);</span>
      }
      // fix for SelfRequest
<span class="fc bfc" id="L166" title="All 2 branches covered.">      if (taskRunner.isSelfRequest()) {</span>
<span class="fc" id="L167">        taskRunner.setSenderByRequestToValidate(false);</span>
      }
      // Try to check if file still exists in send not self not through mode
<span class="fc bfc" id="L170" title="All 4 branches covered.">      if (taskRunner.isSender() &amp;&amp; !taskRunner.isSelfRequest() &amp;&amp;</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">          !taskRunner.isSendThrough()) {</span>
        try {
<span class="fc" id="L173">          final R66Session session = new R66Session(false);</span>
<span class="fc" id="L174">          session.setReady(true);</span>
<span class="fc" id="L175">          final boolean ssl = Configuration.configuration.isUseSSL();</span>
<span class="fc" id="L176">          session.getAuth().specialNoSessionAuth(ssl,</span>
<span class="fc" id="L177">                                                 Configuration.configuration.getHostId(</span>
                                                     ssl));
<span class="fc" id="L179">          final DbTaskRunner reloaded =</span>
<span class="fc" id="L180">              new DbTaskRunner(session, taskRunner.getRule(),</span>
<span class="fc" id="L181">                               taskRunner.getSpecialId(),</span>
<span class="fc" id="L182">                               taskRunner.getRequester(),</span>
<span class="fc" id="L183">                               taskRunner.getRequested());</span>
<span class="fc" id="L184">          reloaded.setSender(taskRunner.isSender());</span>
<span class="fc" id="L185">          session.setRunner(reloaded);</span>
<span class="fc" id="L186">          session.setBlockSize(reloaded.getBlocksize());</span>
<span class="fc" id="L187">          final File file = new File(reloaded.getFullFilePath());</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">          if (!file.isFile()) {</span>
<span class="nc" id="L189">            logger.warn(&quot;File not found: {}&quot;, file.getAbsolutePath());</span>
            // File does no more exist =&gt; error
<span class="nc" id="L191">            reloaded.changeUpdatedInfo(UpdatedInfo.INERROR);</span>
<span class="nc" id="L192">            reloaded.setErrorExecutionStatus(ErrorCode.FileNotFound);</span>
<span class="nc" id="L193">            logger.error(&quot;Runner Error: {} {}&quot;,</span>
<span class="nc" id="L194">                         ErrorCode.FileNotFound.getMesg(),</span>
<span class="nc" id="L195">                         taskRunner.toShortString());</span>
<span class="nc" id="L196">            reloaded.setErrorTask();</span>
<span class="nc" id="L197">            reloaded.update();</span>
<span class="nc" id="L198">            return;</span>
          }
<span class="fc" id="L200">          status = true;</span>
<span class="nc" id="L201">        } catch (final CommandAbstractException e) {</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">          if (Configuration.configuration.isShutdown()) {</span>
            // ignore since shutdown
<span class="nc" id="L204">            logger.warn(e.getMessage());</span>
          } else {
            // Wrong path? Ignore
<span class="nc" id="L207">            logger.warn(e);</span>
          }
<span class="nc" id="L209">        } catch (final OpenR66RunnerErrorException e) {</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">          if (Configuration.configuration.isShutdown()) {</span>
            // ignore since shutdown
<span class="nc" id="L212">            logger.warn(e.getMessage());</span>
          } else {
            // Wrong run error? Ignore
<span class="nc" id="L215">            logger.warn(e);</span>
          }
<span class="nc" id="L217">        } catch (final WaarpDatabaseException e) {</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">          if (Configuration.configuration.isShutdown()) {</span>
            // ignore since shutdown
<span class="nc" id="L220">            logger.warn(e.getMessage());</span>
          } else {
            // Wrong dbtask? Ignore
<span class="nc" id="L223">            logger.warn(e);</span>
          }
<span class="nc" id="L225">        } catch (final OpenR66ProtocolNoSslException e) {</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">          if (Configuration.configuration.isShutdown()) {</span>
            // ignore since shutdown
<span class="nc" id="L228">            logger.warn(e.getMessage());</span>
          } else {
            // Wrong ssl? Ignore
<span class="nc" id="L231">            logger.warn(e);</span>
          }
<span class="pc" id="L233">        }</span>
      } else {
<span class="fc" id="L235">        status = true;</span>
      }
<span class="pc bpc" id="L237" title="3 of 6 branches missed.">      if (Configuration.configuration.isShutdown() || Thread.interrupted() ||</span>
          !status) {
<span class="nc" id="L239">        taskRunner.changeUpdatedInfo(UpdatedInfo.TOSUBMIT);</span>
<span class="nc" id="L240">        taskRunner.forceSaveStatus();</span>
<span class="nc" id="L241">        return;</span>
      }
      final R66Future transfer;
      try {
<span class="fc" id="L245">        transfer = runTransfer();</span>
<span class="nc" id="L246">      } catch (final OpenR66RunnerErrorException e) {</span>
<span class="nc" id="L247">        logger.error(&quot;Runner Error: {} {}&quot;, e.getMessage(),</span>
<span class="nc" id="L248">                     taskRunner.toShortString());</span>
<span class="nc" id="L249">        return;</span>
<span class="fc" id="L250">      } catch (final OpenR66ProtocolNoConnectionException e) {</span>
<span class="fc" id="L251">        logger.error(&quot;No connection Error {}&quot;, e.getMessage());</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">        if (localChannelReference != null) {</span>
<span class="nc" id="L253">          localChannelReference.setErrorMessage(</span>
<span class="nc" id="L254">              ErrorCode.ConnectionImpossible.getMesg(),</span>
              ErrorCode.ConnectionImpossible);
        }
<span class="fc" id="L257">        taskRunner.setErrorTask();</span>
        try {
<span class="fc" id="L259">          taskRunner.forceSaveStatus();</span>
<span class="fc" id="L260">          taskRunner.run();</span>
<span class="fc" id="L261">          taskRunner.saveStatus();</span>
<span class="nc" id="L262">        } catch (final OpenR66RunnerErrorException e1) {</span>
<span class="nc" id="L263">          changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ConnectionImpossible,</span>
                            true);
<span class="fc" id="L265">        }</span>
<span class="fc" id="L266">        return;</span>
<span class="nc" id="L267">      } catch (final OpenR66ProtocolPacketException e) {</span>
<span class="nc" id="L268">        logger.error(&quot;Protocol Error&quot;, e);</span>
<span class="nc" id="L269">        return;</span>
<span class="fc" id="L270">      } catch (final OpenR66ProtocolNotYetConnectionException e) {</span>
<span class="fc" id="L271">        logger.warn(&quot;No connection warning {}&quot;, e.getMessage());</span>
<span class="fc" id="L272">        return;</span>
<span class="fc" id="L273">      }</span>
<span class="fc" id="L274">      final R66Result result = transfer.getResult();</span>
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">      if (result != null) {</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">        if (result.getCode() == ErrorCode.QueryAlreadyFinished) {</span>
<span class="nc" id="L277">          logger.warn(Messages.getString(TRANSFER_STATUS) +</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">                      (transfer.isSuccess()?</span>
<span class="nc" id="L279">                          Messages.getString(REQUEST_INFORMATION_SUCCESS) :</span>
<span class="nc" id="L280">                          Messages.getString(REQUEST_INFORMATION_FAILURE)) +</span>
<span class="nc" id="L281">                      &quot;     &quot; + ErrorCode.QueryAlreadyFinished.getMesg() + ':' +</span>
<span class="nc" id="L282">                      result.toString());</span>
        } else {
<span class="fc bfc" id="L284" title="All 2 branches covered.">          if (transfer.isSuccess()) {</span>
<span class="fc" id="L285">            logger.info(&quot;{}{}     {}&quot;, Messages.getString(TRANSFER_STATUS),</span>
<span class="fc" id="L286">                        Messages.getString(REQUEST_INFORMATION_SUCCESS),</span>
                        result);
          } else {
<span class="fc" id="L289">            logger.error(Messages.getString(TRANSFER_STATUS) +</span>
<span class="fc" id="L290">                         Messages.getString(REQUEST_INFORMATION_FAILURE) +</span>
<span class="fc" id="L291">                         &quot;     &quot; + result.toString());</span>
          }
        }
      } else {
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (transfer.isSuccess()) {</span>
<span class="nc" id="L296">          logger.warn(Messages.getString(TRANSFER_STATUS) +</span>
<span class="nc" id="L297">                      Messages.getString(REQUEST_INFORMATION_SUCCESS) +</span>
                      &quot;     no result&quot;);
        } else {
<span class="nc" id="L300">          logger.error(Messages.getString(TRANSFER_STATUS) +</span>
<span class="nc" id="L301">                       Messages.getString(REQUEST_INFORMATION_FAILURE) +</span>
                       &quot;     no result&quot;);
        }
      }
    } finally {
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">      if (activeRunners != null) {</span>
<span class="nc" id="L307">        activeRunners.remove(this);</span>
      }
<span class="fc" id="L309">      setName(&quot;Finished_&quot; + nameTask);</span>
    }
<span class="fc" id="L311">  }</span>

  /**
   * @param runner
   * @param limit
   *
   * @return True if the task was run less than limit, else False
   */
  public final boolean incrementTaskRunnerTry(final DbTaskRunner runner,
                                              final int limit) {
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">    if (!isLimitRetryConnection()) {</span>
<span class="nc" id="L322">      return true;</span>
    }
<span class="fc" id="L324">    final String key = runner.getKey();</span>
<span class="fc" id="L325">    Integer tries = taskRunnerRetryHashMap.get(key);</span>
<span class="fc" id="L326">    logger.debug(&quot;try to find integer: {}&quot;, tries);</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">    if (tries == null) {</span>
<span class="fc" id="L328">      tries = 1;</span>
    } else {
<span class="fc" id="L330">      tries += 1;</span>
    }
<span class="fc bfc" id="L332" title="All 2 branches covered.">    logger.debug(&quot;Check: {} vs {}: {}&quot;, tries, limit, limit &lt;= tries);</span>
<span class="pc bpc" id="L333" title="1 of 4 branches missed.">    if (limit &lt;= tries || Thread.interrupted()) {</span>
<span class="fc" id="L334">      taskRunnerRetryHashMap.remove(key);</span>
<span class="fc" id="L335">      return false;</span>
    } else {
<span class="fc" id="L337">      taskRunnerRetryHashMap.put(key, tries);</span>
<span class="fc" id="L338">      return true;</span>
    }
  }

  /**
   * True transfer run (can be called directly to enable exception outside any
   * executors)
   *
   * @return The R66Future of the transfer operation
   *
   * @throws OpenR66RunnerErrorException
   * @throws OpenR66ProtocolNoConnectionException
   * @throws OpenR66ProtocolPacketException
   * @throws OpenR66ProtocolNotYetConnectionException
   */
  public final R66Future runTransfer()
      throws OpenR66RunnerErrorException, OpenR66ProtocolNoConnectionException,
             OpenR66ProtocolPacketException,
             OpenR66ProtocolNotYetConnectionException {
<span class="fc" id="L357">    logger.debug(&quot;Start attempt Transfer&quot;);</span>
<span class="fc" id="L358">    localChannelReference = initRequest();</span>
<span class="fc" id="L359">    localChannelReference.getFutureValidRequest().awaitOrInterruptible(</span>
<span class="fc" id="L360">        Configuration.configuration.getTimeoutCon());</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">    if (localChannelReference.getFutureValidRequest().isSuccess()) {</span>
<span class="fc" id="L362">      return finishTransfer(localChannelReference);</span>
<span class="fc" id="L363">    } else if (</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">        localChannelReference.getFutureValidRequest().getResult() != null &amp;&amp;</span>
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">        localChannelReference.getFutureValidRequest().getResult().getCode() ==</span>
        ErrorCode.ServerOverloaded) {
<span class="nc" id="L367">      return tryAgainTransferOnOverloaded(true, localChannelReference);</span>
    } else {
<span class="fc" id="L369">      return finishTransfer(localChannelReference);</span>
    }
  }

  /**
   * In case an overloaded signal is returned by the requested
   *
   * @param retry if True, it will retry in case of overloaded remote
   *     server, else it just stops
   * @param localChannelReference
   *
   * @return The R66Future of the transfer operation
   *
   * @throws OpenR66RunnerErrorException
   * @throws OpenR66ProtocolNoConnectionException
   * @throws OpenR66ProtocolPacketException
   * @throws OpenR66ProtocolNotYetConnectionException
   */
  public final R66Future tryAgainTransferOnOverloaded(final boolean retry,
                                                      final LocalChannelReference localChannelReference)
      throws OpenR66RunnerErrorException, OpenR66ProtocolNoConnectionException,
             OpenR66ProtocolPacketException,
             OpenR66ProtocolNotYetConnectionException {
<span class="nc bnc" id="L392" title="All 2 branches missed.">    if (this.localChannelReference == null) {</span>
<span class="nc" id="L393">      this.localChannelReference = localChannelReference;</span>
    }
<span class="nc" id="L395">    final boolean incRetry =</span>
<span class="nc" id="L396">        incrementTaskRunnerTry(taskRunner, Configuration.RETRYNB);</span>
<span class="nc" id="L397">    logger.debug(&quot;tryAgainTransferOnOverloaded: {}:{}&quot;, retry, incRetry);</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">    switch (taskRunner.getUpdatedInfo()) {</span>
      case DONE:
      case INERROR:
      case INTERRUPTED:
<span class="nc" id="L402">        break;</span>
      default:
<span class="nc" id="L404">        changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ServerOverloaded,</span>
                          true);
    }
    // redo if possible
<span class="nc bnc" id="L408" title="All 4 branches missed.">    if (retry &amp;&amp; incRetry) {</span>
      try {
<span class="nc" id="L410">        Thread.sleep(Configuration.configuration.getConstraintLimitHandler()</span>
<span class="nc" id="L411">                                                .getSleepTime());</span>
<span class="nc" id="L412">      } catch (final InterruptedException e) {//NOSONAR</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">        if (localChannelReference == null) {</span>
<span class="nc" id="L414">          taskRunner.setLocalChannelReference(new LocalChannelReference());</span>
        }
<span class="nc" id="L416">        taskRunner.getLocalChannelReference()</span>
<span class="nc" id="L417">                  .setErrorMessage(ErrorCode.ConnectionImpossible.getMesg(),</span>
                                   ErrorCode.ConnectionImpossible);
<span class="nc" id="L419">        taskRunner.setErrorTask();</span>
<span class="nc" id="L420">        taskRunner.run();</span>
<span class="nc" id="L421">        taskRunner.saveStatus();</span>
<span class="nc" id="L422">        throw new OpenR66ProtocolNoConnectionException(</span>
            &quot;End of retry on ServerOverloaded due to interruption&quot;);
<span class="nc" id="L424">      }</span>
<span class="nc" id="L425">      return runTransfer();</span>
    } else {
<span class="nc bnc" id="L427" title="All 2 branches missed.">      if (localChannelReference == null) {</span>
<span class="nc" id="L428">        taskRunner.setLocalChannelReference(new LocalChannelReference());</span>
      }
<span class="nc" id="L430">      taskRunner.getLocalChannelReference()</span>
<span class="nc" id="L431">                .setErrorMessage(ErrorCode.ConnectionImpossible.getMesg(),</span>
                                 ErrorCode.ConnectionImpossible);
<span class="nc" id="L433">      taskRunner.setErrorTask();</span>
<span class="nc" id="L434">      taskRunner.run();</span>
<span class="nc" id="L435">      taskRunner.saveStatus();</span>
<span class="nc" id="L436">      throw new OpenR66ProtocolNoConnectionException(</span>
          &quot;End of retry on ServerOverloaded&quot;);
    }
  }

  /**
   * Finish the transfer (called at the end of runTransfer)
   *
   * @param localChannelReference
   *
   * @return The R66Future of the transfer operation
   */
  public final R66Future finishTransfer(
      final LocalChannelReference localChannelReference) {
<span class="fc bfc" id="L450" title="All 2 branches covered.">    if (this.localChannelReference == null) {</span>
<span class="fc" id="L451">      this.localChannelReference = localChannelReference;</span>
    }
<span class="fc" id="L453">    final R66Future transfer = localChannelReference.getFutureRequest();</span>
<span class="fc" id="L454">    transfer.awaitOrInterruptible();</span>
<span class="fc" id="L455">    taskRunnerRetryHashMap.remove(taskRunner.getKey());</span>
<span class="fc" id="L456">    logger.info(&quot;Request done with {}&quot;,</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">                transfer.isSuccess()? &quot;success&quot; : &quot;error&quot;);</span>
<span class="fc" id="L458">    localChannelReference.close();</span>
    // now reload TaskRunner if it still exists (light client can forget it)
<span class="fc" id="L460">    final boolean isSender = taskRunner.isSender();</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">    if (transfer.isSuccess()) {</span>
      try {
<span class="fc" id="L463">        taskRunner.select();</span>
<span class="nc" id="L464">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L465">        logger.debug(&quot;Not a problem but cannot find at the end the task&quot;, e);</span>
<span class="nc" id="L466">        taskRunner.setFrom(transfer.getRunner());</span>
<span class="fc" id="L467">      }</span>
<span class="fc" id="L468">      taskRunner.setSender(isSender);</span>
<span class="fc" id="L469">      changeUpdatedInfo(UpdatedInfo.DONE, ErrorCode.CompleteOk, false);</span>
    } else {
      try {
<span class="fc" id="L472">        taskRunner.select();</span>
<span class="nc" id="L473">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L474">        logger.debug(&quot;Not a problem but cannot find at the end the task&quot;);</span>
<span class="nc" id="L475">        taskRunner.setFrom(transfer.getRunner());</span>
<span class="fc" id="L476">      }</span>
<span class="fc" id="L477">      taskRunner.setSender(isSender);</span>
      // Case when we were interrupted
<span class="fc bfc" id="L479" title="All 2 branches covered.">      if (transfer.getResult() == null) {</span>
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">        switch (taskRunner.getUpdatedInfo()) {</span>
          case DONE:
<span class="nc" id="L482">            final R66Result ok =</span>
                new R66Result(null, true, ErrorCode.CompleteOk, taskRunner);
<span class="nc" id="L484">            transfer.setResult(ok);</span>
<span class="nc" id="L485">            transfer.setSuccess();</span>
<span class="nc" id="L486">            changeUpdatedInfo(UpdatedInfo.DONE, ErrorCode.CompleteOk, false);</span>
<span class="nc" id="L487">            break;</span>
          case INERROR:
          case INTERRUPTED:
          default:
<span class="fc" id="L491">            final R66Result error =</span>
                new R66Result(null, true, ErrorCode.Internal, taskRunner);
<span class="fc" id="L493">            transfer.setResult(error);</span>
<span class="fc" id="L494">            transfer.cancel();</span>
<span class="fc" id="L495">            changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.Internal, false);</span>
        }
<span class="fc" id="L497">        return transfer;</span>
      }
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">      if (transfer.getResult().getCode() == ErrorCode.QueryAlreadyFinished) {</span>
        // check if post task to execute
<span class="nc" id="L501">        logger.warn(&quot;WARN QueryAlreadyFinished:     &quot; + transfer + &quot;     &quot; +</span>
<span class="nc" id="L502">                    taskRunner.toShortString());</span>
        try {
<span class="nc" id="L504">          TransferUtils.finalizeTaskWithNoSession(taskRunner,</span>
                                                  localChannelReference);
<span class="nc" id="L506">        } catch (final OpenR66RunnerErrorException e) {</span>
<span class="nc" id="L507">          taskRunner.changeUpdatedInfo(UpdatedInfo.INERROR);</span>
<span class="nc" id="L508">          taskRunner.forceSaveStatus();</span>
<span class="nc" id="L509">        }</span>
      } else {
<span class="fc bfc" id="L511" title="All 2 branches covered.">        switch (taskRunner.getUpdatedInfo()) {</span>
          case DONE:
          case INERROR:
          case INTERRUPTED:
          case TOSUBMIT:
<span class="fc" id="L516">            break;</span>
          default:
<span class="fc" id="L518">            changeUpdatedInfo(UpdatedInfo.INERROR,</span>
<span class="fc" id="L519">                              transfer.getResult().getCode(), false);</span>
        }
      }
    }
<span class="fc" id="L523">    return transfer;</span>
  }

  /**
   * Initialize the request
   *
   * @return the localChannelReference holding the transfer request
   *
   * @throws OpenR66ProtocolNoConnectionException
   * @throws OpenR66ProtocolPacketException
   * @throws OpenR66ProtocolNotYetConnectionException
   */
  public final LocalChannelReference initRequest()
      throws OpenR66ProtocolNoConnectionException,
             OpenR66ProtocolPacketException,
             OpenR66ProtocolNotYetConnectionException {
<span class="fc" id="L539">    changeUpdatedInfo(UpdatedInfo.RUNNING, ErrorCode.Running, true);</span>
<span class="fc" id="L540">    final long id = taskRunner.getSpecialId();</span>
    final String tid;
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">    if (id == DbConstantR66.ILLEGALVALUE) {</span>
<span class="nc" id="L543">      tid = &quot;Runner_&quot; + taskRunner.getRuleId() + '_' + taskRunner.getMode() +</span>
            &quot;_NEWTRANSFER&quot;;
    } else {
<span class="fc" id="L546">      tid = &quot;Runner_&quot; + taskRunner.getRuleId() + '_' + taskRunner.getMode() +</span>
            '_' + id;
    }
<span class="fc" id="L549">    setName(tid);</span>
<span class="fc" id="L550">    logger.debug(&quot;Will run {}&quot;, taskRunner);</span>
<span class="fc" id="L551">    boolean restartPost = false;</span>
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">    if (taskRunner.getGloballaststep() == TASKSTEP.POSTTASK.ordinal()) {</span>
      // Send a validation to requested
<span class="nc bnc" id="L554" title="All 2 branches missed.">      if (!taskRunner.isRequestOnRequested()) {</span>
        // restart
<span class="nc" id="L556">        restartPost = true;</span>
      }
    }
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">    if (taskRunner.isRequestOnRequested()) {</span>
      // Don't have to restart a task for itself (or should use requester)
<span class="nc" id="L561">      logger.warn(&quot;Requested host cannot initiate itself the request&quot;);</span>
<span class="nc" id="L562">      changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.LoopSelfRequestedHost,</span>
                        true);
<span class="nc" id="L564">      throw new OpenR66ProtocolNoConnectionException(</span>
          &quot;Requested host cannot initiate itself the request&quot;);
    }
    final DbHostAuth host;
    try {
<span class="fc" id="L569">      host = new DbHostAuth(taskRunner.getRequested());</span>
<span class="nc" id="L570">    } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L571">      logger.error(</span>
<span class="nc" id="L572">          &quot;Requested host cannot be found: &quot; + taskRunner.getRequested());</span>
<span class="nc" id="L573">      changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.NotKnownHost, true);</span>
<span class="nc" id="L574">      throw new OpenR66ProtocolNoConnectionException(</span>
<span class="nc" id="L575">          &quot;Requested host cannot be found &quot; + taskRunner.getRequested());</span>
<span class="fc" id="L576">    }</span>
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">    if (host.isClient()) {</span>
<span class="nc" id="L578">      logger.warn(&quot;Cannot initiate a connection with a client: {}&quot;, host);</span>
<span class="nc" id="L579">      changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ConnectionImpossible,</span>
                        true);
<span class="nc" id="L581">      throw new OpenR66ProtocolNoConnectionException(</span>
          &quot;Cannot connect to client &quot; + host);
    }
<span class="fc" id="L584">    final SocketAddress socketAddress = host.getSocketAddress();</span>
<span class="fc" id="L585">    final boolean isSSL = host.isSsl();</span>

    final LocalChannelReference localChannelReferenceTemp;
    try {
<span class="fc" id="L589">      localChannelReferenceTemp =</span>
<span class="fc" id="L590">          networkTransaction.createConnectionWithRetryWithAuthenticationException(</span>
              socketAddress, isSSL, futureRequest);
<span class="fc" id="L592">    } catch (final OpenR66ProtocolNotAuthenticatedException e1) {</span>
<span class="fc" id="L593">      changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.BadAuthent, true);</span>
<span class="fc" id="L594">      taskRunner.setLocalChannelReference(new LocalChannelReference());</span>
<span class="fc" id="L595">      throw new OpenR66ProtocolNoConnectionException(</span>
          CANNOT_CONNECT_TO_SERVER + host +
          &quot; cannot be authenticated so stop retry here&quot;, e1);
<span class="fc" id="L598">    }</span>
<span class="fc" id="L599">    taskRunner.setLocalChannelReference(localChannelReferenceTemp);</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">    if (localChannelReferenceTemp == null) {</span>
      // propose to redo
      String retry;
<span class="fc bfc" id="L603" title="All 2 branches covered.">      if (incrementTaskRunnerTry(taskRunner, Configuration.RETRYNB)) {</span>

<span class="fc" id="L605">        logger.debug(&quot;Will retry since Cannot connect to {}&quot;, host);</span>
<span class="fc" id="L606">        retry = &quot; but will retry&quot;;</span>
        // now wait
        try {
<span class="fc" id="L609">          Thread.sleep(Configuration.configuration.getDelayRetry());</span>
<span class="nc" id="L610">        } catch (final InterruptedException e) {//NOSONAR</span>
<span class="nc" id="L611">          SysErrLogger.FAKE_LOGGER.ignoreLog(e);</span>
<span class="nc" id="L612">          logger.info(</span>
              &quot;Will not retry since an interruption occurs while connection to {}&quot;,
              host);
<span class="nc" id="L615">          retry = &quot; and retries gets an interruption so stop here&quot;;</span>
<span class="nc" id="L616">          changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ConnectionImpossible,</span>
                            true);
<span class="nc" id="L618">          taskRunner.setLocalChannelReference(new LocalChannelReference());</span>
<span class="nc" id="L619">          throw new OpenR66ProtocolNoConnectionException(</span>
              CANNOT_CONNECT_TO_SERVER + host + retry);
<span class="fc" id="L621">        }</span>
<span class="fc" id="L622">        changeUpdatedInfo(UpdatedInfo.TOSUBMIT, ErrorCode.ConnectionImpossible,</span>
                          true);
<span class="fc" id="L624">        throw new OpenR66ProtocolNotYetConnectionException(</span>
            CANNOT_CONNECT_TO_SERVER + host + retry);
      } else {
<span class="fc" id="L627">        logger.info(</span>
            &quot;Will not retry since limit of connection attemtps is reached for {}&quot;,
            host);
<span class="fc" id="L630">        retry = &quot; and retries reach step limit so stop here&quot;;</span>
<span class="fc" id="L631">        changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ConnectionImpossible,</span>
                          true);
<span class="fc" id="L633">        taskRunner.setLocalChannelReference(new LocalChannelReference());</span>
<span class="fc" id="L634">        throw new OpenR66ProtocolNoConnectionException(</span>
            CANNOT_CONNECT_TO_SERVER + host + retry);
      }
    }
<span class="fc bfc" id="L638" title="All 2 branches covered.">    if (handler != null) {</span>
<span class="fc" id="L639">      localChannelReferenceTemp.setRecvThroughHandler(handler);</span>
    }
<span class="fc" id="L641">    localChannelReferenceTemp.setSendThroughMode(isSendThroughMode);</span>
<span class="pc bpc" id="L642" title="1 of 2 branches missed.">    if (restartPost) {</span>
<span class="nc" id="L643">      final RequestPacket request = taskRunner.getRequest();</span>
<span class="nc" id="L644">      logger.debug(&quot;Will send request {} &quot;, request);</span>
<span class="nc" id="L645">      localChannelReferenceTemp.setClientRunner(this);</span>
<span class="nc" id="L646">      localChannelReferenceTemp.sessionNewState(R66FiniteDualStates.REQUESTR);</span>
      try {
<span class="nc" id="L648">        ChannelUtils.writeAbstractLocalPacket(localChannelReferenceTemp,</span>
                                              request, false);
<span class="nc" id="L650">      } catch (final OpenR66ProtocolPacketException e) {</span>
        // propose to redo
<span class="nc" id="L652">        logger.warn(&quot;Cannot transfer request to &quot; + host);</span>
<span class="nc" id="L653">        changeUpdatedInfo(UpdatedInfo.INTERRUPTED, ErrorCode.Internal, true);</span>
<span class="nc" id="L654">        localChannelReferenceTemp.close();</span>
<span class="nc" id="L655">        throw e;</span>
<span class="nc" id="L656">      }</span>
<span class="nc" id="L657">      logger.debug(&quot;Wait for request to {}&quot;, host);</span>
<span class="nc" id="L658">      return localChannelReferenceTemp;</span>
    }
    // If Requester is NOT Sender, and if TransferTask then decrease now if
    // possible the rank
<span class="fc bfc" id="L662" title="All 2 branches covered.">    if (!taskRunner.isSender() &amp;&amp;</span>
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">        taskRunner.getGloballaststep() == TASKSTEP.TRANSFERTASK.ordinal()) {</span>
<span class="nc" id="L664">      logger.debug(</span>
          &quot;Requester is not Sender so decrease if possible the rank {}&quot;,
          taskRunner);
<span class="nc" id="L667">      taskRunner.restartRank();</span>
<span class="nc" id="L668">      taskRunner.forceSaveStatus();</span>
<span class="nc" id="L669">      logger.info(&quot;Requester is not Sender so new rank is {} {}&quot;,</span>
<span class="nc" id="L670">                  taskRunner.getRank(), taskRunner);</span>
    }
<span class="fc" id="L672">    final RequestPacket request = taskRunner.getRequest();</span>
<span class="fc" id="L673">    request.setLimit(</span>
<span class="fc" id="L674">        localChannelReferenceTemp.getChannelLimit(taskRunner.isSender()));</span>
<span class="fc" id="L675">    localChannelReferenceTemp.setClientRunner(this);</span>
<span class="fc" id="L676">    logger.debug(&quot;Will send request {} {}&quot;, request, localChannelReferenceTemp);</span>
<span class="fc" id="L677">    localChannelReferenceTemp.sessionNewState(R66FiniteDualStates.REQUESTR);</span>
    try {
<span class="fc" id="L679">      ChannelUtils.writeAbstractLocalPacket(localChannelReferenceTemp, request,</span>
                                            false);
<span class="nc" id="L681">    } catch (final OpenR66ProtocolPacketException e) {</span>
      // propose to redo
<span class="nc" id="L683">      logger.warn(&quot;Cannot transfer request to &quot; + host);</span>
<span class="nc" id="L684">      changeUpdatedInfo(UpdatedInfo.INTERRUPTED, ErrorCode.Internal, true);</span>
<span class="nc" id="L685">      localChannelReferenceTemp.close();</span>
<span class="nc" id="L686">      throw e;</span>
<span class="fc" id="L687">    }</span>
<span class="fc" id="L688">    logger.debug(&quot;Wait for request to {} {} {}&quot;, host,</span>
                 localChannelReferenceTemp, request);
<span class="fc" id="L690">    return localChannelReferenceTemp;</span>
  }

  /**
   * Change the UpdatedInfo of the current runner
   *
   * @param info
   */
  public final void changeUpdatedInfo(final AbstractDbData.UpdatedInfo info,
                                      final ErrorCode code,
                                      final boolean force) {
<span class="fc" id="L701">    taskRunner.changeUpdatedInfo(info);</span>
<span class="fc" id="L702">    taskRunner.setErrorExecutionStatus(code);</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">    if (force) {</span>
<span class="fc" id="L704">      taskRunner.forceSaveStatus();</span>
    } else {
      try {
<span class="fc" id="L707">        taskRunner.saveStatus();</span>
<span class="nc" id="L708">      } catch (final OpenR66RunnerErrorException ignored) {</span>
        // nothing
<span class="fc" id="L710">      }</span>
    }
<span class="fc" id="L712">  }</span>

  /**
   * @param handler the handler to set
   */
  public final void setRecvThroughHandler(final RecvThroughHandler handler) {
<span class="fc" id="L718">    this.handler = handler;</span>
<span class="fc" id="L719">  }</span>

  public final void setSendThroughMode() {
<span class="fc" id="L722">    isSendThroughMode = true;</span>
<span class="fc" id="L723">  }</span>

  public final boolean getSendThroughMode() {
<span class="nc" id="L726">    return isSendThroughMode;</span>
  }

  public final boolean isLimitRetryConnection() {
<span class="fc" id="L730">    return limitRetryConnection;</span>
  }

  public final void setLimitRetryConnection(
      final boolean limitRetryConnection) {
<span class="fc" id="L735">    this.limitRetryConnection = limitRetryConnection;</span>
<span class="fc" id="L736">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>