<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>R66Session.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Extensions for JRE 8 and greater</a> &gt; <a href="../index.html" class="el_bundle">WaarpR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.context</a> &gt; <span class="el_source">R66Session.java</span></div><h1>R66Session.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.openr66.context;

import org.waarp.common.command.exception.CommandAbstractException;
import org.waarp.common.database.data.AbstractDbData.UpdatedInfo;
import org.waarp.common.digest.FilesystemBasedDigest;
import org.waarp.common.exception.IllegalFiniteStateException;
import org.waarp.common.exception.NoRestartException;
import org.waarp.common.file.SessionInterface;
import org.waarp.common.file.filesystembased.FilesystemBasedFileParameterImpl;
import org.waarp.common.logging.SysErrLogger;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.state.MachineState;
import org.waarp.compress.WaarpZstdCodec;
import org.waarp.openr66.context.authentication.R66Auth;
import org.waarp.openr66.context.filesystem.R66Dir;
import org.waarp.openr66.context.filesystem.R66File;
import org.waarp.openr66.context.filesystem.R66Restart;
import org.waarp.openr66.context.task.exception.OpenR66RunnerErrorException;
import org.waarp.openr66.database.data.DbTaskRunner;
import org.waarp.openr66.database.data.DbTaskRunner.TASKSTEP;
import org.waarp.openr66.protocol.configuration.Configuration;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolSystemException;
import org.waarp.openr66.protocol.localhandler.LocalChannelReference;
import org.waarp.openr66.protocol.localhandler.packet.RequestPacket;
import org.waarp.openr66.protocol.localhandler.packet.compression.ZstdCompressionCodecDataPacket;
import org.waarp.openr66.protocol.utils.FileUtils;

import java.io.File;
import java.lang.ref.SoftReference;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.security.NoSuchAlgorithmException;
import java.util.HashMap;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * The global object session in OpenR66, a session by local channel
 */
public class R66Session implements SessionInterface {
  /**
   * Internal Logger
   */
<span class="fc" id="L63">  private static final WaarpLogger logger =</span>
<span class="fc" id="L64">      WaarpLoggerFactory.getLogger(R66Session.class);</span>
  private static final String FILE_IS_IN_THROUGH_MODE =
      &quot;File is in through mode: {}&quot;;
  private static final String FILE_CANNOT_BE_WRITE = &quot;File cannot be write&quot;;

  /**
   * Global Codec for packet compression
   */
<span class="fc" id="L72">  private static final ZstdCompressionCodecDataPacket codec =</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">      Configuration.configuration.isCompressionAvailable()?</span>
          new ZstdCompressionCodecDataPacket() : null;

  /**
   * Block size used during file transfer
   */
<span class="fc" id="L79">  private int blockSize = Configuration.configuration.getBlockSize();</span>
  /**
   * The local channel reference
   */
  private LocalChannelReference localChannelReference;
  /**
   * Authentication
   */
  private final R66Auth auth;
  /**
   * Remote Address
   */
  private SocketAddress raddress;
  /**
   * Local Address
   */
  private SocketAddress laddress;

  /**
   * Current directory
   */
  private final R66Dir dir;
  /**
   * Current file
   */
  private R66File file;
  /**
   * Does this session is Ready to serve a request
   */
  private boolean isReady;
  /**
   * Used to prevent deny of service
   */
<span class="fc" id="L112">  private final AtomicInteger numOfError = new AtomicInteger(0);</span>

  /**
   * Current Restart information
   */
  private final R66Restart restart;

  /**
   * DbTaskRunner
   */
  private DbTaskRunner runner;

<span class="fc" id="L124">  private String status = &quot;NoStatus&quot;;</span>

  /**
   * The Finite Machine State
   */
  private final MachineState&lt;R66FiniteDualStates&gt; state;
<span class="fc" id="L130">  private Exception traceState = null;</span>
  /**
   * Business Object if used
   */
  private R66BusinessInterface businessObject;
  /**
   * Extended protocol or not
   */
<span class="fc" id="L138">  private final boolean extendedProtocol =</span>
<span class="fc" id="L139">      Configuration.configuration.isExtendedProtocol();</span>

<span class="fc" id="L141">  private final HashMap&lt;String, R66Dir&gt; dirsFromSession =</span>
      new HashMap&lt;String, R66Dir&gt;();
<span class="fc" id="L143">  private static SoftReference&lt;byte[]&gt; reusableBufferStatic = null;</span>
<span class="fc" id="L144">  private static SoftReference&lt;byte[]&gt; reusableDataPacketBufferStatic = null;</span>
<span class="fc" id="L145">  private static SoftReference&lt;byte[]&gt; reusableCompressionBufferStatic = null;</span>
<span class="fc" id="L146">  private SoftReference&lt;byte[]&gt; reusableBuffer = null;</span>
<span class="fc" id="L147">  private SoftReference&lt;byte[]&gt; reusableDataPacketBuffer = null;</span>
<span class="fc" id="L148">  private SoftReference&lt;byte[]&gt; reusableCompressionBuffer = null;</span>
<span class="fc" id="L149">  private FilesystemBasedDigest digestBlock = null;</span>
  private boolean isSender;
  private boolean isCompressionEnabled;
<span class="fc" id="L152">  private int compressionMaxSize =</span>
<span class="fc" id="L153">      WaarpZstdCodec.getMaxCompressedSize(blockSize);</span>

  /**
   * @return the compression codec
   */
  public static ZstdCompressionCodecDataPacket getCodec() {
<span class="fc" id="L159">    return codec;</span>
  }

  /**
   * Create the session
   */
<span class="fc" id="L165">  public R66Session() {</span>
<span class="fc" id="L166">    isReady = false;</span>
<span class="fc" id="L167">    auth = new R66Auth(this);</span>
<span class="fc" id="L168">    dir = new R66Dir(this);</span>
<span class="fc" id="L169">    restart = new R66Restart(this);</span>
<span class="fc" id="L170">    state = R66FiniteDualStates.newSessionMachineState();</span>
<span class="fc" id="L171">    isCompressionEnabled = Configuration.configuration.isCompressionAvailable();</span>
<span class="fc" id="L172">    synchronized (logger) {</span>
<span class="fc" id="L173">      reusableBuffer = reusableBufferStatic;</span>
<span class="fc" id="L174">      reusableBufferStatic = null;</span>
<span class="fc" id="L175">      reusableDataPacketBuffer = reusableDataPacketBufferStatic;</span>
<span class="fc" id="L176">      reusableDataPacketBufferStatic = null;</span>
<span class="fc" id="L177">    }</span>
<span class="fc" id="L178">  }</span>

  /**
   * Create the session without Buffers
   */
<span class="fc" id="L183">  public R66Session(final boolean noBuffer) {</span>
<span class="fc" id="L184">    isReady = false;</span>
<span class="fc" id="L185">    auth = new R66Auth(this);</span>
<span class="fc" id="L186">    dir = new R66Dir(this);</span>
<span class="fc" id="L187">    restart = new R66Restart(this);</span>
<span class="fc" id="L188">    state = R66FiniteDualStates.newSessionMachineState();</span>
<span class="fc" id="L189">    isCompressionEnabled = Configuration.configuration.isCompressionAvailable();</span>
<span class="fc" id="L190">  }</span>

  /**
   * @return extendedProtocol
   */
  public final boolean getExtendedProtocol() {
<span class="fc" id="L196">    return extendedProtocol;</span>
  }

  /**
   * @return the businessObject
   */
  public final R66BusinessInterface getBusinessObject() {
<span class="fc" id="L203">    return businessObject;</span>
  }

  /**
   * @param businessObject the businessObject to set
   */
  public final void setBusinessObject(
      final R66BusinessInterface businessObject) {
<span class="fc" id="L211">    this.businessObject = businessObject;</span>
<span class="fc" id="L212">  }</span>

  /**
   * Propose a new State
   *
   * @param desiredstate
   *
   * @throws IllegalFiniteStateException if the new status if not ok
   */
  public final void newState(final R66FiniteDualStates desiredstate) {
    try {
<span class="fc" id="L223">      state.setCurrent(desiredstate);</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">      if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L225">        traceState = new Exception(&quot;Trace for debugging&quot;);</span>
      }
<span class="fc" id="L227">    } catch (final IllegalFiniteStateException e) {</span>
<span class="fc" id="L228">      logger.warn(&quot;Should not changed of State: {} {}&quot;, this, e.getMessage(),</span>
                  e);
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">      if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L231">        logger.warn(&quot;Previous condition of state: {}&quot;, this, traceState);</span>
<span class="nc" id="L232">        traceState = new Exception(&quot;Trace for debugging&quot;);</span>
      }
<span class="fc" id="L234">      state.setDryCurrent(desiredstate);</span>
<span class="fc" id="L235">    }</span>
<span class="fc" id="L236">  }</span>

  public final void setErrorState() {
    try {
<span class="nc" id="L240">      state.setCurrent(R66FiniteDualStates.ERROR);</span>
<span class="nc" id="L241">    } catch (final IllegalFiniteStateException e) {</span>
<span class="nc" id="L242">      logger.error(&quot;Couldn't pass to error state. This should not happen&quot;);</span>
<span class="nc" id="L243">    }</span>
<span class="nc" id="L244">  }</span>

  /**
   * @return the current state in the finite state machine
   */
  public final R66FiniteDualStates getState() {
<span class="fc" id="L250">    return state.getCurrent();</span>
  }

  /**
   * Debugging purpose (trace)
   *
   * @param stat
   */
  public final void setStatus(final int stat) {
<span class="fc bfc" id="L259" title="All 2 branches covered.">    if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L260">      final StackTraceElement elt = Thread.currentThread().getStackTrace()[2];</span>
<span class="fc" id="L261">      status =</span>
<span class="fc" id="L262">          '(' + elt.getFileName() + ':' + elt.getLineNumber() + &quot;):&quot; + stat;</span>
<span class="fc" id="L263">    } else {</span>
<span class="fc" id="L264">      status = &quot;:&quot; + stat;</span>
    }
<span class="fc" id="L266">  }</span>

  @Override
  public final void clear() {
<span class="fc" id="L270">    partialClear();</span>
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">    if (dir != null) {</span>
<span class="fc" id="L272">      dir.clear();</span>
    }
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">    if (auth != null) {</span>
<span class="fc" id="L275">      auth.clear();</span>
    }
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">    if (runner != null) {</span>
<span class="nc" id="L278">      runner.clear();</span>
    }
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">    if (state != null) {</span>
      try {
<span class="fc" id="L282">        state.setCurrent(R66FiniteDualStates.CLOSEDCHANNEL);</span>
<span class="nc" id="L283">      } catch (final IllegalFiniteStateException ignored) {</span>
        // nothing
<span class="fc" id="L285">      }</span>
<span class="fc" id="L286">      R66FiniteDualStates.endSessionMachineSate(state);</span>
    }
<span class="fc" id="L288">  }</span>

  public final void partialClear() {
    // First check if a transfer was on going
<span class="fc bfc" id="L292" title="All 6 branches covered.">    if (runner != null &amp;&amp; !runner.isFinished() &amp;&amp; !runner.continueTransfer()) {</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">      if (localChannelReference != null) {</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">        if (!localChannelReference.getFutureRequest().isDone()) {</span>
<span class="fc" id="L295">          final R66Result result = new R66Result(</span>
              new OpenR66RunnerErrorException(&quot;Close before ending&quot;), this,
              true, ErrorCode.Disconnection,
              runner);// True since called from closed
<span class="fc" id="L299">          result.setRunner(runner);</span>
          try {
<span class="fc" id="L301">            setFinalizeTransfer(false, result);</span>
<span class="fc" id="L302">          } catch (final OpenR66RunnerErrorException ignored) {</span>
            // nothing
<span class="nc" id="L304">          } catch (final OpenR66ProtocolSystemException ignored) {</span>
            // nothing
<span class="fc" id="L306">          }</span>
        }
      }
    }
    // No clean of file since it can be used after channel is closed
<span class="fc" id="L311">    isReady = false;</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">    if (businessObject != null) {</span>
<span class="nc" id="L313">      businessObject.releaseResources(this);</span>
<span class="nc" id="L314">      businessObject = null;</span>
    }
<span class="fc" id="L316">    digestBlock = null;</span>
<span class="fc bfc" id="L317" title="All 4 branches covered.">    if (reusableBuffer != null &amp;&amp; reusableBufferStatic == null) {</span>
<span class="fc" id="L318">      reusableBufferStatic = reusableBuffer;</span>
    }
<span class="fc bfc" id="L320" title="All 4 branches covered.">    if (reusableDataPacketBuffer != null &amp;&amp;</span>
        reusableDataPacketBufferStatic == null) {
<span class="fc" id="L322">      reusableDataPacketBufferStatic = reusableDataPacketBuffer;</span>
    }
<span class="fc bfc" id="L324" title="All 4 branches covered.">    if (reusableCompressionBuffer != null &amp;&amp;</span>
        reusableCompressionBufferStatic == null) {
<span class="fc" id="L326">      reusableCompressionBufferStatic = reusableCompressionBuffer;</span>
    }
<span class="fc" id="L328">    reusableBuffer = null;</span>
<span class="fc" id="L329">    reusableDataPacketBuffer = null;</span>
<span class="fc" id="L330">    reusableCompressionBuffer = null;</span>
<span class="fc" id="L331">  }</span>

  @Override
  public final R66Auth getAuth() {
<span class="fc" id="L335">    return auth;</span>
  }

  @Override
  public final int getBlockSize() {
<span class="fc" id="L340">    return blockSize;</span>
  }

  /**
   * @param blocksize the blocksize to set
   */
  public final void setBlockSize(final int blocksize) {
<span class="fc" id="L347">    blockSize = blocksize;</span>
<span class="fc" id="L348">    compressionMaxSize = WaarpZstdCodec.getMaxCompressedSize(blockSize);</span>
<span class="fc" id="L349">  }</span>

  private SoftReference&lt;byte[]&gt; getBuffer(SoftReference&lt;byte[]&gt; softReference,
                                          final int length) {
<span class="fc bfc" id="L353" title="All 2 branches covered.">    if (softReference == null) {</span>
<span class="fc" id="L354">      softReference = new SoftReference&lt;byte[]&gt;(new byte[length]);</span>
<span class="fc" id="L355">      return softReference;</span>
    }
<span class="fc" id="L357">    final byte[] buffer = softReference.get();</span>
<span class="pc bpc" id="L358" title="1 of 4 branches missed.">    if (buffer != null &amp;&amp; buffer.length &gt;= length) {</span>
<span class="fc" id="L359">      return softReference;</span>
    }
<span class="fc" id="L361">    softReference.clear();</span>
<span class="fc" id="L362">    softReference = new SoftReference&lt;byte[]&gt;(new byte[length]);</span>
<span class="fc" id="L363">    return softReference;</span>
  }

  /**
   * @param length the target size
   *
   * @return the reusable buffer for sending per Session
   */
  public final byte[] getReusableBuffer(final int length) {
<span class="fc" id="L372">    reusableBuffer = getBuffer(reusableBuffer, length);</span>
<span class="fc" id="L373">    return reusableBuffer.get();</span>
  }

  /**
   * @param length the target size
   *
   * @return the reusable buffer for received DataPacket per Session
   */
  public final byte[] getReusableDataPacketBuffer(final int length) {
<span class="fc" id="L382">    reusableDataPacketBuffer = getBuffer(reusableDataPacketBuffer, length);</span>
<span class="fc" id="L383">    return reusableDataPacketBuffer.get();</span>
  }

  /**
   * @param length the original size
   *
   * @return the possible reusable compression buffer per Session
   */
  public final byte[] getSessionReusableCompressionBuffer(final int length) {
<span class="fc" id="L392">    reusableCompressionBuffer = getBuffer(reusableCompressionBuffer,</span>
<span class="fc" id="L393">                                          WaarpZstdCodec.getMaxCompressedSize(</span>
                                              length));
<span class="fc" id="L395">    return reusableCompressionBuffer.get();</span>
  }

  /**
   * @return True if compression is enabled in this session
   */
  public final boolean isCompressionEnabled() {
<span class="fc" id="L402">    return isCompressionEnabled;</span>
  }

  /**
   * @param compressionEnabled True if compression is enabled in this session
   */
  public final void setCompressionEnabled(final boolean compressionEnabled) {
<span class="fc" id="L409">    logger.debug(&quot;Compression enabled? {} =&gt; {}&quot;, isCompressionEnabled,</span>
<span class="fc" id="L410">                 compressionEnabled);</span>
<span class="fc" id="L411">    isCompressionEnabled = compressionEnabled;</span>
<span class="fc bfc" id="L412" title="All 4 branches covered.">    if (isCompressionEnabled &amp;&amp; reusableCompressionBuffer == null) {</span>
<span class="fc" id="L413">      synchronized (logger) {</span>
<span class="fc" id="L414">        reusableCompressionBuffer = reusableCompressionBufferStatic;</span>
<span class="fc" id="L415">        reusableCompressionBufferStatic = null;</span>
<span class="fc" id="L416">      }</span>
<span class="fc bfc" id="L417" title="All 4 branches covered.">    } else if (!isCompressionEnabled &amp;&amp; reusableCompressionBuffer != null) {</span>
<span class="fc" id="L418">      synchronized (logger) {</span>
<span class="fc" id="L419">        reusableDataPacketBufferStatic = reusableCompressionBuffer;</span>
<span class="fc" id="L420">        reusableCompressionBuffer = null;</span>
<span class="fc" id="L421">      }</span>
    }
<span class="fc" id="L423">  }</span>

  /**
   * @return the current max compression size according to block size
   */
  public final int getCompressionMaxSize() {
<span class="nc" id="L429">    return compressionMaxSize;</span>
  }

  /**
   * Initialize per block digest
   */
  public final void initializeDigest() {
<span class="pc bpc" id="L436" title="1 of 4 branches missed.">    if (digestBlock == null &amp;&amp; RequestPacket.isMD5Mode(getRunner().getMode())) {</span>
      try {
<span class="fc" id="L438">        digestBlock = new FilesystemBasedDigest(</span>
<span class="fc" id="L439">            localChannelReference.getPartner().getDigestAlgo());</span>
<span class="nc" id="L440">      } catch (final NoSuchAlgorithmException e) {</span>
<span class="nc" id="L441">        SysErrLogger.FAKE_LOGGER.ignoreLog(e);</span>
<span class="fc" id="L442">      }</span>
    }
<span class="fc" id="L444">  }</span>

  /**
   * @return the digest used per block
   */
  public final FilesystemBasedDigest getDigestBlock() {
<span class="fc" id="L450">    return digestBlock;</span>
  }

  @Override
  public final R66Dir getDir() {
<span class="fc" id="L455">    return dir;</span>
  }

  @Override
  public final FilesystemBasedFileParameterImpl getFileParameter() {
<span class="nc" id="L460">    return Configuration.getFileParameter();</span>
  }

  @Override
  public final R66Restart getRestart() {
<span class="nc" id="L465">    return restart;</span>
  }

  /**
   * @return True if the connection is currently authenticated
   */
  public final boolean isAuthenticated() {
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">    if (auth == null) {</span>
<span class="nc" id="L473">      return false;</span>
    }
<span class="fc" id="L475">    return auth.isIdentified();</span>
  }

  /**
   * @return True if the Channel is ready to accept transfer
   */
  public final boolean isReady() {
<span class="fc" id="L482">    return isReady;</span>
  }

  /**
   * @param isReady the isReady for transfer to set
   */
  public final void setReady(final boolean isReady) {
<span class="fc" id="L489">    this.isReady = isReady;</span>
<span class="fc" id="L490">  }</span>

  /**
   * @return the runner
   */
  public final DbTaskRunner getRunner() {
<span class="fc" id="L496">    return runner;</span>
  }

  /**
   * @param localChannelReference the localChannelReference to set
   */
  public final void setLocalChannelReference(
      final LocalChannelReference localChannelReference) {
<span class="fc" id="L504">    this.localChannelReference = localChannelReference;</span>
<span class="fc" id="L505">    this.localChannelReference.setSession(this);</span>
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">    if (this.localChannelReference.getNetworkChannel() != null) {</span>
<span class="fc" id="L507">      raddress = this.localChannelReference.getNetworkChannel().remoteAddress();</span>
<span class="fc" id="L508">      laddress = this.localChannelReference.getNetworkChannel().localAddress();</span>
    } else {
<span class="nc" id="L510">      raddress = laddress = new InetSocketAddress(0);</span>
    }
<span class="fc" id="L512">  }</span>

  /**
   * @return the remote SocketAddress
   */
  public final SocketAddress getRemoteAddress() {
<span class="fc" id="L518">    return raddress;</span>
  }

  /**
   * @return the local SocketAddress
   */
  public final SocketAddress getLocalAddress() {
<span class="fc" id="L525">    return laddress;</span>
  }

  /**
   * @return the localChannelReference
   */
  public final LocalChannelReference getLocalChannelReference() {
<span class="fc" id="L532">    return localChannelReference;</span>
  }

  /**
   * To be called in case of No Session not from a valid LocalChannelHandler
   *
   * @param runner
   * @param localChannelReference
   */
  public final void setNoSessionRunner(final DbTaskRunner runner,
                                       final LocalChannelReference localChannelReference) {
<span class="fc" id="L543">    this.runner = runner;</span>
    // Warning: the file is not correctly setup
<span class="fc" id="L545">    auth.specialNoSessionAuth(false, Configuration.configuration.getHostId());</span>
    try {
<span class="fc" id="L547">      file = (R66File) dir.setFile(this.runner.getFilename(), false);</span>
<span class="nc" id="L548">    } catch (final CommandAbstractException ignored) {</span>
      // nothing
<span class="fc" id="L550">    }</span>
<span class="fc" id="L551">    this.localChannelReference = localChannelReference;</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">    if (this.localChannelReference == null) {</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">      if (this.runner.getLocalChannelReference() != null) {</span>
<span class="nc" id="L554">        this.localChannelReference = this.runner.getLocalChannelReference();</span>
      } else {
<span class="fc" id="L556">        this.localChannelReference = new LocalChannelReference();</span>
      }
<span class="fc" id="L558">      this.localChannelReference.setErrorMessage(</span>
<span class="fc" id="L559">          this.runner.getErrorInfo().getMesg(), this.runner.getErrorInfo());</span>
    }
<span class="fc" id="L561">    runner.setLocalChannelReference(this.localChannelReference);</span>
<span class="fc" id="L562">    this.localChannelReference.setSession(this);</span>
<span class="fc" id="L563">  }</span>

  /**
   * Set the File from the runner before PRE operation are done
   *
   * @throws OpenR66RunnerErrorException
   */
  public final void setFileBeforePreRunner()
      throws OpenR66RunnerErrorException {
    // check first if the next step is the PRE task from beginning
    try {
<span class="fc" id="L574">      file = FileUtils.getFile(logger, this, runner.getOriginalFilename(),</span>
<span class="fc" id="L575">                               runner.isPreTaskStarting(), isSender,</span>
<span class="fc" id="L576">                               runner.isSendThrough(), file);</span>
<span class="fc" id="L577">    } catch (final OpenR66RunnerErrorException e) {</span>
<span class="fc" id="L578">      runner.setErrorExecutionStatus(ErrorCode.FileNotFound);</span>
<span class="fc" id="L579">      throw e;</span>
<span class="fc" id="L580">    }</span>
<span class="fc bfc" id="L581" title="All 4 branches covered.">    if (isSender &amp;&amp; !runner.isSendThrough()) {</span>
      // possibly resolved filename
      try {
<span class="fc" id="L584">        runner.setOriginalFilename(file.getFile());</span>
<span class="fc" id="L585">        runner.setFilename(file.getFile());</span>
<span class="fc" id="L586">        logger.debug(&quot;Old size: {} =&gt; {}&quot;, runner.getOriginalSize(),</span>
<span class="fc" id="L587">                     file.length());</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">        if (runner.getOriginalSize() &lt;= 0) {</span>
<span class="fc" id="L589">          final long originalSize = file.length();</span>
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">          if (originalSize &gt; 0) {</span>
<span class="fc" id="L591">            runner.setOriginalSize(originalSize);</span>
          }
        }
<span class="nc" id="L594">      } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L595">        throw new OpenR66RunnerErrorException(e);</span>
<span class="fc" id="L596">      }</span>
    }
<span class="fc" id="L598">  }</span>

  /**
   * Set the File from the runner once PRE operation are done, only for Receiver
   *
   * @param createFile When True, the file can be newly created if
   *     needed.
   *     If False, no new file will be
   *     created, thus having an Exception.
   *
   * @throws OpenR66RunnerErrorException
   * @throws CommandAbstractException only when new received created
   *     file
   *     cannot be created
   */
  public final void setFileAfterPreRunnerReceiver(final boolean createFile)
      throws OpenR66RunnerErrorException, CommandAbstractException {
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">    if (businessObject != null) {</span>
<span class="nc" id="L616">      businessObject.checkAtChangeFilename(this);</span>
    }
    // File should not exist except if restart
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">    if (runner.getRank() &gt; 0) {</span>
      // Filename should be get back from runner load from database
      try {
<span class="nc" id="L622">        file = (R66File) dir.setFile(runner.getFilename(), true);</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">        if (runner.isRecvThrough()) {</span>
          // no test on file since it does not really exist
<span class="nc" id="L625">          logger.debug(FILE_IS_IN_THROUGH_MODE, file);</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">        } else if (!file.canWrite()) {</span>
<span class="nc" id="L627">          throw new OpenR66RunnerErrorException(FILE_CANNOT_BE_WRITE);</span>
        }
<span class="nc" id="L629">      } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L630">        throw new OpenR66RunnerErrorException(e);</span>
<span class="nc" id="L631">      }</span>
    } else {
      // New FILENAME if necessary and store it
<span class="pc bpc" id="L634" title="1 of 2 branches missed.">      if (createFile) {</span>
<span class="fc" id="L635">        file = null;</span>
<span class="fc" id="L636">        String newfilename = runner.getOriginalFilename();</span>
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">        if (newfilename.charAt(1) == ':') {</span>
          // Windows path
<span class="nc" id="L639">          newfilename = newfilename.substring(2);</span>
        }
<span class="fc" id="L641">        newfilename = R66File.getBasename(newfilename);</span>
        try {
<span class="fc" id="L643">          file = dir.setUniqueFile(runner.getSpecialId(), newfilename);</span>
<span class="fc" id="L644">          runner.setFilename(file.getBasename());</span>
<span class="nc" id="L645">        } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L646">          runner.deleteTempFile();</span>
<span class="nc" id="L647">          throw e;</span>
<span class="fc" id="L648">        }</span>
        try {
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">          if (runner.isRecvThrough()) {</span>
            // no test on file since it does not really exist
<span class="nc" id="L652">            logger.debug(FILE_IS_IN_THROUGH_MODE, file);</span>
<span class="nc" id="L653">            runner.deleteTempFile();</span>
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">          } else if (!file.canWrite()) {</span>
<span class="nc" id="L655">            runner.deleteTempFile();</span>
<span class="nc" id="L656">            throw new OpenR66RunnerErrorException(FILE_CANNOT_BE_WRITE);</span>
          }
<span class="nc" id="L658">        } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L659">          runner.deleteTempFile();</span>
<span class="nc" id="L660">          throw new OpenR66RunnerErrorException(e);</span>
<span class="fc" id="L661">        }</span>
<span class="fc" id="L662">      } else {</span>
<span class="nc" id="L663">        throw new OpenR66RunnerErrorException(&quot;No file created&quot;);</span>
      }
    }
    // Store TRUEFILENAME
    try {
<span class="pc bpc" id="L668" title="1 of 2 branches missed.">      if (runner.isFileMoved()) {</span>
<span class="nc" id="L669">        runner.setFileMoved(file.getFile(), true);</span>
      } else {
<span class="fc" id="L671">        runner.setFilename(file.getFile());</span>
      }
<span class="nc" id="L673">    } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L674">      runner.deleteTempFile();</span>
<span class="nc" id="L675">      throw new OpenR66RunnerErrorException(e);</span>
<span class="fc" id="L676">    }</span>
<span class="fc" id="L677">  }</span>

  /**
   * Set the File from the runner once PRE operation are done
   *
   * @param createFile When True, the file can be newly created if
   *     needed.
   *     If False, no new file will be
   *     created, thus having an Exception.
   *
   * @throws OpenR66RunnerErrorException
   * @throws CommandAbstractException only when new received created
   *     file
   *     cannot be created
   */
  public final void setFileAfterPreRunner(final boolean createFile)
      throws OpenR66RunnerErrorException, CommandAbstractException {
<span class="pc bpc" id="L694" title="1 of 2 branches missed.">    if (businessObject != null) {</span>
<span class="nc" id="L695">      businessObject.checkAtChangeFilename(this);</span>
    }
    // Now create the associated file
<span class="pc bpc" id="L698" title="1 of 2 branches missed.">    if (isSender != runner.isSender()) {</span>
<span class="nc" id="L699">      logger.warn(&quot;Not same SenderSide {} {}&quot;, isSender, runner.isSender());</span>
    }
<span class="fc bfc" id="L701" title="All 2 branches covered.">    if (isSender) {</span>
      try {
<span class="pc bpc" id="L703" title="1 of 2 branches missed.">        if (file == null) {</span>
          try {
<span class="nc" id="L705">            file = (R66File) dir.setFile(runner.getFilename(), false);</span>
<span class="nc" id="L706">          } catch (final CommandAbstractException e) {</span>
            // file is not under normal base directory, so is external
            // File must already exist but can be using special code ('*?')
<span class="nc" id="L709">            file = dir.setFileNoCheck(runner.getFilename());</span>
<span class="nc" id="L710">          }</span>
        }
<span class="fc bfc" id="L712" title="All 2 branches covered.">        if (runner.isSendThrough()) {</span>
          // no test on file since it does not really exist
<span class="fc" id="L714">          logger.debug(FILE_IS_IN_THROUGH_MODE, file);</span>
<span class="pc bpc" id="L715" title="1 of 2 branches missed.">        } else if (!file.canRead()) {</span>
          // file is not under normal base directory, so is external
          // File must already exist but cannot used special code ('*?')
<span class="nc" id="L718">          final R66File newFile = new R66File(this, dir, runner.getFilename());</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">          if (!newFile.canRead()) {</span>
<span class="nc" id="L720">            runner.setErrorExecutionStatus(ErrorCode.FileNotFound);</span>
<span class="nc" id="L721">            throw new OpenR66RunnerErrorException(</span>
<span class="nc" id="L722">                &quot;File cannot be read: &quot; + file.getTrueFile().getAbsolutePath() +</span>
<span class="nc" id="L723">                &quot; to &quot; + newFile.getTrueFile().getAbsolutePath());</span>
          }
        }
<span class="nc" id="L726">      } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L727">        throw new OpenR66RunnerErrorException(e);</span>
<span class="fc" id="L728">      }</span>
    } else {
      // File should not exist except if restart
<span class="fc bfc" id="L731" title="All 2 branches covered.">      if (runner.getRank() &gt; 0) {</span>
        // Filename should be get back from runner load from database
        try {
<span class="fc" id="L734">          file = (R66File) dir.setFile(runner.getFilename(), true);</span>
<span class="pc bpc" id="L735" title="1 of 2 branches missed.">          if (runner.isRecvThrough()) {</span>
            // no test on file since it does not really exist
<span class="nc" id="L737">            logger.debug(FILE_IS_IN_THROUGH_MODE, file);</span>
<span class="pc bpc" id="L738" title="1 of 2 branches missed.">          } else if (!file.canWrite()) {</span>
<span class="nc" id="L739">            throw new OpenR66RunnerErrorException(FILE_CANNOT_BE_WRITE);</span>
          }
<span class="nc" id="L741">        } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L742">          throw new OpenR66RunnerErrorException(e);</span>
<span class="fc" id="L743">        }</span>
      } else {
        // New FILENAME if necessary and store it
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">        if (createFile) {</span>
<span class="fc" id="L747">          file = null;</span>
<span class="fc" id="L748">          String newfilename = runner.getOriginalFilename();</span>
<span class="pc bpc" id="L749" title="1 of 2 branches missed.">          if (newfilename.charAt(1) == ':') {</span>
            // Windows path
<span class="nc" id="L751">            newfilename = newfilename.substring(2);</span>
          }
<span class="fc" id="L753">          newfilename = R66File.getBasename(newfilename);</span>
          try {
<span class="fc" id="L755">            file = dir.setUniqueFile(runner.getSpecialId(), newfilename);</span>
<span class="fc" id="L756">            runner.setFilename(file.getBasename());</span>
<span class="nc" id="L757">          } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L758">            runner.deleteTempFile();</span>
<span class="nc" id="L759">            throw e;</span>
<span class="fc" id="L760">          }</span>
          try {
<span class="fc bfc" id="L762" title="All 2 branches covered.">            if (runner.isRecvThrough()) {</span>
              // no test on file since it does not really exist
<span class="fc" id="L764">              logger.debug(FILE_IS_IN_THROUGH_MODE, file);</span>
<span class="fc" id="L765">              runner.deleteTempFile();</span>
<span class="pc bpc" id="L766" title="1 of 2 branches missed.">            } else if (!file.canWrite()) {</span>
<span class="nc" id="L767">              runner.deleteTempFile();</span>
<span class="nc" id="L768">              throw new OpenR66RunnerErrorException(FILE_CANNOT_BE_WRITE);</span>
            }
<span class="nc" id="L770">          } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L771">            runner.deleteTempFile();</span>
<span class="nc" id="L772">            throw new OpenR66RunnerErrorException(e);</span>
<span class="fc" id="L773">          }</span>
<span class="fc" id="L774">        } else {</span>
<span class="nc" id="L775">          throw new OpenR66RunnerErrorException(&quot;No file created&quot;);</span>
        }
      }
    }
    // Store TRUEFILENAME
    try {
<span class="fc bfc" id="L781" title="All 2 branches covered.">      if (runner.isFileMoved()) {</span>
<span class="fc" id="L782">        runner.setFileMoved(file.getFile(), true);</span>
      } else {
<span class="fc" id="L784">        runner.setFilename(file.getFile());</span>
      }
<span class="nc" id="L786">    } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L787">      runner.deleteTempFile();</span>
<span class="nc" id="L788">      throw new OpenR66RunnerErrorException(e);</span>
<span class="fc" id="L789">    }</span>
    // check fileSize
<span class="pc bpc" id="L791" title="1 of 4 branches missed.">    if (isSender &amp;&amp; file != null) {</span>
<span class="fc" id="L792">      logger.debug(&quot;could change size: {} =&gt; {}&quot;, runner.getOriginalSize(),</span>
<span class="fc" id="L793">                   file.length());</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">      if (runner.getOriginalSize() &lt; 0) {</span>
<span class="fc" id="L795">        final long originalSize = file.length();</span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">        if (originalSize &gt; 0) {</span>
<span class="fc" id="L797">          runner.setOriginalSize(originalSize);</span>
        }
      }
    }
<span class="fc" id="L801">  }</span>

  /**
   * To be used when a request comes with a bad code so it cannot be set
   * normally
   *
   * @param runner
   * @param code
   */
  public final void setBadRunner(final DbTaskRunner runner,
                                 final ErrorCode code) {
<span class="fc" id="L812">    this.runner = runner;</span>
<span class="pc bpc" id="L813" title="1 of 2 branches missed.">    if (code == ErrorCode.QueryAlreadyFinished) {</span>
<span class="pc bpc" id="L814" title="1 of 2 branches missed.">      if (this.runner.isSender()) {</span>
        // Change dir
        try {
<span class="nc" id="L817">          dir.changeDirectory(this.runner.getRule().getSendPath());</span>
<span class="nc" id="L818">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="nc" id="L820">        }</span>
      } else {
        // Change dir
        try {
<span class="fc" id="L824">          dir.changeDirectory(this.runner.getRule().getWorkPath());</span>
<span class="nc" id="L825">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="fc" id="L827">        }</span>
      }
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">      if (businessObject != null) {</span>
<span class="nc" id="L830">        businessObject.checkAtError(this);</span>
      }
<span class="fc" id="L832">      this.runner.setPostTask();</span>
      try {
<span class="fc" id="L834">        setFileAfterPreRunner(false);</span>
<span class="nc" id="L835">      } catch (final OpenR66RunnerErrorException ignored) {</span>
        // nothing
<span class="nc" id="L837">      } catch (final CommandAbstractException ignored) {</span>
        // nothing
<span class="pc" id="L839">      }</span>
    }
<span class="fc" id="L841">  }</span>

  /**
   * Set the runner, and setup the directory first.
   * &lt;p&gt;
   * This call should be followed by a startup() call.
   *
   * @param runner the runner to set
   *
   * @throws OpenR66RunnerErrorException
   */
  public final void setRunner(final DbTaskRunner runner)
      throws OpenR66RunnerErrorException {
<span class="fc" id="L854">    this.runner = runner;</span>
<span class="fc bfc" id="L855" title="All 2 branches covered.">    if (localChannelReference != null) {</span>
<span class="fc" id="L856">      this.runner.setLocalChannelReference(localChannelReference);</span>
    }
<span class="fc" id="L858">    this.isSender = runner.isSender();</span>
<span class="fc" id="L859">    logger.debug(&quot;Runner to set: {} {}&quot;, runner.shallIgnoreSave(), runner);</span>
<span class="fc" id="L860">    this.runner.checkThroughMode();</span>
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">    if (businessObject != null) {</span>
<span class="nc" id="L862">      businessObject.checkAtStartup(this);</span>
    }
<span class="fc bfc" id="L864" title="All 2 branches covered.">    if (this.runner.isSender()) {</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">      if (runner.isSendThrough()) {</span>
        // May not change dir as needed
        // Change dir
        try {
<span class="fc" id="L869">          dir.changeDirectory(this.runner.getRule().getSendPath());</span>
<span class="nc" id="L870">        } catch (final CommandAbstractException e) {</span>
          // ignore
<span class="pc" id="L872">        }</span>
      } else {
        // Change dir
        try {
<span class="fc" id="L876">          dir.changeDirectory(this.runner.getRule().getSendPath());</span>
<span class="nc" id="L877">        } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L878">          throw new OpenR66RunnerErrorException(e);</span>
<span class="fc" id="L879">        }</span>
      }
    } else {
<span class="fc bfc" id="L882" title="All 2 branches covered.">      if (runner.isRecvThrough()) {</span>
        // May not change dir as needed
        // Change dir
        try {
<span class="fc" id="L886">          dir.changeDirectory(this.runner.getRule().getWorkPath());</span>
<span class="nc" id="L887">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="pc" id="L889">        }</span>
      } else {
        // Change dir
        try {
<span class="fc" id="L893">          dir.changeDirectory(this.runner.getRule().getWorkPath());</span>
<span class="nc" id="L894">        } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L895">          throw new OpenR66RunnerErrorException(e);</span>
<span class="fc" id="L896">        }</span>
      }
    }
<span class="fc" id="L899">    logger.debug(&quot;Dir is: {}&quot;, dir.getFullPath());</span>
<span class="fc" id="L900">  }</span>

  /**
   * START from the PreTask if necessary, and prepare the file
   *
   * @param checkNotExternal if True, the file as Sender should not be
   *     external to current directory
   *
   * @throws OpenR66RunnerErrorException
   */
  public final void startup(final boolean checkNotExternal)
      throws OpenR66RunnerErrorException {
<span class="fc" id="L912">    setRestartMarker();</span>
<span class="fc" id="L913">    logger.debug(&quot;GlobalLastStep: {} vs {}:{}&quot;, runner.getGloballaststep(),</span>
<span class="fc" id="L914">                 TASKSTEP.NOTASK.ordinal(), TASKSTEP.PRETASK.ordinal());</span>
<span class="fc" id="L915">    initializeTransfer(checkNotExternal);</span>
    // Now create the associated file
    try {
<span class="fc" id="L918">      setFileAfterPreRunner(true);</span>
<span class="nc" id="L919">    } catch (final CommandAbstractException e2) {</span>
      // generated due to a possible wildcard not ready
<span class="nc" id="L921">      file = null;</span>
<span class="fc" id="L922">    }</span>
<span class="fc" id="L923">    logger.debug(&quot;GlobalLastStep: {}&quot;, runner.getGloballaststep());</span>
<span class="pc bpc" id="L924" title="1 of 2 branches missed.">    if (runner.getGloballaststep() == TASKSTEP.TRANSFERTASK.ordinal()) {</span>
<span class="pc bpc" id="L925" title="1 of 2 branches missed.">      if (businessObject != null) {</span>
<span class="nc" id="L926">        businessObject.checkAfterPreCommand(this);</span>
      }
<span class="fc bfc" id="L928" title="All 2 branches covered.">      if (!runner.isSender()) {</span>
<span class="pc bpc" id="L929" title="1 of 2 branches missed.">        if (initializeReceiver()) {</span>
<span class="nc" id="L930">          return;</span>
        }
      } else {
<span class="fc" id="L933">        initializeSender();</span>
      }
    }
<span class="fc" id="L936">    runner.saveStatus();</span>
<span class="pc bpc" id="L937" title="1 of 2 branches missed.">    logger.debug(&quot;Final init: {} {}&quot;, runner, file != null);</span>
<span class="fc" id="L938">  }</span>

  private void initializeSender() throws OpenR66RunnerErrorException {
<span class="pc bpc" id="L941" title="1 of 2 branches missed.">    if (file != null) {</span>
      try {
<span class="fc" id="L943">        localChannelReference.getFutureRequest().setFilesize(file.length());</span>
<span class="nc" id="L944">      } catch (final CommandAbstractException ignored) {</span>
        // nothing
<span class="fc" id="L946">      }</span>
      try {
<span class="fc" id="L948">        file.restartMarker(restart);</span>
<span class="nc" id="L949">      } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L950">        runner.deleteTempFile();</span>
<span class="nc" id="L951">        throw new OpenR66RunnerErrorException(e);</span>
<span class="fc" id="L952">      }</span>
    }
<span class="fc" id="L954">  }</span>

  private boolean initializeReceiver() throws OpenR66RunnerErrorException {
    // Check file length according to rank
<span class="fc bfc" id="L958" title="All 2 branches covered.">    if (runner.isRecvThrough()) {</span>
      // no size can be checked
    } else {
<span class="fc" id="L961">      long length = 0;</span>
<span class="pc bpc" id="L962" title="1 of 2 branches missed.">      if (file != null) {</span>
        try {
<span class="fc" id="L964">          length = file.length();</span>
<span class="nc" id="L965">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="fc" id="L967">        }</span>
      }
<span class="fc" id="L969">      final long needed = runner.getOriginalSize() - length;</span>
<span class="fc" id="L970">      long available = 0;</span>
<span class="fc" id="L971">      String targetDir = null;</span>
      try {
<span class="fc" id="L973">        available = dir.getFreeSpace();</span>
<span class="fc" id="L974">        targetDir = dir.getPwd();</span>
<span class="nc" id="L975">      } catch (final CommandAbstractException ignored) {</span>
        // nothing
<span class="fc" id="L977">      }</span>
<span class="pc bpc" id="L978" title="1 of 2 branches missed.">      if (file != null) {</span>
<span class="fc" id="L979">        final File truefile = file.getTrueFile().getParentFile();</span>
<span class="fc" id="L980">        available = truefile.getFreeSpace();</span>
<span class="fc" id="L981">        targetDir = truefile.getPath();</span>
      }
<span class="fc" id="L983">      logger.debug(&quot;Check available space: {} &gt;? {}(+{})&quot;, available, needed,</span>
<span class="fc" id="L984">                   length);</span>
      // Available &gt; 0 since some system returns 0 (wrong size)
<span class="pc bpc" id="L986" title="2 of 4 branches missed.">      if (available &gt; 0 &amp;&amp; needed &gt; available) {</span>
        // not enough space
<span class="nc" id="L988">        runner.setErrorExecutionStatus(ErrorCode.Internal);</span>
<span class="nc" id="L989">        throw new OpenR66RunnerErrorException(</span>
            &quot;File cannot be written due to unsufficient space available: &quot; +
            targetDir + &quot; need &quot; + needed + &quot; more while available is &quot; +
            available);
      }
<span class="pc bpc" id="L994" title="1 of 2 branches missed.">      if (file == null) {</span>
<span class="nc" id="L995">        runner.saveStatus();</span>
<span class="nc" id="L996">        logger.info(&quot;Final PARTIAL init: {}&quot;, runner);</span>
<span class="nc" id="L997">        return true;</span>
      }
<span class="fc" id="L999">      checkPosition(length);</span>
    }
<span class="fc" id="L1001">    return false;</span>
  }

  private void checkPosition(final long length)
      throws OpenR66RunnerErrorException {
    // First check available space
    try {
<span class="fc" id="L1008">      final long oldPosition = restart.getPosition();</span>
<span class="fc" id="L1009">      restart.setSet(true);</span>
<span class="pc bpc" id="L1010" title="1 of 2 branches missed.">      if (oldPosition &gt; length) {</span>
<span class="nc" id="L1011">        int newRank = (int) (length / runner.getBlocksize()) -</span>
<span class="nc" id="L1012">                      Configuration.getRankRestart();</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">        if (newRank &lt;= 0) {</span>
<span class="nc" id="L1014">          newRank = 1;</span>
        }
<span class="nc" id="L1016">        logger.info(&quot;OldPos: {}:{} curLength: {}:{}&quot;, oldPosition,</span>
<span class="nc" id="L1017">                    runner.getRank(), length, newRank);</span>
<span class="nc" id="L1018">        logger.warn(&quot;Decreased Rank Restart for {} at &quot; + newRank, runner);</span>
<span class="nc" id="L1019">        runner.setTransferTask(newRank);</span>
<span class="nc" id="L1020">        restart.restartMarker(runner.getBlocksize() * runner.getRank());</span>
      }
      try {
<span class="fc" id="L1023">        file.restartMarker(restart);</span>
<span class="nc" id="L1024">      } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L1025">        runner.deleteTempFile();</span>
<span class="nc" id="L1026">        throw new OpenR66RunnerErrorException(e);</span>
<span class="fc" id="L1027">      }</span>
<span class="nc" id="L1028">    } catch (final NoRestartException e) {</span>
      // length is not to be changed
<span class="fc" id="L1030">    }</span>
<span class="fc" id="L1031">  }</span>

  private void initializeTransfer(final boolean checkNotExternal)
      throws OpenR66RunnerErrorException {
<span class="fc bfc" id="L1035" title="All 4 branches covered.">    if (runner.isSelfRequest() &amp;&amp; runner.getRule().isSendMode()) {</span>
      // It might be the sender and initiator side, already changed by
      // receiver, reset globalLastStep and globalStep
<span class="fc" id="L1038">      runner.setInitialTask();</span>
    }
<span class="fc bfc" id="L1040" title="All 2 branches covered.">    if (runner.getGloballaststep() == TASKSTEP.NOTASK.ordinal() ||</span>
<span class="pc bpc" id="L1041" title="1 of 2 branches missed.">        runner.getGloballaststep() == TASKSTEP.PRETASK.ordinal()) {</span>
<span class="fc" id="L1042">      setFileBeforePreRunner();</span>
<span class="pc bpc" id="L1043" title="1 of 8 branches missed.">      if (runner.isSender() &amp;&amp; !runner.isSendThrough() &amp;&amp; file != null &amp;&amp;</span>
          checkNotExternal) {
<span class="fc" id="L1045">        String path = null;</span>
        try {
<span class="fc" id="L1047">          path = file.getFile();</span>
<span class="nc" id="L1048">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="fc" id="L1050">        }</span>
<span class="pc bpc" id="L1051" title="2 of 4 branches missed.">        if (file.isExternal() ||</span>
<span class="pc bpc" id="L1052" title="1 of 2 branches missed.">            path != null &amp;&amp; !dir.isPathInCurrentDir(path)) {</span>
          // should not be
<span class="nc" id="L1054">          logger.error(</span>
              &quot;File cannot be found in the current output directory: {} not in {}&quot;,
              file, dir);
<span class="nc" id="L1057">          runner.setErrorExecutionStatus(ErrorCode.FileNotAllowed);</span>
<span class="nc" id="L1058">          throw new OpenR66RunnerErrorException(</span>
              &quot;File cannot be found in the current output directory&quot;);
        }
      }
<span class="fc" id="L1062">      runner.setPreTask();</span>
<span class="fc" id="L1063">      runner.run();</span>
<span class="fc bfc" id="L1064" title="All 4 branches covered.">      if (runner.isSender() &amp;&amp; !runner.isSendThrough()) {</span>
<span class="pc bpc" id="L1065" title="1 of 2 branches missed.">        if (file != null) {</span>
          try {
<span class="fc" id="L1067">            final long originalSize = file.length();</span>
<span class="pc bpc" id="L1068" title="1 of 2 branches missed.">            if (originalSize &gt; 0) {</span>
<span class="fc" id="L1069">              runner.setOriginalSize(originalSize);</span>
            }
<span class="nc" id="L1071">          } catch (final CommandAbstractException e) {</span>
            // ignore
<span class="fc" id="L1073">          }</span>
        }
      }
<span class="fc" id="L1076">      runner.setTransferTask(runner.getRank());</span>
    } else {
<span class="fc" id="L1078">      runner.reset();</span>
<span class="fc" id="L1079">      runner.changeUpdatedInfo(UpdatedInfo.RUNNING);</span>
    }
<span class="fc" id="L1081">  }</span>

  private void setRestartMarker() {
<span class="pc bpc" id="L1084" title="1 of 2 branches missed.">    if (runner.getRank() &gt; 0) {</span>
<span class="nc" id="L1085">      logger.debug(&quot;restart at {} {}&quot;, runner.getRank(), runner);</span>
<span class="nc" id="L1086">      logger.debug(&quot;restart at {} {}&quot;, runner.getRank(), dir);</span>
<span class="nc" id="L1087">      runner.setTransferTask(runner.getRank());</span>
<span class="nc" id="L1088">      restart.restartMarker(runner.getBlocksize() * runner.getRank());</span>
    } else {
<span class="fc" id="L1090">      restart.restartMarker(0);</span>
    }
<span class="fc" id="L1092">  }</span>

  /**
   * Rename the current receive file from the very beginning since the sender
   * has a post action that changes its
   * name
   *
   * @param newFilename
   *
   * @throws OpenR66RunnerErrorException
   */
  public final void renameReceiverFile(final String newFilename)
      throws OpenR66RunnerErrorException {
<span class="pc bpc" id="L1105" title="1 of 2 branches missed.">    if (runner == null) {</span>
<span class="nc" id="L1106">      return;</span>
    }
    // First delete the temporary file if needed
<span class="pc bpc" id="L1109" title="1 of 2 branches missed.">    if (runner.getRank() &gt; 0) {</span>
<span class="nc" id="L1110">      logger.error(</span>
          &quot;Renaming file is not correct since transfer does not start from first block&quot;);
      // Not correct
<span class="nc" id="L1113">      throw new OpenR66RunnerErrorException(</span>
          &quot;Renaming file not correct since transfer already started&quot;);
    }
<span class="pc bpc" id="L1116" title="1 of 2 branches missed.">    if (!runner.isRecvThrough()) {</span>
<span class="fc" id="L1117">      runner.deleteTempFile();</span>
    }
    // Now rename it
<span class="fc" id="L1120">    runner.setOriginalFilename(newFilename);</span>
    try {
<span class="fc" id="L1122">      setFileAfterPreRunnerReceiver(true);</span>
<span class="nc" id="L1123">    } catch (final CommandAbstractException e) {</span>
<span class="nc" id="L1124">      throw new OpenR66RunnerErrorException(e);</span>
<span class="fc" id="L1125">    }</span>
<span class="fc" id="L1126">  }</span>

  /**
   * Finalize the transfer step by running the error or post operation
   * according
   * to the status.
   *
   * @param status
   * @param finalValue
   *
   * @throws OpenR66RunnerErrorException
   * @throws OpenR66ProtocolSystemException
   */
  public final void setFinalizeTransfer(final boolean status,
                                        final R66Result finalValue)
      throws OpenR66RunnerErrorException, OpenR66ProtocolSystemException {
<span class="fc" id="L1142">    logger.debug(&quot;{}:{}:{}&quot;, status, finalValue, runner);</span>
<span class="fc bfc" id="L1143" title="All 2 branches covered.">    if (runner == null) {</span>
<span class="pc bpc" id="L1144" title="1 of 2 branches missed.">      if (localChannelReference != null) {</span>
<span class="pc bpc" id="L1145" title="1 of 2 branches missed.">        if (status) {</span>
<span class="nc" id="L1146">          localChannelReference.validateRequest(finalValue);</span>
        } else {
<span class="fc" id="L1148">          localChannelReference.invalidateRequest(finalValue);</span>
        }
      }
<span class="pc bpc" id="L1151" title="1 of 2 branches missed.">      if (businessObject != null) {</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">        if (status) {</span>
<span class="nc" id="L1153">          businessObject.checkAfterTransfer(this);</span>
        } else {
<span class="nc" id="L1155">          businessObject.checkAtError(this);</span>
        }
      }
<span class="fc" id="L1158">      return;</span>
    }
<span class="pc bpc" id="L1160" title="1 of 2 branches missed.">    if (businessObject != null) {</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">      if (status) {</span>
<span class="nc" id="L1162">        businessObject.checkAfterTransfer(this);</span>
      } else {
<span class="nc" id="L1164">        businessObject.checkAtError(this);</span>
      }
    }
<span class="pc bpc" id="L1167" title="1 of 2 branches missed.">    if (runner.isAllDone()) {</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">      if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L1169">        logger.debug(&quot;Transfer already done but {} on {} {}&quot;, status, file,</span>
<span class="nc" id="L1170">                     runner.toShortString(),</span>
<span class="nc" id="L1171">                     new OpenR66RunnerErrorException(finalValue.toString()));</span>
      }
      // FIXME ??
      /*
       * if (! status) runner.finalizeTransfer(localChannelReference, file, finalValue, status)
       */
<span class="nc" id="L1177">      return;</span>
    }
<span class="pc bpc" id="L1179" title="1 of 2 branches missed.">    if (runner.isInError()) {</span>
<span class="nc bnc" id="L1180" title="All 2 branches missed.">      if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L1181">        logger.debug(&quot;Transfer already done in error but {} on {} {}&quot;, status,</span>
<span class="nc" id="L1182">                     file, runner.toShortString(),</span>
<span class="nc" id="L1183">                     new OpenR66RunnerErrorException(finalValue.toString()));</span>
      }
      // FIXME ??
      /*
       * if (! status) runner.finalizeTransfer(localChannelReference, file, finalValue, status)
       */
<span class="nc" id="L1189">      return;</span>
    }
<span class="pc bpc" id="L1191" title="1 of 2 branches missed.">    if (localChannelReference.getFutureRequest().isDone()) {</span>
<span class="nc bnc" id="L1192" title="All 2 branches missed.">      if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L1193">        logger.debug(&quot;Request already done but {} on {} {}&quot; + status, file,</span>
<span class="nc" id="L1194">                     runner.toShortString(),</span>
<span class="nc" id="L1195">                     new OpenR66RunnerErrorException(finalValue.toString()));</span>
      }
      // Already finished once so do nothing more
<span class="nc" id="L1198">      return;</span>
    }
<span class="fc bfc" id="L1200" title="All 2 branches covered.">    if (!status) {</span>
<span class="fc" id="L1201">      runner.deleteTempFile();</span>
<span class="fc" id="L1202">      runner.setErrorExecutionStatus(finalValue.getCode());</span>
    }
<span class="fc bfc" id="L1204" title="All 2 branches covered.">    if (status) {</span>
<span class="fc" id="L1205">      runner.finishTransferTask(ErrorCode.TransferOk);</span>
    } else {
<span class="fc" id="L1207">      runner.finishTransferTask(finalValue.getCode());</span>
    }
<span class="fc" id="L1209">    logger.debug(&quot;Transfer {} on {} and {}&quot;, status, file, runner);</span>
<span class="fc bfc" id="L1210" title="All 2 branches covered.">    if (!runner.ready()) {</span>
      // Pre task in error (or even before)
      final OpenR66RunnerErrorException runnerErrorException;
<span class="pc bpc" id="L1213" title="2 of 4 branches missed.">      if (!status &amp;&amp; finalValue.getException() != null) {</span>
<span class="fc" id="L1214">        runnerErrorException = new OpenR66RunnerErrorException(</span>
<span class="fc" id="L1215">            &quot;Pre task in error (or even before)&quot;, finalValue.getException());</span>
      } else {
<span class="nc" id="L1217">        runnerErrorException = new OpenR66RunnerErrorException(</span>
            &quot;Pre task in error (or even before)&quot;);
      }
<span class="fc" id="L1220">      finalValue.setException(runnerErrorException);</span>
<span class="fc" id="L1221">      logger.info(&quot;Pre task in error (or even before) : {}&quot;,</span>
<span class="fc" id="L1222">                  runnerErrorException.getMessage());</span>
<span class="pc bpc" id="L1223" title="1 of 2 branches missed.">      if (Configuration.configuration.isExecuteErrorBeforeTransferAllowed()) {</span>
<span class="fc" id="L1224">        runner.finalizeTransfer(localChannelReference, file, finalValue,</span>
                                status);
      }
<span class="fc" id="L1227">      runner.saveStatus();</span>
<span class="fc" id="L1228">      localChannelReference.invalidateRequest(finalValue);</span>
<span class="fc" id="L1229">      throw runnerErrorException;</span>
    }
    try {
<span class="pc bpc" id="L1232" title="1 of 2 branches missed.">      if (file != null) {</span>
<span class="fc" id="L1233">        file.closeFile();</span>
      }
<span class="nc" id="L1235">    } catch (final CommandAbstractException e1) {</span>
<span class="nc" id="L1236">      R66Result result = finalValue;</span>
<span class="nc bnc" id="L1237" title="All 2 branches missed.">      if (status) {</span>
<span class="nc" id="L1238">        result = new R66Result(new OpenR66RunnerErrorException(e1), this, false,</span>
                               ErrorCode.Internal, runner);
      }
<span class="nc" id="L1241">      localChannelReference.invalidateRequest(result);</span>
<span class="nc" id="L1242">      throw (OpenR66RunnerErrorException) result.getException();</span>
<span class="fc" id="L1243">    }</span>
<span class="fc" id="L1244">    runner.finalizeTransfer(localChannelReference, file, finalValue, status);</span>
<span class="pc bpc" id="L1245" title="1 of 2 branches missed.">    if (businessObject != null) {</span>
<span class="nc" id="L1246">      businessObject.checkAfterPost(this);</span>
    }
<span class="fc" id="L1248">  }</span>

  /**
   * Try to finalize the request if possible
   *
   * @param errorValue
   *
   * @throws OpenR66RunnerErrorException
   * @throws OpenR66ProtocolSystemException
   */
  public final void tryFinalizeRequest(final R66Result errorValue)
      throws OpenR66RunnerErrorException, OpenR66ProtocolSystemException {
<span class="pc bpc" id="L1260" title="1 of 2 branches missed.">    if (getLocalChannelReference() == null) {</span>
<span class="nc" id="L1261">      return;</span>
    }
<span class="fc bfc" id="L1263" title="All 2 branches covered.">    if (getLocalChannelReference().getFutureRequest().isDone()) {</span>
<span class="fc" id="L1264">      return;</span>
    }
<span class="fc bfc" id="L1266" title="All 2 branches covered.">    if (runner == null) {</span>
<span class="fc" id="L1267">      localChannelReference.invalidateRequest(errorValue);</span>
<span class="fc" id="L1268">      return;</span>
    }
    // do the real end
<span class="pc bpc" id="L1271" title="1 of 2 branches missed.">    if (runner.getStatus() == ErrorCode.CompleteOk) {</span>
<span class="nc" id="L1272">      runner.setAllDone();</span>
<span class="nc" id="L1273">      runner.forceSaveStatus();</span>
<span class="nc" id="L1274">      localChannelReference.validateRequest(</span>
          new R66Result(this, true, ErrorCode.CompleteOk, runner));
<span class="pc bpc" id="L1276" title="1 of 2 branches missed.">    } else if (runner.getStatus() == ErrorCode.TransferOk &amp;&amp;</span>
<span class="nc bnc" id="L1277" title="All 2 branches missed.">               (!runner.isSender() ||</span>
<span class="nc bnc" id="L1278" title="All 2 branches missed.">                errorValue.getCode() == ErrorCode.QueryAlreadyFinished)) {</span>
      // Try to finalize it
      try {
<span class="nc" id="L1281">        setFinalizeTransfer(true,</span>
                            new R66Result(this, true, ErrorCode.CompleteOk,
                                          runner));
<span class="nc" id="L1284">        localChannelReference.validateRequest(</span>
<span class="nc" id="L1285">            localChannelReference.getFutureEndTransfer().getResult());</span>
<span class="nc" id="L1286">      } catch (final OpenR66ProtocolSystemException e) {</span>
<span class="nc" id="L1287">        logger.error(&quot;Cannot validate runner:     {}&quot;, runner.toShortString());</span>
<span class="nc" id="L1288">        runner.changeUpdatedInfo(UpdatedInfo.INERROR);</span>
<span class="nc" id="L1289">        runner.setErrorExecutionStatus(errorValue.getCode());</span>
<span class="nc" id="L1290">        runner.forceSaveStatus();</span>
<span class="nc" id="L1291">        setFinalizeTransfer(false, errorValue);</span>
<span class="nc" id="L1292">      } catch (final OpenR66RunnerErrorException e) {</span>
<span class="nc" id="L1293">        logger.error(&quot;Cannot validate runner:     {}&quot;, runner.toShortString());</span>
<span class="nc" id="L1294">        runner.changeUpdatedInfo(UpdatedInfo.INERROR);</span>
<span class="nc" id="L1295">        runner.setErrorExecutionStatus(errorValue.getCode());</span>
<span class="nc" id="L1296">        runner.forceSaveStatus();</span>
<span class="nc" id="L1297">        setFinalizeTransfer(false, errorValue);</span>
<span class="nc" id="L1298">      }</span>
    } else {
      // invalidate Request
<span class="fc" id="L1301">      logger.error(</span>
          &quot;Runner {} will be shutdown while in status {} and future status will be {}&quot;,
<span class="fc" id="L1303">          runner.getSpecialId(), runner.getStatus().getMesg(),</span>
<span class="fc" id="L1304">          errorValue.getCode().getMesg());</span>
<span class="fc" id="L1305">      setFinalizeTransfer(false, errorValue);</span>
    }
<span class="fc" id="L1307">  }</span>

  /**
   * @return the file
   */
  public final R66File getFile() {
<span class="fc" id="L1313">    return file;</span>
  }

  /**
   * @return True if the number of Error is still acceptable
   */
  public final boolean addError() {
<span class="nc" id="L1320">    final int value = numOfError.incrementAndGet();</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">    return value &lt; Configuration.RETRYNB;</span>
  }

  @Override
  public final String toString() {
<span class="pc bpc" id="L1326" title="1 of 2 branches missed.">    return &quot;Session: FS[&quot; + state.getCurrent() + &quot;] &quot; + status + &quot;  &quot; +</span>
<span class="pc bpc" id="L1327" title="1 of 2 branches missed.">           (auth != null? auth.toString() : &quot;no Auth&quot;) + &quot;     &quot; +</span>
<span class="pc bfc" id="L1328" title="All 2 branches covered.">           (dir != null? dir.toString() : &quot;no Dir&quot;) + &quot;     &quot; +</span>
<span class="fc bfc" id="L1329" title="All 2 branches covered.">           (file != null? file.toString() : &quot;no File&quot;) + &quot;     &quot; +</span>
<span class="fc" id="L1330">           (runner != null? runner.toShortString() : &quot;no Runner&quot;);</span>
  }

  @Override
  public final String getUniqueExtension() {
<span class="nc" id="L1335">    return Configuration.EXT_R66;</span>
  }

  /**
   * @return the dirsFromSession
   */
  public final HashMap&lt;String, R66Dir&gt; getDirsFromSession() {
<span class="fc" id="L1342">    return dirsFromSession;</span>
  }

  /**
   * @return True if according to session, it is the sender side (to byPass
   *     send to itself issue)
   */
  public final boolean isSender() {
<span class="fc" id="L1350">    return isSender;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>