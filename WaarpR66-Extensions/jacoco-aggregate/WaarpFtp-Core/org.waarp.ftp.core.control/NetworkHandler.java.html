<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>NetworkHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Extensions for JRE 8 and greater</a> &gt; <a href="../index.html" class="el_bundle">WaarpFtp-Core</a> &gt; <a href="index.source.html" class="el_package">org.waarp.ftp.core.control</a> &gt; <span class="el_source">NetworkHandler.java</span></div><h1>NetworkHandler.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.ftp.core.control;

import io.netty.channel.Channel;
import io.netty.channel.ChannelException;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.handler.ssl.SslHandler;
import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.GenericFutureListener;
import org.waarp.common.command.ReplyCode;
import org.waarp.common.command.exception.CommandAbstractException;
import org.waarp.common.command.exception.Reply421Exception;
import org.waarp.common.command.exception.Reply503Exception;
import org.waarp.common.crypto.ssl.WaarpSslUtility;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.WaarpNettyUtil;
import org.waarp.ftp.core.command.AbstractCommand;
import org.waarp.ftp.core.command.FtpCommandCode;
import org.waarp.ftp.core.command.access.USER;
import org.waarp.ftp.core.command.internal.ConnectionCommand;
import org.waarp.ftp.core.command.internal.IncorrectCommand;
import org.waarp.ftp.core.control.ftps.FtpsInitializer;
import org.waarp.ftp.core.data.FtpTransferControl;
import org.waarp.ftp.core.exception.FtpNoConnectionException;
import org.waarp.ftp.core.session.FtpSession;
import org.waarp.ftp.core.utils.FtpChannelUtils;

import java.io.IOException;
import java.net.BindException;
import java.net.ConnectException;
import java.nio.channels.ClosedChannelException;
import java.util.concurrent.RejectedExecutionException;

/**
 * Main Network Handler (Control part) implementing RFC 959, 775, 2389, 2428,
 * 3659 and supports XCRC and XMD5
 * commands.
 */
public class NetworkHandler extends SimpleChannelInboundHandler&lt;String&gt; {
  private static final String INTERNAL_ERROR_DISCONNECT =
      &quot;Internal error: disconnect&quot;;

  /**
   * Internal Logger
   */
<span class="fc" id="L68">  private static final WaarpLogger logger =</span>
<span class="fc" id="L69">      WaarpLoggerFactory.getLogger(NetworkHandler.class);</span>

  /**
   * Business Handler
   */
  private final BusinessHandler businessHandler;

  /**
   * Internal store for the SessionInterface
   */
  private final FtpSession session;

  /**
   * The associated Channel
   */
  private Channel controlChannel;
  /**
   * ChannelHandlerContext that could be used whenever needed
   */
  private ChannelHandlerContext ctx;

  /**
   * Constructor from session
   *
   * @param session
   */
<span class="fc" id="L95">  public NetworkHandler(final FtpSession session) {</span>
<span class="fc" id="L96">    this.session = session;</span>
<span class="fc" id="L97">    businessHandler = session.getBusinessHandler();</span>
<span class="fc" id="L98">    businessHandler.setNetworkHandler(this);</span>
<span class="fc" id="L99">  }</span>

  /**
   * @return the businessHandler
   */
  public final BusinessHandler getBusinessHandler() {
<span class="nc" id="L105">    return businessHandler;</span>
  }

  /**
   * @return the session
   */
  public final FtpSession getFtpSession() {
<span class="fc" id="L112">    return session;</span>
  }

  /**
   * @return the Control Channel
   */
  public final Channel getControlChannel() {
<span class="fc" id="L119">    return controlChannel;</span>
  }

  /**
   * Run firstly executeChannelClosed.
   */
  @Override
  public void channelInactive(final ChannelHandlerContext ctx)
      throws Exception {
<span class="pc bpc" id="L128" title="2 of 4 branches missed.">    if (session == null || session.getDataConn() == null ||</span>
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        session.getDataConn().getFtpTransferControl() == null) {</span>
<span class="nc" id="L130">      super.channelInactive(ctx);</span>
<span class="nc" id="L131">      return;</span>
    }
    // Wait for any command running before closing (bad client sometimes
    // don't wait for answer)
<span class="fc" id="L135">    int limit = 200;</span>
<span class="fc" id="L136">    while (session.getDataConn().getFtpTransferControl()</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">                  .isFtpTransferExecuting()) {</span>
<span class="nc" id="L138">      Thread.sleep(WaarpNettyUtil.MINIMAL_DELAY_MS);</span>
<span class="nc" id="L139">      limit--;</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">      if (limit &lt;= 0) {</span>
<span class="nc" id="L141">        logger.warn(&quot;Waiting for transfer finished but 2s is not enough&quot;);</span>
<span class="nc" id="L142">        break; // wait at most 1s</span>
      }
    }
<span class="fc" id="L145">    businessHandler.executeChannelClosed();</span>
    // release file and other permanent objects
<span class="fc" id="L147">    businessHandler.clear();</span>
<span class="fc" id="L148">    session.clear();</span>
<span class="fc" id="L149">    super.channelInactive(ctx);</span>
<span class="fc" id="L150">  }</span>

  /**
   * Initialize the Handler.
   */
  @Override
  public void channelActive(final ChannelHandlerContext ctx) throws Exception {
<span class="fc" id="L157">    this.ctx = ctx;</span>
<span class="fc" id="L158">    final Channel channel = ctx.channel();</span>
<span class="fc" id="L159">    controlChannel = channel;</span>
<span class="fc" id="L160">    session.setControlConnected();</span>
<span class="fc" id="L161">    FtpChannelUtils.addCommandChannel(channel, session.getConfiguration());</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">    if (isStillAlive(ctx)) {</span>
      // Make the first execution ready
<span class="fc" id="L164">      final AbstractCommand command = new ConnectionCommand(getFtpSession());</span>
<span class="fc" id="L165">      session.setNextCommand(command);</span>
      // This command can change the next Command
<span class="fc" id="L167">      businessHandler.executeChannelConnected(channel);</span>
      // Answer ready to continue from first command = Connection
<span class="fc" id="L169">      messageRunAnswer(ctx);</span>
<span class="fc" id="L170">      getFtpSession().setReady(true);</span>
    }
<span class="fc" id="L172">  }</span>

  /**
   * If the service is going to shutdown, it sends back a 421 message to the
   * connection
   *
   * @return True if the service is alive, else False if the system is going
   *     down
   */
  private boolean isStillAlive(final ChannelHandlerContext ctx) {
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">    if (session.getConfiguration().isShutdown()) {</span>
<span class="nc" id="L183">      session.setExitErrorCode(&quot;Service is going down: disconnect&quot;);</span>
<span class="nc" id="L184">      writeFinalAnswer(ctx);</span>
<span class="nc" id="L185">      return false;</span>
    }
<span class="fc" id="L187">    return true;</span>
  }

  /**
   * Default exception task: close the current connection after calling
   * exceptionLocalCaught and writing if
   * possible the current replyCode.
   */
  @Override
  public void exceptionCaught(final ChannelHandlerContext ctx,
                              final Throwable cause) {
<span class="fc" id="L198">    this.ctx = ctx;</span>
<span class="fc" id="L199">    final Channel channel = ctx.channel();</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">    if (session == null) {</span>
      // should not be
<span class="nc" id="L202">      logger.warn(&quot;NO SESSION&quot;, cause);</span>
<span class="nc" id="L203">      return;</span>
    }
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">    if (cause instanceof ConnectException) {</span>
<span class="nc" id="L206">      final ConnectException e2 = (ConnectException) cause;</span>
<span class="nc" id="L207">      logger.warn(&quot;Connection impossible since {} with Channel {}&quot;,</span>
<span class="nc" id="L208">                  e2.getMessage(), channel);</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">    } else if (cause instanceof ChannelException) {</span>
<span class="nc" id="L210">      final ChannelException e2 = (ChannelException) cause;</span>
<span class="nc" id="L211">      logger.warn(</span>
          &quot;Connection (example: timeout) impossible since {} with Channel {}&quot;,
<span class="nc" id="L213">          e2.getMessage(), channel);</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">    } else if (cause instanceof ClosedChannelException) {</span>
<span class="nc" id="L215">      logger.debug(&quot;Connection closed before end&quot;);</span>
<span class="nc" id="L216">      session.setExitErrorCode(INTERNAL_ERROR_DISCONNECT);</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">      if (channel.isActive()) {</span>
<span class="nc" id="L218">        writeFinalAnswer(ctx);</span>
      }
<span class="nc" id="L220">      return;</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">    } else if (cause instanceof CommandAbstractException) {</span>
      // FTP Exception: not close if not necessary
<span class="nc" id="L223">      final CommandAbstractException e2 = (CommandAbstractException) cause;</span>
<span class="nc" id="L224">      logger.warn(&quot;Command Error Reply {}&quot;, e2.getMessage());</span>
<span class="nc" id="L225">      session.setReplyCode(e2);</span>
<span class="nc" id="L226">      businessHandler.afterRunCommandKo(e2);</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">      if (channel.isActive()) {</span>
<span class="nc" id="L228">        writeFinalAnswer(ctx);</span>
      }
<span class="nc" id="L230">      return;</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">    } else if (cause instanceof NullPointerException) {</span>
<span class="nc" id="L232">      final NullPointerException e2 = (NullPointerException) cause;</span>
<span class="nc" id="L233">      logger.warn(&quot;Null pointer Exception: &quot; + ctx.channel(), e2);</span>
      try {
<span class="nc" id="L235">        session.setExitErrorCode(INTERNAL_ERROR_DISCONNECT);</span>
<span class="nc bnc" id="L236" title="All 4 branches missed.">        if (businessHandler != null &amp;&amp; session.getDataConn() != null) {</span>
<span class="nc" id="L237">          businessHandler.exceptionLocalCaught(cause);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">          if (channel.isActive()) {</span>
<span class="nc" id="L239">            writeFinalAnswer(ctx);</span>
          }
        }
<span class="nc" id="L242">      } catch (final NullPointerException ignored) {</span>
        // nothing
<span class="nc" id="L244">      }</span>
<span class="nc" id="L245">      return;</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">    } else if (cause instanceof BindException) {</span>
<span class="nc" id="L247">      final BindException e2 = (BindException) cause;</span>
<span class="nc" id="L248">      logger.warn(&quot;Connection aborted since {} with Channel {}&quot;,</span>
<span class="nc" id="L249">                  e2.getMessage(), channel);</span>
<span class="nc" id="L250">      logger.debug(&quot;DEBUG&quot;, cause);</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">    } else if (cause instanceof IOException) {</span>
<span class="nc" id="L252">      final IOException e2 = (IOException) cause;</span>
<span class="nc" id="L253">      logger.warn(&quot;Connection aborted since {} with Channel {}&quot;,</span>
<span class="nc" id="L254">                  e2.getMessage(), channel);</span>
<span class="nc" id="L255">      logger.debug(&quot;DEBUG&quot;, cause);</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">    } else if (cause instanceof RejectedExecutionException) {</span>
<span class="nc" id="L257">      logger.debug(&quot;Rejected execution (shutdown) from {}&quot;, channel);</span>
<span class="nc" id="L258">      return;</span>
    } else {
<span class="fc" id="L260">      logger.warn(&quot;Unexpected exception from Outband Ref Channel: &quot; + channel +</span>
<span class="fc" id="L261">                  &quot; Exception: &quot; + cause.getMessage(), cause);</span>
    }
<span class="fc" id="L263">    session.setExitErrorCode(INTERNAL_ERROR_DISCONNECT);</span>
<span class="fc" id="L264">    businessHandler.exceptionLocalCaught(cause);</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">    if (channel.isActive()) {</span>
<span class="nc" id="L266">      writeFinalAnswer(ctx);</span>
    }
<span class="fc" id="L268">  }</span>

  /**
   * Simply call messageRun with the received message
   */
  @Override
  public void channelRead0(final ChannelHandlerContext ctx, final String e) {
<span class="fc" id="L275">    this.ctx = ctx;</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">    if (isStillAlive(ctx)) {</span>
      // First wait for the initialization to be fully done
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">      if (!session.isReady()) {</span>
<span class="nc" id="L279">        session.setReplyCode(</span>
            ReplyCode.REPLY_421_SERVICE_NOT_AVAILABLE_CLOSING_CONTROL_CONNECTION,
            null);
<span class="nc" id="L282">        businessHandler.afterRunCommandKo(</span>
<span class="nc" id="L283">            new Reply421Exception(session.getReplyCode().getMesg()));</span>
<span class="nc" id="L284">        writeIntermediateAnswer(ctx);</span>
<span class="nc" id="L285">        return;</span>
      }
<span class="fc" id="L287">      AbstractCommand command = FtpCommandCode.getFromLine(getFtpSession(), e);</span>
<span class="fc" id="L288">      logger.debug(&quot;RECVMSG: {} CMD: {} {}&quot; + command.getCode(), e,</span>
<span class="fc" id="L289">                   command.getCommand());</span>
      // First check if the command is an ABORT, QUIT or STAT
<span class="fc bfc" id="L291" title="All 2 branches covered.">      if (!FtpCommandCode.isSpecialCommand(command.getCode())) {</span>
        // Now check if a transfer is on its way: illegal to have at
        // same time two commands (except ABORT). Wait is at most 100x
        // RETRYINMS=1s
<span class="fc" id="L295">        final FtpTransferControl control =</span>
<span class="fc" id="L296">            session.getDataConn().getFtpTransferControl();</span>
<span class="fc" id="L297">        final boolean notFinished = control.waitFtpTransferExecuting();</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        if (notFinished) {</span>
<span class="nc" id="L299">          session.setReplyCode(ReplyCode.REPLY_503_BAD_SEQUENCE_OF_COMMANDS,</span>
                               &quot;Previous transfer command is not finished yet&quot;);
<span class="nc" id="L301">          businessHandler.afterRunCommandKo(</span>
<span class="nc" id="L302">              new Reply503Exception(session.getReplyCode().getMesg()));</span>
<span class="nc" id="L303">          writeIntermediateAnswer(ctx);</span>
<span class="nc" id="L304">          return;</span>
        }
      }
      // Default message
<span class="fc" id="L308">      session.setReplyCode(ReplyCode.REPLY_200_COMMAND_OKAY, null);</span>
      // Special check for SSL AUTH/PBSZ/PROT/USER/PASS/ACCT/CCC
<span class="fc bfc" id="L310" title="All 2 branches covered.">      if (FtpCommandCode.isSslOrAuthCommand(command.getCode())) {</span>
<span class="fc" id="L311">        session.setNextCommand(command);</span>
<span class="fc" id="L312">        messageRunAnswer(ctx);</span>
<span class="fc" id="L313">        return;</span>
      }
<span class="fc bfc" id="L315" title="All 2 branches covered.">      if (session.getCurrentCommand().isNextCommandValid(command)) {</span>
<span class="fc" id="L316">        logger.debug(&quot;Previous: {} Next: {}&quot;,</span>
<span class="fc" id="L317">                     session.getCurrentCommand().getCode(), command.getCode());</span>
<span class="fc" id="L318">        session.setNextCommand(command);</span>
<span class="fc" id="L319">        messageRunAnswer(ctx);</span>
      } else {
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        if (!session.getAuth().isIdentified()) {</span>
<span class="fc" id="L322">          session.setReplyCode(ReplyCode.REPLY_530_NOT_LOGGED_IN, null);</span>
<span class="fc" id="L323">          session.setNextCommand(new USER());</span>
<span class="fc" id="L324">          writeFinalAnswer(ctx);</span>
<span class="fc" id="L325">          return;</span>
        }
<span class="nc" id="L327">        command = new IncorrectCommand();</span>
<span class="nc" id="L328">        command.setArgs(getFtpSession(), e, null,</span>
                        FtpCommandCode.IncorrectSequence);
<span class="nc" id="L330">        session.setNextCommand(command);</span>
<span class="nc" id="L331">        messageRunAnswer(ctx);</span>
      }
    }
<span class="fc" id="L334">  }</span>

  /**
   * Write the current answer and eventually close channel if necessary (421
   * or
   * 221)
   *
   * @return True if the channel is closed due to the code
   */
  private boolean writeFinalAnswer(final ChannelHandlerContext ctx) {
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">    if (session.getReplyCode() ==</span>
        ReplyCode.REPLY_421_SERVICE_NOT_AVAILABLE_CLOSING_CONTROL_CONNECTION ||
<span class="fc bfc" id="L346" title="All 2 branches covered.">        session.getReplyCode() ==</span>
        ReplyCode.REPLY_221_CLOSING_CONTROL_CONNECTION) {
<span class="fc" id="L348">      session.getDataConn().getFtpTransferControl().clear();</span>
<span class="fc" id="L349">      writeIntermediateAnswer(ctx).addListener(WaarpSslUtility.SSLCLOSE);</span>
<span class="fc" id="L350">      return true;</span>
    }
<span class="fc" id="L352">    writeIntermediateAnswer(ctx);</span>
<span class="fc" id="L353">    session.setCurrentCommandFinished();</span>
<span class="fc" id="L354">    return false;</span>
  }

  /**
   * Write an intermediate Answer from Business before last answer also set by
   * the Business
   *
   * @return the ChannelFuture associated with the write
   */
  public final ChannelFuture writeIntermediateAnswer(
      final ChannelHandlerContext ctx) {
<span class="fc" id="L365">    logger.debug(&quot;Answer: {}&quot;, session.getAnswer());</span>
<span class="fc" id="L366">    return ctx.writeAndFlush(session.getAnswer());</span>
  }

  /**
   * Write an intermediate Answer from Business before last answer also set by
   * the Business
   *
   * @return the ChannelFuture associated with the write
   */
  public final ChannelFuture writeIntermediateAnswer() {
<span class="fc" id="L376">    return writeIntermediateAnswer(ctx);</span>
  }

  /**
   * To be extended to inform of an error to SNMP support
   *
   * @param error1
   * @param error2
   */
  protected void callForSnmp(final String error1, final String error2) {
    // ignore
<span class="fc" id="L387">  }</span>

  /**
   * Execute one command and write the following answer
   */
  private void messageRunAnswer(final ChannelHandlerContext ctx) {
<span class="fc" id="L393">    boolean error = false;</span>
<span class="fc" id="L394">    logger.debug(&quot;Code: {}&quot;, session.getCurrentCommand().getCode());</span>
    try {
<span class="fc" id="L396">      businessHandler.beforeRunCommand();</span>
<span class="fc" id="L397">      final AbstractCommand command = session.getCurrentCommand();</span>
<span class="fc" id="L398">      logger.debug(&quot;Run {}&quot;, command.getCommand());</span>
<span class="fc" id="L399">      command.exec();</span>
<span class="fc" id="L400">      businessHandler.afterRunCommandOk();</span>
<span class="fc" id="L401">    } catch (final CommandAbstractException e) {</span>
<span class="fc" id="L402">      logger.debug(&quot;Command in error&quot;, e);</span>
<span class="fc" id="L403">      error = true;</span>
<span class="fc" id="L404">      session.setReplyCode(e);</span>
<span class="fc" id="L405">      businessHandler.afterRunCommandKo(e);</span>
<span class="fc" id="L406">    }</span>
<span class="fc" id="L407">    logger.debug(&quot;Code: {} [{}]&quot;, session.getCurrentCommand().getCode(),</span>
<span class="fc" id="L408">                 session.getReplyCode());</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">    if (error) {</span>
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">      if (session.getCurrentCommand().getCode() !=</span>
          FtpCommandCode.INTERNALSHUTDOWN) {
<span class="fc" id="L412">        writeFinalAnswer(ctx);</span>
      }
      // In error so Check that Data is closed
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">      if (session.getDataConn().isActive()) {</span>
<span class="nc" id="L416">        logger.debug(&quot;Closing DataChannel while command is in error&quot;);</span>
        try {
<span class="nc" id="L418">          session.getDataConn().getCurrentDataChannel().close();</span>
<span class="nc" id="L419">        } catch (final FtpNoConnectionException e) {</span>
          // ignore
<span class="nc" id="L421">        }</span>
      }
<span class="fc" id="L423">      return;</span>
    }
<span class="fc bfc" id="L425" title="All 2 branches covered.">    if (session.getCurrentCommand().getCode() == FtpCommandCode.AUTH ||</span>
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">        session.getCurrentCommand().getCode() == FtpCommandCode.CCC) {</span>
<span class="fc" id="L427">      controlChannel.config().setAutoRead(false);</span>
<span class="fc" id="L428">      final ChannelFuture future = writeIntermediateAnswer(ctx);</span>
<span class="fc" id="L429">      session.setCurrentCommandFinished();</span>
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">      if (session.getCurrentCommand().getCode() == FtpCommandCode.AUTH) {</span>
<span class="fc" id="L431">        logger.debug(&quot;SSL to be added to pipeline&quot;);</span>
<span class="fc" id="L432">        ChannelHandler sslHandler = ctx.pipeline().first();</span>
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">        if (sslHandler instanceof SslHandler) {</span>
<span class="nc" id="L434">          logger.debug(&quot;Already got a SslHandler&quot;);</span>
        } else {
<span class="fc" id="L436">          logger.debug(&quot;Add Explicitely SSL support to Command&quot;);</span>
          // add the SSL support
<span class="fc" id="L438">          sslHandler =</span>
<span class="fc" id="L439">              FtpsInitializer.waarpSslContextFactory.createHandlerServer(</span>
<span class="fc" id="L440">                  FtpsInitializer.waarpSslContextFactory.needClientAuthentication(),</span>
<span class="fc" id="L441">                  false, ctx.channel());</span>
<span class="fc" id="L442">          session.prepareSsl();</span>
<span class="fc" id="L443">          WaarpSslUtility.addSslHandler(future, ctx.pipeline(), sslHandler,</span>
<span class="fc" id="L444">                                        new GenericFutureListener&lt;Future&lt;? super Channel&gt;&gt;() {</span>
                                          @Override
                                          public final void operationComplete(
                                              final Future&lt;? super Channel&gt; future) {
<span class="fc bfc" id="L448" title="All 2 branches covered.">                                            if (!future.isSuccess()) {</span>
<span class="fc" id="L449">                                              final String error2 =</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">                                                  future.cause() != null?</span>
<span class="fc" id="L451">                                                      future.cause()</span>
<span class="pc" id="L452">                                                            .getMessage() :</span>
                                                      &quot;During Handshake&quot;;
<span class="fc" id="L454">                                              logger.error(</span>
                                                  &quot;Cannot finalize Ssl Command channel {}&quot;,
<span class="fc" id="L456">                                                  error2, future.cause());</span>
<span class="fc" id="L457">                                              callForSnmp(</span>
                                                  &quot;SSL Connection Error&quot;,
                                                  error2);
<span class="fc" id="L460">                                              session.setSsl(false);</span>
<span class="fc" id="L461">                                              ctx.close();</span>
<span class="fc" id="L462">                                            } else {</span>
<span class="fc" id="L463">                                              logger.debug(</span>
                                                  &quot;End of initialization of SSL and command channel: {}&quot;,
<span class="fc" id="L465">                                                  ctx.channel());</span>
<span class="fc" id="L466">                                              session.setSsl(true);</span>
                                            }
<span class="fc" id="L468">                                          }</span>
                                        });
        }
<span class="pc bnc" id="L471" title="All 2 branches missed.">      } else if (session.getCurrentCommand().getCode() == FtpCommandCode.CCC) {</span>
<span class="nc" id="L472">        logger.debug(&quot;SSL to be removed from pipeline&quot;);</span>
        // remove the SSL support
<span class="nc" id="L474">        session.prepareSsl();</span>
<span class="nc" id="L475">        WaarpSslUtility.removingSslHandler(future, controlChannel, false);</span>
      }
<span class="fc bfc" id="L477" title="All 2 branches covered.">    } else if (session.getCurrentCommand().getCode() !=</span>
               FtpCommandCode.INTERNALSHUTDOWN) {
<span class="fc" id="L479">      writeFinalAnswer(ctx);</span>
    }
<span class="fc" id="L481">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>