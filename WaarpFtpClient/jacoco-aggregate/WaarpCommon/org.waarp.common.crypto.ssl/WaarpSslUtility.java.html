<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>WaarpSslUtility.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Ftp R66 client</a> &gt; <a href="../index.html" class="el_bundle">WaarpCommon</a> &gt; <a href="index.source.html" class="el_package">org.waarp.common.crypto.ssl</a> &gt; <span class="el_source">WaarpSslUtility.java</span></div><h1>WaarpSslUtility.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.common.crypto.ssl;

import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.group.ChannelGroup;
import io.netty.channel.group.DefaultChannelGroup;
import io.netty.handler.ssl.SslHandler;
import io.netty.util.concurrent.DefaultEventExecutor;
import io.netty.util.concurrent.EventExecutor;
import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.GenericFutureListener;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.WaarpNettyUtil;
import org.waarp.common.utility.WaarpThreadFactory;

import java.util.NoSuchElementException;

/**
 * Utilities for SSL support
 */
public final class WaarpSslUtility {
  /**
   * Internal Logger
   */
<span class="fc" id="L48">  private static final WaarpLogger logger =</span>
<span class="fc" id="L49">      WaarpLoggerFactory.getLogger(WaarpSslUtility.class);</span>

  /**
   * EventExecutor associated with Ssl utility
   */
<span class="fc" id="L54">  private static final EventExecutor SSL_EVENT_EXECUTOR =</span>
      new DefaultEventExecutor(new WaarpThreadFactory(&quot;SSLEVENT&quot;));
  /**
   * ChannelGroup for SSL
   */
<span class="fc" id="L59">  private static final ChannelGroup sslChannelGroup =</span>
      new DefaultChannelGroup(&quot;SslChannelGroup&quot;, SSL_EVENT_EXECUTOR);

  /**
   * Closing channel with SSL close at first step
   */
<span class="fc" id="L65">  public static final ChannelFutureListener SSLCLOSE =</span>
<span class="fc" id="L66">      new ChannelFutureListener() {</span>

        @Override
        public final void operationComplete(final ChannelFuture future) {
<span class="fc bfc" id="L70" title="All 2 branches covered.">          if (future.channel().isActive()) {</span>
<span class="fc" id="L71">            future.channel().eventLoop()</span>
<span class="fc" id="L72">                  .submit(new SslThread(future.channel()));</span>
          }
<span class="fc" id="L74">        }</span>
      };

  private WaarpSslUtility() {
  }

  /**
   * Add the Channel as SSL handshake will start soon
   *
   * @param channel
   */
  public static void addSslOpenedChannel(final Channel channel) {
<span class="fc" id="L86">    sslChannelGroup.add(channel);</span>
<span class="fc" id="L87">  }</span>

  /**
   * Add a SslHandler in a pipeline when the channel is already active
   *
   * @param future might be null, condition to start to add the
   *     handler to
   *     the pipeline
   * @param pipeline
   * @param sslHandler
   * @param listener action once the handshake is done
   */
  @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
  public static void addSslHandler(final ChannelFuture future,
                                   final ChannelPipeline pipeline,
                                   final ChannelHandler sslHandler,
                                   final GenericFutureListener&lt;? extends Future&lt;? super Channel&gt;&gt; listener) {
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">    if (future == null) {</span>
<span class="nc" id="L105">      logger.debug(&quot;Add SslHandler: {}&quot;, pipeline.channel());</span>
<span class="nc" id="L106">      pipeline.channel().config().setAutoRead(true);</span>
<span class="nc" id="L107">      pipeline.addFirst(&quot;SSL&quot;, sslHandler);</span>
<span class="nc" id="L108">      ((SslHandler) sslHandler).handshakeFuture().addListener(listener);</span>
    } else {
<span class="fc" id="L110">      future.addListener(new GenericFutureListener() {</span>
        @Override
        public final void operationComplete(final Future future) {
<span class="fc" id="L113">          logger.debug(&quot;Add SslHandler: {}&quot;, pipeline.channel());</span>
<span class="fc" id="L114">          pipeline.channel().config().setAutoRead(true);</span>
<span class="fc" id="L115">          pipeline.addFirst(&quot;SSL&quot;, sslHandler);</span>
<span class="fc" id="L116">          ((SslHandler) sslHandler).handshakeFuture().addListener(listener);</span>
<span class="fc" id="L117">        }</span>
      });
    }
<span class="fc" id="L120">    logger.debug(&quot;Checked Ssl Handler to be added: {}&quot;, pipeline.channel());</span>
<span class="fc" id="L121">  }</span>

  /**
   * Wait for the handshake on the given channel (better to use addSslHandler
   * when handler is added after
   * channel is active)
   *
   * @param channel
   *
   * @return True if the Handshake is done correctly
   */
  public static boolean waitForHandshake(final Channel channel) {
<span class="fc" id="L133">    final ChannelHandler handler = channel.pipeline().first();</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">    if (handler instanceof SslHandler) {</span>
<span class="fc" id="L135">      logger.debug(&quot;Start handshake SSL: {}&quot;, channel);</span>
<span class="fc" id="L136">      final SslHandler sslHandler = (SslHandler) handler;</span>
      // Get the SslHandler and begin handshake ASAP.
      // Get notified when SSL handshake is done.
<span class="fc" id="L139">      final Future&lt;Channel&gt; handshakeFuture = sslHandler.handshakeFuture();</span>
<span class="fc" id="L140">      WaarpNettyUtil.awaitOrInterrupted(handshakeFuture,</span>
<span class="fc" id="L141">                                        sslHandler.getHandshakeTimeoutMillis() +</span>
                                        1000);
<span class="fc" id="L143">      logger.debug(&quot;Handshake: {}:{}&quot;, handshakeFuture.isSuccess(), channel,</span>
<span class="fc" id="L144">                   handshakeFuture.cause());</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">      if (!handshakeFuture.isSuccess()) {</span>
<span class="nc" id="L146">        channel.close().awaitUninterruptibly(100);</span>
<span class="nc" id="L147">        return false;</span>
      }
<span class="fc" id="L149">    } else {</span>
<span class="nc" id="L150">      logger.info(&quot;SSL Not found but connected: {} {}&quot;,</span>
<span class="nc" id="L151">                  handler.getClass().getName());</span>
    }
<span class="fc" id="L153">    return true;</span>
  }

  /**
   * Waiting for the channel to be opened and ready (Client side) (blocking
   * call)
   *
   * @param future a future on connect only
   *
   * @return the channel if correctly associated, else return null
   */
  public static Channel waitforChannelReady(final ChannelFuture future) {
    // Wait until the connection attempt succeeds or fails.
<span class="fc" id="L166">    WaarpNettyUtil.awaitOrInterrupted(future);</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">    if (!future.isSuccess()) {</span>
<span class="nc" id="L168">      logger.error(&quot;Channel not connected&quot;, future.cause());</span>
<span class="nc" id="L169">      return null;</span>
    }
<span class="fc" id="L171">    final Channel channel = future.channel();</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">    if (waitForHandshake(channel)) {</span>
<span class="fc" id="L173">      return channel;</span>
    }
<span class="nc" id="L175">    return null;</span>
  }

  /**
   * Utility to force all channels to be closed
   */
  public static void forceCloseAllSslChannels() {
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">    if (SSL_EVENT_EXECUTOR.isShutdown()) {</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">      for (final Channel channel : sslChannelGroup) {</span>
<span class="nc" id="L184">        closingSslChannel(channel);</span>
<span class="nc" id="L185">      }</span>
<span class="nc" id="L186">      WaarpNettyUtil.awaitOrInterrupted(sslChannelGroup.close());</span>
<span class="nc" id="L187">      SSL_EVENT_EXECUTOR.shutdownGracefully();</span>
    }
<span class="fc" id="L189">  }</span>

  /**
   * Utility method to close a channel in SSL mode correctly (if any)
   *
   * @param channel
   */
  public static ChannelFuture closingSslChannel(final Channel channel) {
<span class="fc bfc" id="L197" title="All 2 branches covered.">    if (channel.isActive()) {</span>
<span class="fc" id="L198">      removingSslHandler(null, channel, true);</span>
<span class="fc" id="L199">      logger.debug(</span>
          &quot;Close the channel and returns the ChannelFuture: &quot; + channel);
<span class="fc" id="L201">      return channel.closeFuture();</span>
    }
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">    if (channel.closeFuture().isDone()) {</span>
<span class="fc" id="L204">      return channel.closeFuture();</span>
    }
<span class="nc" id="L206">    logger.debug(&quot;Already closed&quot;);</span>
<span class="nc" id="L207">    return channel.newSucceededFuture();</span>
  }

  /**
   * Remove the SslHandler (if any) cleanly
   *
   * @param future if not null, wait for this future to be done to
   *     removed
   *     the sslhandler
   * @param channel
   * @param close True to close the channel, else to only remove the SslHandler
   */
  @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
  public static void removingSslHandler(final ChannelFuture future,
                                        final Channel channel,
                                        final boolean close) {
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">    if (channel.isActive()) {</span>
<span class="fc" id="L224">      channel.config().setAutoRead(true);</span>
<span class="fc" id="L225">      final ChannelHandler handler = channel.pipeline().first();</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">      if (handler instanceof SslHandler) {</span>
<span class="fc" id="L227">        final SslHandler sslHandler = (SslHandler) handler;</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (future != null) {</span>
<span class="nc" id="L229">          future.addListener(new GenericFutureListener() {</span>
            @Override
            public final void operationComplete(final Future future) {
<span class="nc" id="L232">              waitForSslClose(channel, sslHandler, close);</span>
<span class="nc" id="L233">            }</span>
          });
        } else {
<span class="fc" id="L236">          waitForSslClose(channel, sslHandler, close);</span>
        }
<span class="fc" id="L238">      } else {</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">        if (close) {</span>
<span class="fc" id="L240">          channel.close();</span>
        }
      }
    }
<span class="fc" id="L244">  }</span>

  private static void waitForSslClose(final Channel channel,
                                      final SslHandler sslHandler,
                                      final boolean close) {
<span class="fc" id="L249">    logger.debug(&quot;Found SslHandler and wait for Ssl.closeOutbound() : {}&quot;,</span>
                 channel);
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">    if (channel.isActive()) {</span>
<span class="fc" id="L252">      sslHandler.closeOutbound()</span>
<span class="fc" id="L253">                .addListener(new GenericFutureListener&lt;Future&lt;? super Void&gt;&gt;() {</span>
                  @Override
                  public final void operationComplete(
                      final Future&lt;? super Void&gt; future) {
<span class="fc" id="L257">                    logger.debug(&quot;Ssl closed: {}&quot;, channel);</span>
<span class="fc" id="L258">                    channel.pipeline().remove(sslHandler);</span>
<span class="pc bpc" id="L259" title="2 of 4 branches missed.">                    if (close &amp;&amp; channel.isActive()) {</span>
<span class="fc" id="L260">                      channel.close();</span>
                    }
<span class="fc" id="L262">                  }</span>
                });
    }
<span class="fc" id="L265">  }</span>

  /**
   * Wait for the channel with SSL to be closed
   *
   * @param channel
   * @param delay
   *
   * @return True if an error occurs as an interruption
   */
  public static boolean waitForClosingSslChannel(final Channel channel,
                                                 final long delay) {
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">    if (!WaarpNettyUtil.awaitOrInterrupted(channel.closeFuture(), delay)) {</span>
      try {
<span class="nc" id="L279">        channel.pipeline().remove(SslHandler.class);</span>
<span class="nc" id="L280">        logger.debug(&quot;try to close anyway&quot;);</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (channel.isActive()) {</span>
<span class="nc" id="L282">          WaarpNettyUtil.awaitOrInterrupted(channel.close(), delay);</span>
        }
<span class="nc" id="L284">        return false;</span>
<span class="nc" id="L285">      } catch (final NoSuchElementException e) {</span>
        // ignore
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (channel.isActive()) {</span>
<span class="nc" id="L288">          WaarpNettyUtil.awaitOrInterrupted(channel.closeFuture(), delay);</span>
        }
      }
    }
<span class="fc" id="L292">    return true;</span>
  }

  /**
   * Thread used to ensure we are not in IO thread when waiting
   */
  private static class SslThread implements Runnable {
    private final Channel channel;

    /**
     * @param channel
     */
<span class="fc" id="L304">    private SslThread(final Channel channel) {</span>
<span class="fc" id="L305">      this.channel = channel;</span>
<span class="fc" id="L306">    }</span>

    @Override
    public void run() {
<span class="fc" id="L310">      closingSslChannel(channel);</span>
<span class="fc" id="L311">    }</span>

  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>