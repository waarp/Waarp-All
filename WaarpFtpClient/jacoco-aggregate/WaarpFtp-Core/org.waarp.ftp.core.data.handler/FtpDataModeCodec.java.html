<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FtpDataModeCodec.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Ftp R66 client</a> &gt; <a href="../index.html" class="el_bundle">WaarpFtp-Core</a> &gt; <a href="index.source.html" class="el_package">org.waarp.ftp.core.data.handler</a> &gt; <span class="el_source">FtpDataModeCodec.java</span></div><h1>FtpDataModeCodec.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.ftp.core.data.handler;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.ByteToMessageCodec;
import org.waarp.common.exception.InvalidArgumentException;
import org.waarp.common.file.DataBlock;
import org.waarp.common.future.WaarpFuture;
import org.waarp.ftp.core.command.FtpArgumentCode.TransferMode;
import org.waarp.ftp.core.command.FtpArgumentCode.TransferStructure;
import org.waarp.ftp.core.data.handler.FtpSeekAheadData.SeekAheadNoBackArrayException;

import java.util.List;

/**
 * First CODEC :&lt;br&gt;
 * - encode : takes a {@link DataBlock} and transforms it to a ByteBuf&lt;br&gt;
 * - decode : takes a ByteBuf and transforms it to a {@link DataBlock}&lt;br&gt;
 * STREAM and BLOCK mode are implemented. COMPRESSED mode is not implemented.
 */
public class FtpDataModeCodec extends ByteToMessageCodec&lt;DataBlock&gt; {
  /*
   * 3.4.1. STREAM MODE The data is transmitted as a stream of bytes. There is no restriction on the
   * representation type used; record structures are allowed. In a record structured file EOR and EOF will each
   * be indicated by a two-byte control code. The first byte of the control code will be all ones, the escape
   * character. The second byte will have the low order bit on and zeros elsewhere for EOR and the second low
   * order bit on for EOF; that is, the byte will have value 1 for EOR and value 2 for EOF. EOR and EOF may be
   * indicated together on the last byte transmitted by turning both low order bits on (i.e., the value 3). If a
   * byte of all ones was intended to be sent as data, it should be repeated in the second byte of the control
   * code. If the structure is a file structure, the EOF is indicated by the sending host closing the data
   * connection and all bytes are data bytes. 3.4.2. BLOCK MODE The file is transmitted as a series of data
   * blocks preceded by one or more header bytes. The header bytes contain a count field, and descriptor code.
   * The count field indicates the total length of the data block in bytes, thus marking the beginning of the
   * next data block (there are no filler bits). The descriptor code defines: last block in the file (EOF) last
   * block in the record (EOR), restart marker (see the Section on Error Recovery and Restart) or suspect data
   * (i.e., the data being transferred is suspected of errors and is not reliable). This last code is NOT
   * intended for error control within FTP. It is motivated by the desire of sites exchanging certain types of
   * data (e.g., seismic or weather data) to send and receive all the data despite local errors (such as
   * &quot;magnetic tape read errors&quot;), but to indicate in the transmission that certain portions are suspect).
   * Record structures are allowed in this mode, and any representation type may be used. The header consists of
   * the three bytes. Of the 24 bits of header information, the 16 low order bits shall represent byte count,
   * and the 8 high order bits shall represent descriptor codes as shown below. Block Header
   * +----------------+----------------+----------------+ | Descriptor | Byte Count | | 8 bits | 16 bits |
   * +----------------+----------------+----------------+ The descriptor codes are indicated by bit flags in the
   * descriptor byte. Four codes have been assigned, where each code number is the decimal value of the
   * corresponding bit in the byte. Code Meaning 128 End of data block is EOR 64 End of data block is EOF 32
   * Suspected errors in data block 16 Data block is a restart marker With this encoding, more than one
   * descriptor coded condition may exist for a particular block. As many bits as necessary may be flagged. The
   * restart marker is embedded in the data stream as an integral number of 8-bit bytes representing printable
   * characters in the language being used over the control connection (e.g., default--NVT-ASCII). &lt;SP&gt; (Space,
   * in the appropriate language) must not be used WITHIN a restart marker. For example, to transmit a
   * six-character marker, the following would be sent: +--------+--------+--------+ |Descrptr| Byte count |
   * |code= 16| = 6 | +--------+--------+--------+ +--------+--------+--------+ | Marker | Marker | Marker | | 8
   * bits | 8 bits | 8 bits | +--------+--------+--------+ +--------+--------+--------+ | Marker | Marker |
   * Marker | | 8 bits | 8 bits | 8 bits | +--------+--------+--------+
   */
  /**
   * Transfer Mode
   */
  private TransferMode mode;

  /**
   * Structure Mode
   */
  private TransferStructure structure;

  /**
   * Ftp Data Block
   */
  private DataBlock dataBlock;

  /**
   * Last byte for STREAM+RECORD
   */
  private int lastbyte;

  /**
   * Is the underlying DataNetworkHandler ready to receive block
   */
  private volatile boolean isReady;

  /**
   * Blocking step between DataNetworkHandler and this Codec in order to wait
   * that the DataNetworkHandler is
   * ready
   */
<span class="fc" id="L108">  private final WaarpFuture codecLocked = new WaarpFuture();</span>

  /**
   * @param mode
   * @param structure
   */
  public FtpDataModeCodec(final TransferMode mode,
<span class="fc" id="L115">                          final TransferStructure structure) {</span>
<span class="fc" id="L116">    this.mode = mode;</span>
<span class="fc" id="L117">    this.structure = structure;</span>
<span class="fc" id="L118">  }</span>

  /**
   * Inform the Codec that DataNetworkHandler is ready (called from
   * DataNetworkHandler after setCorrectCodec).
   */
  public void setCodecReady() {
<span class="fc" id="L125">    codecLocked.setSuccess();</span>
<span class="fc" id="L126">  }</span>

  protected DataBlock decodeRecordStandard(final ByteBuf buf,
                                           final int length) {
<span class="nc" id="L130">    final ByteBuf newbuf = ByteBufAllocator.DEFAULT.buffer(length, length);</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">    if (lastbyte == 0xFF) {</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">      if (readByteForDataBlock(buf, newbuf)) {</span>
<span class="nc" id="L133">        lastbyte = 0;</span>
      }
    }
    try {
<span class="nc bnc" id="L137" title="All 2 branches missed.">      while (buf.readableBytes() &gt; 0) {</span>
<span class="nc" id="L138">        lastbyte = buf.readUnsignedByte();</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">        if (lastbyte == 0xFF) {</span>
<span class="nc" id="L140">          readByteForDataBlock(buf, newbuf);</span>
        } else {
<span class="nc" id="L142">          newbuf.writeByte((byte) (lastbyte &amp; 0xFF));</span>
        }
<span class="nc" id="L144">        lastbyte = 0;</span>
      }
<span class="nc" id="L146">    } catch (final IndexOutOfBoundsException e) {</span>
      // End of read
<span class="nc" id="L148">    }</span>
<span class="nc" id="L149">    dataBlock.setBlock(newbuf);</span>
<span class="nc" id="L150">    return dataBlock;</span>
  }

  private boolean readByteForDataBlock(final ByteBuf buf,
                                       final ByteBuf newbuf) {
<span class="nc" id="L155">    final int nextbyte = buf.readUnsignedByte();</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">    if (nextbyte == 0xFF) {</span>
<span class="nc" id="L157">      newbuf.writeByte((byte) (lastbyte &amp; 0xFF));</span>
<span class="nc" id="L158">      return false;</span>
    } else {
<span class="nc bnc" id="L160" title="All 2 branches missed.">      if (nextbyte == 1) {</span>
<span class="nc" id="L161">        dataBlock.setEOR(true);</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">      } else if (nextbyte == 2) {</span>
<span class="nc" id="L163">        dataBlock.setEOF(true);</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">      } else if (nextbyte == 3) {</span>
<span class="nc" id="L165">        dataBlock.setEOR(true);</span>
<span class="nc" id="L166">        dataBlock.setEOF(true);</span>
      }
<span class="nc" id="L168">      return true;</span>
    }
  }

  protected DataBlock decodeRecord(final ByteBuf buf, final int length) {
    final FtpSeekAheadData sad;
    try {
<span class="nc" id="L175">      sad = new FtpSeekAheadData(buf);</span>
<span class="nc" id="L176">    } catch (final SeekAheadNoBackArrayException e1) {</span>
<span class="nc" id="L177">      return decodeRecordStandard(buf, length);</span>
<span class="nc" id="L178">    }</span>
<span class="nc" id="L179">    final ByteBuf newbuf = ByteBufAllocator.DEFAULT.buffer(length, length);</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">    if (lastbyte == 0xFF) {</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">      if (readBytesFromSad(sad, newbuf)) {</span>
<span class="nc" id="L182">        lastbyte = 0;</span>
      }
    }
    try {
<span class="nc bnc" id="L186" title="All 2 branches missed.">      while (sad.pos &lt; sad.limit) {</span>
<span class="nc" id="L187">        lastbyte = sad.bytes[sad.pos++] &amp; 0xFF;</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (lastbyte == 0xFF) {</span>
<span class="nc" id="L189">          readBytesFromSad(sad, newbuf);</span>
        } else {
<span class="nc" id="L191">          newbuf.writeByte((byte) (lastbyte &amp; 0xFF));</span>
        }
<span class="nc" id="L193">        lastbyte = 0;</span>
      }
<span class="nc" id="L195">    } catch (final IndexOutOfBoundsException e) {</span>
      // End of read
<span class="nc" id="L197">    }</span>
<span class="nc" id="L198">    sad.setReadPosition(0);</span>
<span class="nc" id="L199">    dataBlock.setBlock(newbuf);</span>
<span class="nc" id="L200">    return dataBlock;</span>
  }

  private boolean readBytesFromSad(final FtpSeekAheadData sad,
                                   final ByteBuf newbuf) {
<span class="nc" id="L205">    final int nextbyte = sad.bytes[sad.pos++] &amp; 0xFF;</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">    if (nextbyte == 0xFF) {</span>
<span class="nc" id="L207">      newbuf.writeByte((byte) (lastbyte &amp; 0xFF));</span>
<span class="nc" id="L208">      return false;</span>
    } else {
<span class="nc bnc" id="L210" title="All 2 branches missed.">      if (nextbyte == 1) {</span>
<span class="nc" id="L211">        dataBlock.setEOR(true);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">      } else if (nextbyte == 2) {</span>
<span class="nc" id="L213">        dataBlock.setEOF(true);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">      } else if (nextbyte == 3) {</span>
<span class="nc" id="L215">        dataBlock.setEOR(true);</span>
<span class="nc" id="L216">        dataBlock.setEOF(true);</span>
      }
<span class="nc" id="L218">      return true;</span>
    }
  }

  @Override
  protected void decode(final ChannelHandlerContext ctx, final ByteBuf buf,
                        final List&lt;Object&gt; out) throws Exception {
    // First test if the connection is fully ready (block might be
    // transferred
    // by client before connection is ready)
<span class="fc bfc" id="L228" title="All 2 branches covered.">    if (!isReady) {</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">      if (!codecLocked.awaitOrInterruptible()) {</span>
<span class="nc" id="L230">        throw new InvalidArgumentException(</span>
            &quot;Codec not unlocked while should be&quot;);
      }
<span class="fc" id="L233">      isReady = true;</span>
    }
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">    if (buf.readableBytes() == 0) {</span>
<span class="nc" id="L236">      return;</span>
    }
    // If STREAM Mode, no task to do, just next filter
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">    if (mode == TransferMode.STREAM) {</span>
<span class="fc" id="L240">      dataBlock = new DataBlock();</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">      if (structure != TransferStructure.RECORD) {</span>
<span class="fc" id="L242">        final ByteBuf newbuf = buf.slice();</span>
<span class="fc" id="L243">        buf.readerIndex(buf.readableBytes());</span>
<span class="fc" id="L244">        newbuf.retain();</span>
<span class="fc" id="L245">        dataBlock.setBlock(newbuf);</span>
<span class="fc" id="L246">        out.add(dataBlock);</span>
<span class="fc" id="L247">        return;</span>
      }
      // Except if RECORD Structure!
<span class="nc" id="L250">      final int length = buf.readableBytes();</span>
<span class="nc" id="L251">      out.add(decodeRecord(buf, length));</span>
<span class="nc" id="L252">      return;</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">    } else if (mode == TransferMode.BLOCK) {</span>
      // Now we are in BLOCK Mode
      // Make sure if the length field was received.
<span class="nc bnc" id="L256" title="All 2 branches missed.">      if (buf.readableBytes() &lt; 3) {</span>
        // The length field was not received yet - return null.
        // This method will be invoked again when more packets are
        // received and appended to the buffer.
<span class="nc" id="L260">        return;</span>
      }

      // The length field is in the buffer.

      // Mark the current buffer position before reading the length field
      // because the whole frame might not be in the buffer yet.
      // We will reset the buffer position to the marked position if
      // there's not enough bytes in the buffer.
<span class="nc" id="L269">      buf.markReaderIndex();</span>

<span class="nc bnc" id="L271" title="All 2 branches missed.">      if (dataBlock == null) {</span>
<span class="nc" id="L272">        dataBlock = new DataBlock();</span>
      }
      // Read the descriptor
<span class="nc" id="L275">      dataBlock.setDescriptor(buf.readByte());</span>

      // Read the length field.
<span class="nc" id="L278">      final byte upper = buf.readByte();</span>
<span class="nc" id="L279">      final byte lower = buf.readByte();</span>
<span class="nc" id="L280">      dataBlock.setByteCount(upper, lower);</span>

      // Make sure if there's enough bytes in the buffer.
<span class="nc bnc" id="L283" title="All 2 branches missed.">      if (buf.readableBytes() &lt; dataBlock.getByteCount()) {</span>
        // The whole bytes were not received yet - return null.
        // This method will be invoked again when more packets are
        // received and appended to the buffer.

        // Reset to the marked position to read the length field again
        // next time.
<span class="nc" id="L290">        buf.resetReaderIndex();</span>

<span class="nc" id="L292">        return;</span>
      }
<span class="nc bnc" id="L294" title="All 2 branches missed.">      if (dataBlock.getByteCount() &gt; 0) {</span>
        // There's enough bytes in the buffer. Read it.
<span class="nc" id="L296">        dataBlock.setBlock(buf.readBytes(dataBlock.getByteCount()));</span>
      }
<span class="nc" id="L298">      final DataBlock returnDataBlock = dataBlock;</span>
      // Free the datablock for next frame
<span class="nc" id="L300">      dataBlock = null;</span>
      // Successfully decoded a frame. Return the decoded frame.
<span class="nc" id="L302">      out.add(returnDataBlock);</span>
<span class="nc" id="L303">      return;</span>
    }
    // Type unimplemented
<span class="nc" id="L306">    throw new InvalidArgumentException(&quot;Mode unimplemented: &quot; + mode.name());</span>
  }

  protected ByteBuf encodeRecord(final DataBlock msg, final byte[] buffer) {
<span class="nc" id="L310">    final int size = msg.getByteCount();</span>
<span class="nc" id="L311">    final ByteBuf newbuf = ByteBufAllocator.DEFAULT.buffer(size, size);</span>
    int newbyte;
    try {
<span class="nc" id="L314">      int pos = 0;</span>
<span class="nc" id="L315">      final int limit = buffer.length;</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">      while (pos &lt; limit) {</span>
<span class="nc" id="L317">        newbyte = buffer[pos++] &amp; 0xFF;</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">        if (newbyte == 0xFF) {</span>
<span class="nc" id="L319">          newbuf.writeByte((byte) 0xFF);</span>
        }
<span class="nc" id="L321">        newbuf.writeByte((byte) (newbyte &amp; 0xFF));</span>
      }
<span class="nc" id="L323">    } catch (final IndexOutOfBoundsException e) {</span>
      // end of read
<span class="nc" id="L325">    }</span>
<span class="nc" id="L326">    int value = 0;</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">    if (msg.isEOF()) {</span>
<span class="nc" id="L328">      value += 2;</span>
    }
<span class="nc bnc" id="L330" title="All 2 branches missed.">    if (msg.isEOR()) {</span>
<span class="nc" id="L331">      value += 1;</span>
    }
<span class="nc bnc" id="L333" title="All 2 branches missed.">    if (value &gt; 0) {</span>
<span class="nc" id="L334">      newbuf.writeByte((byte) 0xFF);</span>
<span class="nc" id="L335">      newbuf.writeByte((byte) (value &amp; 0xFF));</span>
    }
<span class="nc" id="L337">    msg.clear();</span>
<span class="nc" id="L338">    return newbuf;</span>
  }

  /**
   * Encode a DataBlock in the correct format for Mode
   *
   * @param msg
   *
   * @return the ByteBuf or null when the last block is already done
   *
   * @throws InvalidArgumentException
   */
  protected ByteBuf encode(final DataBlock msg)
      throws InvalidArgumentException {
<span class="fc bfc" id="L352" title="All 2 branches covered.">    if (msg.isCleared()) {</span>
<span class="fc" id="L353">      return null;</span>
    }
<span class="fc" id="L355">    final byte[] bytes = msg.getByteBlock();</span>
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">    if (mode == TransferMode.STREAM) {</span>
      // If record structure, special attention
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">      if (structure == TransferStructure.RECORD) {</span>
<span class="nc" id="L359">        return encodeRecord(msg, bytes);</span>
      }
<span class="fc" id="L361">      msg.clear();</span>
<span class="fc" id="L362">      return Unpooled.wrappedBuffer(bytes);</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">    } else if (mode == TransferMode.BLOCK) {</span>
<span class="nc" id="L364">      int length = msg.getByteCount();</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">      final int size = length &gt; 0xFFFF? 0xFFFF + 3 : length + 3;</span>
<span class="nc" id="L366">      final ByteBuf newbuf = ByteBufAllocator.DEFAULT.buffer(size, size);</span>
<span class="nc" id="L367">      final byte[] header = { 0, 0, 0 };</span>
      // Is there any data left
<span class="nc bnc" id="L369" title="All 2 branches missed.">      if (length == 0) {</span>
        // It could be an empty block for EOR or EOF
<span class="nc bnc" id="L371" title="All 4 branches missed.">        if (msg.isEOF() || msg.isEOR()) {</span>
<span class="nc" id="L372">          header[0] = msg.getDescriptor();</span>
<span class="nc" id="L373">          header[1] = 0;</span>
<span class="nc" id="L374">          header[2] = 0;</span>
<span class="nc" id="L375">          newbuf.writeBytes(header);</span>
          // Next call will be the last one
<span class="nc" id="L377">          msg.clear();</span>
          // return the last block
<span class="nc" id="L379">          return newbuf;</span>
        }
        // This was the very last call
<span class="nc" id="L382">        msg.clear();</span>
        // return the end of encode
<span class="nc" id="L384">        return null;</span>
      }
      // Is this a Restart so only Markers
<span class="nc bnc" id="L387" title="All 2 branches missed.">      if (msg.isRESTART()) {</span>
<span class="nc" id="L388">        header[0] = msg.getDescriptor();</span>
<span class="nc" id="L389">        header[1] = msg.getByteCountUpper();</span>
<span class="nc" id="L390">        header[2] = msg.getByteCountLower();</span>
<span class="nc" id="L391">        newbuf.writeBytes(header);</span>
<span class="nc" id="L392">        newbuf.writeBytes(msg.getByteMarkers());</span>
        // Next call will be the last one
<span class="nc" id="L394">        msg.clear();</span>
        // return the last block
<span class="nc" id="L396">        return newbuf;</span>
      }
      // Work on sub block, ignoring descriptor since it is not the last
      // one
<span class="nc bnc" id="L400" title="All 2 branches missed.">      if (length &gt; 0xFFFF) {</span>
<span class="nc" id="L401">        header[0] = 0;</span>
<span class="nc" id="L402">        header[1] = (byte) 0xFF;</span>
<span class="nc" id="L403">        header[2] = (byte) 0xFF;</span>
<span class="nc" id="L404">        newbuf.writeBytes(header);</span>
        // Now take the first 0xFFFF bytes from buffer
<span class="nc" id="L406">        newbuf.writeBytes(bytes, msg.getOffset(), 0xFFFF);</span>
<span class="nc" id="L407">        msg.addOffset(0xFFFF);</span>
<span class="nc" id="L408">        length -= 0xFFFF;</span>
<span class="nc" id="L409">        msg.setByteCount(length);</span>
        // return the sub block
<span class="nc" id="L411">        return newbuf;</span>
      }
      // Last final block, using the descriptor
<span class="nc" id="L414">      header[0] = msg.getDescriptor();</span>
<span class="nc" id="L415">      header[1] = msg.getByteCountUpper();</span>
<span class="nc" id="L416">      header[2] = msg.getByteCountLower();</span>
<span class="nc" id="L417">      newbuf.writeBytes(header);</span>
      // real data
<span class="nc" id="L419">      newbuf.writeBytes(bytes, msg.getOffset(), length);</span>
      // Next call will be the last one
<span class="nc" id="L421">      msg.clear();</span>
      // return the last block
<span class="nc" id="L423">      return newbuf;</span>
    }
    // Mode unimplemented
<span class="nc" id="L426">    throw new InvalidArgumentException(&quot;Mode unimplemented: &quot; + mode.name());</span>
  }

  /**
   * @return the mode
   */
  public TransferMode getMode() {
<span class="nc" id="L433">    return mode;</span>
  }

  /**
   * @param mode the mode to set
   */
  public void setMode(final TransferMode mode) {
<span class="fc" id="L440">    this.mode = mode;</span>
<span class="fc" id="L441">  }</span>

  /**
   * @return the structure
   */
  public TransferStructure getStructure() {
<span class="nc" id="L447">    return structure;</span>
  }

  /**
   * @param structure the structure to set
   */
  public void setStructure(final TransferStructure structure) {
<span class="fc" id="L454">    this.structure = structure;</span>
<span class="fc" id="L455">  }</span>

  @Override
  protected void encode(final ChannelHandlerContext ctx, final DataBlock msg,
                        final ByteBuf out) throws Exception {
    // First test if the connection is fully ready (block might be
    // transfered
    // by client before connection is ready)
<span class="fc bfc" id="L463" title="All 2 branches covered.">    if (!isReady) {</span>
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">      if (!codecLocked.awaitOrInterruptible()) {</span>
<span class="nc" id="L465">        throw new InvalidArgumentException(</span>
            &quot;Codec not unlocked while should be&quot;);
      }
<span class="fc" id="L468">      isReady = true;</span>
    }
<span class="fc" id="L470">    ByteBuf next = encode(msg);</span>
    // Could be splitten in several block
<span class="fc bfc" id="L472" title="All 2 branches covered.">    while (next != null) {</span>
<span class="fc" id="L473">      out.writeBytes(next);</span>
<span class="fc" id="L474">      next = encode(msg);</span>
    }
<span class="fc" id="L476">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>