<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FilesystemBasedDigest.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Administrator</a> &gt; <a href="../index.html" class="el_bundle">WaarpDigest</a> &gt; <a href="index.source.html" class="el_package">org.waarp.common.digest</a> &gt; <span class="el_source">FilesystemBasedDigest.java</span></div><h1>FilesystemBasedDigest.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.common.digest;

import io.netty.buffer.ByteBuf;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.Charset;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.zip.Adler32;
import java.util.zip.CRC32;
import java.util.zip.Checksum;

import static org.waarp.common.digest.WaarpBC.*;

/**
 * Class implementing digest like MD5, SHA1. MD5 is based on the Fast MD5
 * implementation, without C library
 * support, but can be revert to JVM native digest.&lt;br&gt;
 * &lt;br&gt;
 * &lt;p&gt;
 * Some performance reports: (done using java -server option)
 * &lt;ul&gt;
 * &lt;li&gt;File based only:&lt;/li&gt;
 * &lt;ul&gt;
 * &lt;li&gt;FastMD5 in C is almost the fastest (+20%), while FastMD5 in Java is the
 * slowest (-20%) and JVM version
 * is in the middle.&lt;/li&gt;
 * &lt;li&gt;If ADLER32 is the referenced time ADLER32=1, CRC32=2.5, MD5=4, SHA1=7,
 * SHA256=11, SHA512=25&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;li&gt;Buffer based only:&lt;/li&gt;
 * &lt;ul&gt;
 * &lt;li&gt;JVM version is the fastest (+20%), while FastMD5 in C or in Java are the
 * same (-20% than JVM).&lt;/li&gt;
 * &lt;li&gt;If ADLER32 is the referenced time ADLER32=1, CRC32=2.5, MD5=4, SHA1=8,
 * SHA256=13, SHA384=29,
 * SHA512=31&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/ul&gt;
 */
public class FilesystemBasedDigest {

  private static final String ALGORITHM_NOT_SUPPORTED_BY_THIS_JVM =
      &quot; Algorithm not supported by this JVM&quot;;

  /**
   * Format used for Files
   */
<span class="fc" id="L75">  public static final Charset UTF8 = Charset.forName(&quot;UTF-8&quot;);</span>
<span class="fc" id="L76">  protected static final byte[] EMPTY = {};</span>
  public static final int ZERO_COPY_CHUNK_SIZE = 64 * 1024;

  static {
<span class="fc" id="L80">    initializedTlsContext();</span>
  }

  MD5 md5;
  Checksum checksum;
  MessageDigest digest;
  DigestAlgo algo;

  /**
   * Constructor of an independent Digest
   *
   * @param algo
   *
   * @throws NoSuchAlgorithmException
   */
  public FilesystemBasedDigest(final DigestAlgo algo)
<span class="fc" id="L96">      throws NoSuchAlgorithmException {</span>
<span class="fc" id="L97">    initialize(algo);</span>
<span class="fc" id="L98">  }</span>

  /**
   * (Re)Initialize the digest
   *
   * @throws NoSuchAlgorithmException
   */
  public void initialize() throws NoSuchAlgorithmException {
<span class="fc bfc" id="L106" title="All 4 branches covered.">    if (algo == DigestAlgo.MD5 &amp;&amp; isUseFastMd5()) {</span>
<span class="fc" id="L107">      md5 = new MD5();</span>
<span class="fc" id="L108">      return;</span>
    }
<span class="pc bpc" id="L110" title="1 of 4 branches missed.">    switch (algo) {</span>
      case ADLER32:
<span class="fc" id="L112">        checksum = new Adler32();</span>
<span class="fc" id="L113">        return;</span>
      case CRC32:
<span class="fc" id="L115">        checksum = new CRC32();</span>
<span class="fc" id="L116">        return;</span>
      case MD5:
      case MD2:
      case SHA1:
      case SHA256:
      case SHA384:
      case SHA512:
<span class="fc" id="L123">        final String algoname = algo.algoName;</span>
        try {
<span class="fc" id="L125">          digest = MessageDigest.getInstance(algoname);</span>
<span class="nc" id="L126">        } catch (final NoSuchAlgorithmException e) {</span>
<span class="nc" id="L127">          throw new NoSuchAlgorithmException(</span>
              algo + ALGORITHM_NOT_SUPPORTED_BY_THIS_JVM, e);
<span class="fc" id="L129">        }</span>
<span class="fc" id="L130">        return;</span>
      default:
<span class="nc" id="L132">        throw new NoSuchAlgorithmException(</span>
            algo.algoName + ALGORITHM_NOT_SUPPORTED_BY_THIS_JVM);
    }
  }

  /**
   * (Re)Initialize the digest
   *
   * @param algo
   *
   * @throws NoSuchAlgorithmException
   */
  public void initialize(final DigestAlgo algo)
      throws NoSuchAlgorithmException {
<span class="fc" id="L146">    this.algo = algo;</span>
<span class="fc" id="L147">    initialize();</span>
<span class="fc" id="L148">  }</span>

  public DigestAlgo getAlgo() {
<span class="nc" id="L151">    return algo;</span>
  }

  /**
   * Update the digest with new bytes
   *
   * @param bytes
   * @param offset
   * @param length
   */
  public void Update(final byte[] bytes, final int offset, final int length) {
<span class="fc bfc" id="L162" title="All 2 branches covered.">    if (md5 != null) {</span>
<span class="fc" id="L163">      md5.Update(bytes, offset, length);</span>
<span class="fc" id="L164">      return;</span>
    }
<span class="pc bpc" id="L166" title="1 of 3 branches missed.">    switch (algo) {</span>
      case ADLER32:
      case CRC32:
<span class="fc" id="L169">        checksum.update(bytes, offset, length);</span>
<span class="fc" id="L170">        return;</span>
      case MD5:
      case MD2:
      case SHA1:
      case SHA256:
      case SHA384:
      case SHA512:
<span class="fc" id="L177">        digest.update(bytes, offset, length);</span>
    }
<span class="fc" id="L179">  }</span>

  private byte[] reusableBytes;

  /**
   * One should call getOffset since offset within array could not 0
   *
   * @param buffer
   *
   * @return the array corresponding to this buffer (may be copied)
   */
  public final byte[] getBytes(final ByteBuf buffer) {
    final byte[] bytes;
<span class="fc" id="L192">    final int length = buffer.readableBytes();</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">    if (buffer.hasArray()) {</span>
<span class="fc" id="L194">      bytes = buffer.array();</span>
    } else {
<span class="nc bnc" id="L196" title="All 4 branches missed.">      if (reusableBytes == null || reusableBytes.length != length) {</span>
<span class="nc" id="L197">        reusableBytes = new byte[length];</span>
      }
<span class="nc" id="L199">      bytes = reusableBytes;</span>
<span class="nc" id="L200">      buffer.getBytes(buffer.readerIndex(), bytes, 0, length);</span>
    }
<span class="fc" id="L202">    return bytes;</span>
  }

  /**
   * @param buffer
   *
   * @return the offset for the getBytes array
   */
  public final int getOffset(final ByteBuf buffer) {
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">    if (buffer.hasArray()) {</span>
<span class="fc" id="L212">      return buffer.arrayOffset();</span>
    }
<span class="nc" id="L214">    return 0;</span>
  }

  /**
   * Update the digest with new buffer
   */
  public void Update(final ByteBuf buffer) {
<span class="fc" id="L221">    final byte[] bytes = getBytes(buffer);</span>
<span class="fc" id="L222">    final int start = getOffset(buffer);</span>
<span class="fc" id="L223">    final int length = buffer.readableBytes();</span>
<span class="fc" id="L224">    Update(bytes, start, length);</span>
<span class="fc" id="L225">  }</span>

  /**
   * Update the digest with new buffer
   */
  public void Update(final byte[] buffer) {
<span class="fc" id="L231">    Update(buffer, 0, buffer.length);</span>
<span class="fc" id="L232">  }</span>

  /**
   * @return the digest in array of bytes
   */
  public byte[] Final() {
<span class="fc bfc" id="L238" title="All 2 branches covered.">    if (md5 != null) {</span>
<span class="fc" id="L239">      return md5.Final();</span>
    }
<span class="pc bpc" id="L241" title="1 of 3 branches missed.">    switch (algo) {</span>
      case ADLER32:
      case CRC32:
<span class="fc" id="L244">        return Long.toOctalString(checksum.getValue()).getBytes(UTF8);</span>
      case MD5:
      case MD2:
      case SHA1:
      case SHA256:
      case SHA384:
      case SHA512:
<span class="fc" id="L251">        return digest.digest();</span>
    }
<span class="nc" id="L253">    return EMPTY;</span>
  }

  /**
   * Initialize the MD5 support
   *
   * @param mustUseFastMd5 True will use FastMD5 support, False will
   *     use JVM
   *     native MD5
   *
   * @return True if the native library is loaded
   */
  public static boolean initializeMd5(final boolean mustUseFastMd5) {
<span class="fc" id="L266">    setUseFastMd5(mustUseFastMd5);</span>
<span class="fc" id="L267">    return true;</span>
  }

  /**
   * @return the useFastMd5
   */
  public static boolean isUseFastMd5() {
<span class="fc" id="L274">    return useFastMd5;</span>
  }

  /**
   * @param useFastMd5 the useFastMd5 to set
   */
  public static void setUseFastMd5(final boolean useFastMd5) {
<span class="fc" id="L281">    FilesystemBasedDigest.useFastMd5 = useFastMd5;</span>
<span class="fc" id="L282">  }</span>

  /**
   * All Algo that Digest Class could handle
   */
<span class="fc" id="L287">  public enum DigestAlgo {</span>
<span class="fc" id="L288">    CRC32(&quot;CRC32&quot;, 11), ADLER32(&quot;ADLER32&quot;, 9), MD5(&quot;MD5&quot;, 16), MD2(&quot;MD2&quot;, 16),</span>
<span class="fc" id="L289">    SHA1(&quot;SHA-1&quot;, 20), SHA256(&quot;SHA-256&quot;, 32), SHA384(&quot;SHA-384&quot;, 48),</span>
<span class="fc" id="L290">    SHA512(&quot;SHA-512&quot;, 64);</span>

    public final String algoName;
    public final int byteSize;

    /**
     * @return the length in bytes of one Digest
     */
    public int getByteSize() {
<span class="fc" id="L299">      return byteSize;</span>
    }

    /**
     * @return the length in Hex form of one Digest
     */
    public int getHexSize() {
<span class="fc" id="L306">      return byteSize * 2;</span>
    }

<span class="fc" id="L309">    DigestAlgo(final String algoName, final int byteSize) {</span>
<span class="fc" id="L310">      this.algoName = algoName;</span>
<span class="fc" id="L311">      this.byteSize = byteSize;</span>
<span class="fc" id="L312">    }</span>

    public static DigestAlgo getFromName(final String name) {
      try {
<span class="nc" id="L316">        return valueOf(name);</span>
<span class="nc" id="L317">      } catch (final IllegalArgumentException ignore) {//NOSONAR</span>
        // ignore
      }
<span class="nc bnc" id="L320" title="All 2 branches missed.">      if (&quot;CRC32&quot;.equalsIgnoreCase(name)) {</span>
<span class="nc" id="L321">        return CRC32;</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">      } else if (&quot;ADLER32&quot;.equalsIgnoreCase(name)) {</span>
<span class="nc" id="L323">        return ADLER32;</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">      } else if (&quot;MD5&quot;.equalsIgnoreCase(name)) {</span>
<span class="nc" id="L325">        return MD5;</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">      } else if (&quot;MD2&quot;.equalsIgnoreCase(name)) {</span>
<span class="nc" id="L327">        return MD2;</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">      } else if (&quot;SHA-1&quot;.equalsIgnoreCase(name)) {</span>
<span class="nc" id="L329">        return SHA1;</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">      } else if (&quot;SHA-256&quot;.equalsIgnoreCase(name)) {</span>
<span class="nc" id="L331">        return SHA256;</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">      } else if (&quot;SHA-384&quot;.equalsIgnoreCase(name)) {</span>
<span class="nc" id="L333">        return SHA384;</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">      } else if (&quot;SHA-512&quot;.equalsIgnoreCase(name)) {</span>
<span class="nc" id="L335">        return SHA512;</span>
      } else {
<span class="nc" id="L337">        throw new IllegalArgumentException(&quot;Digest Algo not found&quot;);</span>
      }
    }
  }

  /**
   * Should a file MD5 be computed using FastMD5
   */
  private static boolean useFastMd5;

  /**
   * @param dig1
   * @param dig2
   *
   * @return True if the two digest are equals
   */
  public static final boolean digestEquals(final byte[] dig1,
                                           final byte[] dig2) {
<span class="fc" id="L355">    return MessageDigest.isEqual(dig1, dig2);</span>
  }

  /**
   * @param dig1
   * @param dig2
   *
   * @return True if the two digest are equals
   */
  public static final boolean digestEquals(final String dig1,
                                           final byte[] dig2) {
<span class="fc" id="L366">    final byte[] bdig1 = getFromHex(dig1);</span>
<span class="fc" id="L367">    return MessageDigest.isEqual(bdig1, dig2);</span>
  }

  /**
   * get the byte array of the MD5 for the given FileInterface using Nio
   * access
   *
   * @param f
   *
   * @return the byte array representing the MD5
   *
   * @throws IOException
   */
  public static byte[] getHashMd5Nio(final File f) throws IOException {
<span class="fc bfc" id="L381" title="All 2 branches covered.">    if (isUseFastMd5()) {</span>
<span class="fc" id="L382">      return MD5.getHashNio(f);</span>
    }
<span class="fc" id="L384">    return getHash(f, true, DigestAlgo.MD5);</span>
  }

  /**
   * get the byte array of the MD5 for the given FileInterface using standard
   * access
   *
   * @param f
   *
   * @return the byte array representing the MD5
   *
   * @throws IOException
   */
  public static byte[] getHashMd5(final File f) throws IOException {
<span class="fc bfc" id="L398" title="All 2 branches covered.">    if (isUseFastMd5()) {</span>
<span class="fc" id="L399">      return MD5.getHash(f);</span>
    }
<span class="fc" id="L401">    return getHash(f, false, DigestAlgo.MD5);</span>
  }

  /**
   * get the byte array of the SHA-1 for the given FileInterface using Nio
   * access
   *
   * @param f
   *
   * @return the byte array representing the SHA-1
   *
   * @throws IOException
   */
  public static byte[] getHashSha1Nio(final File f) throws IOException {
<span class="nc" id="L415">    return getHash(f, true, DigestAlgo.SHA1);</span>
  }

  /**
   * get the byte array of the SHA-1 for the given FileInterface using
   * standard
   * access
   *
   * @param f
   *
   * @return the byte array representing the SHA-1
   *
   * @throws IOException
   */
  public static byte[] getHashSha1(final File f) throws IOException {
<span class="nc" id="L430">    return getHash(f, false, DigestAlgo.SHA1);</span>
  }

  /**
   * Internal function for No NIO InputStream support
   *
   * @param in will be closed at the end of this call
   * @param algo
   * @param buf
   *
   * @return the digest
   *
   * @throws IOException
   */
  private static byte[] getHashNoNio(final InputStream in,
                                     final DigestAlgo algo, final byte[] buf)
      throws IOException {
    // Not NIO
<span class="fc" id="L448">    Checksum checksum = null;</span>
    int size;
    try {
<span class="pc bpc" id="L451" title="1 of 4 branches missed.">      switch (algo) {</span>
        case ADLER32:
<span class="fc" id="L453">          checksum = new Adler32();</span>
<span class="fc" id="L454">          return getBytesCrc(in, buf, checksum);</span>
        case CRC32:
<span class="fc" id="L456">          return getBytesCrc(in, buf, null);</span>
        case MD5:
        case MD2:
        case SHA1:
        case SHA256:
        case SHA384:
        case SHA512:
<span class="fc" id="L463">          final String algoname = algo.algoName;</span>
          final MessageDigest digest;
          try {
<span class="fc" id="L466">            digest = MessageDigest.getInstance(algoname);</span>
<span class="nc" id="L467">          } catch (final NoSuchAlgorithmException e) {</span>
<span class="nc" id="L468">            throw new IOException(algo + ALGORITHM_NOT_SUPPORTED_BY_THIS_JVM,</span>
                                  e);
<span class="fc" id="L470">          }</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">          while ((size = in.read(buf)) &gt;= 0) {</span>
<span class="fc" id="L472">            digest.update(buf, 0, size);</span>
          }
<span class="fc" id="L474">          return digest.digest();</span>
        default:
<span class="nc" id="L476">          throw new IOException(</span>
              algo.algoName + ALGORITHM_NOT_SUPPORTED_BY_THIS_JVM);
      }
    } finally {
<span class="fc" id="L480">      in.close();</span>
    }
  }

  private static byte[] getBytesCrc(final InputStream in, final byte[] buf,
                                    Checksum checksum) throws IOException {
    int size;
<span class="fc bfc" id="L487" title="All 2 branches covered.">    if (checksum == null) { // not ADLER32</span>
<span class="fc" id="L488">      checksum = new CRC32();</span>
    }
<span class="fc bfc" id="L490" title="All 2 branches covered.">    while ((size = in.read(buf)) &gt;= 0) {</span>
<span class="fc" id="L491">      checksum.update(buf, 0, size);</span>
    }
<span class="fc" id="L493">    return Long.toOctalString(checksum.getValue()).getBytes(UTF8);</span>
  }

  /**
   * Get the Digest for the file using the specified algorithm using access
   * through NIO or not
   *
   * @param f
   * @param nio
   * @param algo
   *
   * @return the digest
   *
   * @throws IOException
   */
  @SuppressWarnings(&quot;resource&quot;)
  public static byte[] getHash(final File f, final boolean nio,
                               final DigestAlgo algo) throws IOException {
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">    if (!f.exists()) {</span>
<span class="nc" id="L512">      throw new FileNotFoundException(f.toString());</span>
    }
<span class="fc bfc" id="L514" title="All 4 branches covered.">    if (algo == DigestAlgo.MD5 &amp;&amp; isUseFastMd5()) {</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">      if (nio) {</span>
<span class="fc" id="L516">        return MD5.getHashNio(f);</span>
      } else {
<span class="fc" id="L518">        return MD5.getHash(f);</span>
      }
    }
<span class="fc" id="L521">    FileInputStream in = null;</span>
    try {
<span class="fc" id="L523">      long bufSize = f.length();</span>
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">      if (bufSize == 0) {</span>
<span class="nc" id="L525">        return EMPTY;</span>
      }
<span class="fc bfc" id="L527" title="All 2 branches covered.">      if (bufSize &gt; ZERO_COPY_CHUNK_SIZE) {</span>
<span class="fc" id="L528">        bufSize = ZERO_COPY_CHUNK_SIZE;</span>
      }
<span class="fc" id="L530">      byte[] buf = new byte[(int) bufSize];</span>
<span class="fc" id="L531">      in = new FileInputStream(f);</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">      if (nio) { // NIO</span>
<span class="fc" id="L533">        final FileChannel fileChannel = in.getChannel();</span>
        try {
<span class="fc" id="L535">          final ByteBuffer bb = ByteBuffer.wrap(buf);</span>
<span class="fc" id="L536">          Checksum checksum = null;</span>
          int size;
<span class="pc bpc" id="L538" title="1 of 4 branches missed.">          switch (algo) {</span>
            case ADLER32:
<span class="fc" id="L540">              checksum = new Adler32();</span>
<span class="fc" id="L541">              buf = getBytesCrcFileChannel(buf, fileChannel, bb, checksum);</span>
<span class="fc" id="L542">              break;</span>
            case CRC32:
<span class="fc" id="L544">              buf = getBytesCrcFileChannel(buf, fileChannel, bb, null);</span>
<span class="fc" id="L545">              break;</span>
            case MD5:
            case MD2:
            case SHA1:
            case SHA256:
            case SHA384:
            case SHA512:
<span class="fc" id="L552">              final String algoname = algo.algoName;</span>
              final MessageDigest digest;
              try {
<span class="fc" id="L555">                digest = MessageDigest.getInstance(algoname);</span>
<span class="nc" id="L556">              } catch (final NoSuchAlgorithmException e) {</span>
<span class="nc" id="L557">                throw new IOException(</span>
                    algo + ALGORITHM_NOT_SUPPORTED_BY_THIS_JVM, e);
<span class="fc" id="L559">              }</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">              while ((size = fileChannel.read(bb)) &gt;= 0) {</span>
<span class="fc" id="L561">                digest.update(buf, 0, size);</span>
<span class="fc" id="L562">                bb.clear();</span>
              }
<span class="fc" id="L564">              buf = digest.digest();</span>
<span class="fc" id="L565">              break;</span>
            default:
<span class="nc" id="L567">              throw new IOException(</span>
                  algo.algoName + ALGORITHM_NOT_SUPPORTED_BY_THIS_JVM);
          }
        } finally {
<span class="fc" id="L571">          fileChannel.close();</span>
        }
<span class="fc" id="L573">      } else { // Not NIO</span>
<span class="fc" id="L574">        return getHashNoNio(in, algo, buf);</span>
      }
<span class="fc" id="L576">      return buf;</span>
    } finally {
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">      if (in != null) {</span>
        try {
<span class="fc" id="L580">          in.close();</span>
<span class="nc" id="L581">        } catch (final Exception ignored) {</span>
          // nothing
<span class="fc" id="L583">        }</span>
      }
    }
  }

  private static byte[] getBytesCrcFileChannel(final byte[] buf,
                                               final FileChannel fileChannel,
                                               final ByteBuffer bb,
                                               Checksum checksum)
      throws IOException {
    int size;
<span class="fc bfc" id="L594" title="All 2 branches covered.">    if (checksum == null) { // Not ADLER32</span>
<span class="fc" id="L595">      checksum = new CRC32();</span>
    }
<span class="fc bfc" id="L597" title="All 2 branches covered.">    while ((size = fileChannel.read(bb)) &gt;= 0) {</span>
<span class="fc" id="L598">      checksum.update(buf, 0, size);</span>
<span class="fc" id="L599">      bb.clear();</span>
    }
<span class="fc" id="L601">    return Long.toOctalString(checksum.getValue()).getBytes(UTF8);</span>
  }

  /**
   * Get the Digest for the file using the specified algorithm using access
   * through NIO or not
   *
   * @param stream will be closed at the end of this call
   * @param algo
   *
   * @return the digest
   *
   * @throws IOException
   */
  public static byte[] getHash(final InputStream stream, final DigestAlgo algo)
      throws IOException {
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">    if (stream == null) {</span>
<span class="nc" id="L618">      throw new FileNotFoundException();</span>
    }
<span class="fc bfc" id="L620" title="All 4 branches covered.">    if (algo == DigestAlgo.MD5 &amp;&amp; isUseFastMd5()) {</span>
<span class="fc" id="L621">      return MD5.getHash(stream);</span>
    }
    try {
<span class="fc" id="L624">      final byte[] buf = new byte[ZERO_COPY_CHUNK_SIZE];</span>
      // Not NIO
<span class="fc" id="L626">      return getHashNoNio(stream, algo, buf);</span>
<span class="nc" id="L627">    } catch (final IOException e) {</span>
      try {
<span class="nc" id="L629">        stream.close();</span>
<span class="nc" id="L630">      } catch (final Exception ignored) {</span>
        // nothing
<span class="nc" id="L632">      }</span>
<span class="nc" id="L633">      throw e;</span>
    }
  }

  /**
   * Get hash with given {@link ByteBuf} (from Netty)
   *
   * @param buffer this buffer will not be changed
   * @param algo
   *
   * @return the hash
   *
   * @throws IOException
   */
  public static byte[] getHash(final ByteBuf buffer, final DigestAlgo algo)
      throws IOException {
<span class="fc" id="L649">    Checksum checksum = null;</span>
    byte[] bytes;
<span class="fc" id="L651">    int start = 0;</span>
<span class="fc" id="L652">    final int length = buffer.readableBytes();</span>
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">    if (buffer.hasArray()) {</span>
<span class="fc" id="L654">      start = buffer.arrayOffset();</span>
<span class="fc" id="L655">      bytes = buffer.array();</span>
    } else {
<span class="nc" id="L657">      bytes = new byte[length];</span>
<span class="nc" id="L658">      buffer.getBytes(buffer.readerIndex(), bytes);</span>
    }
<span class="pc bpc" id="L660" title="1 of 5 branches missed.">    switch (algo) {</span>
      case ADLER32:
<span class="fc" id="L662">        checksum = new Adler32();</span>
<span class="fc" id="L663">        return getBytesCrcByteBuf(checksum, bytes, start, length);</span>
      case CRC32:
<span class="fc" id="L665">        return getBytesCrcByteBuf(null, bytes, start, length);</span>
      case MD5:
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">        if (isUseFastMd5()) {</span>
<span class="nc" id="L668">          final MD5 md5 = new MD5();</span>
<span class="nc" id="L669">          md5.Update(bytes, start, length);</span>
<span class="nc" id="L670">          bytes = md5.Final();</span>
<span class="nc" id="L671">          return bytes;</span>
        }
<span class="fc" id="L673">        return getBytesVarious(algo, bytes, start, length);</span>
      case MD2:
      case SHA1:
      case SHA256:
      case SHA384:
      case SHA512:
<span class="fc" id="L679">        return getBytesVarious(algo, bytes, start, length);</span>
      default:
<span class="nc" id="L681">        throw new IOException(</span>
            algo.algoName + ALGORITHM_NOT_SUPPORTED_BY_THIS_JVM);
    }
  }

  /**
   * Get hash with given byte array
   *
   * @param buffer this buffer will not be changed
   * @param algo
   *
   * @return the hash
   *
   * @throws IOException
   */
  public static byte[] getHash(final byte[] buffer, final DigestAlgo algo)
      throws IOException {
<span class="fc" id="L698">    Checksum checksum = null;</span>
<span class="fc" id="L699">    final int length = buffer.length;</span>
<span class="pc bpc" id="L700" title="4 of 5 branches missed.">    switch (algo) {</span>
      case ADLER32:
<span class="nc" id="L702">        checksum = new Adler32();</span>
<span class="nc" id="L703">        return getBytesCrcByteBuf(checksum, buffer, 0, length);</span>
      case CRC32:
<span class="nc" id="L705">        return getBytesCrcByteBuf(null, buffer, 0, length);</span>
      case MD5:
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">        if (isUseFastMd5()) {</span>
<span class="nc" id="L708">          final MD5 md5 = new MD5();</span>
<span class="nc" id="L709">          md5.Update(buffer, 0, length);</span>
<span class="nc" id="L710">          return md5.Final();</span>
        }
<span class="fc" id="L712">        return getBytesVarious(algo, buffer, 0, length);</span>
      case MD2:
      case SHA1:
      case SHA256:
      case SHA384:
      case SHA512:
<span class="nc" id="L718">        return getBytesVarious(algo, buffer, 0, length);</span>
      default:
<span class="nc" id="L720">        throw new IOException(</span>
            algo.algoName + ALGORITHM_NOT_SUPPORTED_BY_THIS_JVM);
    }
  }

  private static byte[] getBytesVarious(final DigestAlgo algo,
                                        final byte[] bytes, final int start,
                                        final int length) throws IOException {
<span class="fc" id="L728">    final String algoname = algo.algoName;</span>
    final MessageDigest digest;
    try {
<span class="fc" id="L731">      digest = MessageDigest.getInstance(algoname);</span>
<span class="nc" id="L732">    } catch (final NoSuchAlgorithmException e) {</span>
<span class="nc" id="L733">      throw new IOException(algoname + ALGORITHM_NOT_SUPPORTED_BY_THIS_JVM, e);</span>
<span class="fc" id="L734">    }</span>
<span class="fc" id="L735">    digest.update(bytes, start, length);</span>
<span class="fc" id="L736">    return digest.digest();</span>
  }

  private static byte[] getBytesCrcByteBuf(Checksum checksum,
                                           final byte[] bytes, final int start,
                                           final int length) {
<span class="fc bfc" id="L742" title="All 2 branches covered.">    if (checksum == null) { // not ADLER32</span>
<span class="fc" id="L743">      checksum = new CRC32();</span>
    }
<span class="fc" id="L745">    checksum.update(bytes, start, length);</span>
<span class="fc" id="L746">    return Long.toOctalString(checksum.getValue()).getBytes(UTF8);</span>
  }

  /**
   * Get hash with given {@link ByteBuf} (from Netty)
   *
   * @param buffer ByteBuf to use to get the hash and this buffer will
   *     not
   *     be changed
   *
   * @return the hash
   */
  public static byte[] getHashMd5(final ByteBuf buffer) {
    try {
<span class="fc" id="L760">      return getHash(buffer, DigestAlgo.MD5);</span>
<span class="nc" id="L761">    } catch (final IOException e) {</span>
<span class="nc" id="L762">      final MD5 md5 = new MD5();</span>
<span class="nc" id="L763">      md5.Update(buffer);</span>
<span class="nc" id="L764">      return md5.Final();</span>
    }
  }

  /**
   * Internal representation of Hexadecimal Code
   */
<span class="fc" id="L771">  private static final char[] HEX_CHARS = {</span>
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e',
      'f',
  };

  /**
   * Get the hexadecimal representation as a String of the array of bytes
   *
   * @param hash
   *
   * @return the hexadecimal representation as a String of the array of bytes
   */
  public static final String getHex(final byte[] hash) {
<span class="fc" id="L784">    final char[] buf = new char[hash.length * 2];</span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">    for (int i = 0, x = 0; i &lt; hash.length; i++) {</span>
<span class="fc" id="L786">      buf[x++] = HEX_CHARS[hash[i] &gt;&gt;&gt; 4 &amp; 0xf];</span>
<span class="fc" id="L787">      buf[x++] = HEX_CHARS[hash[i] &amp; 0xf];</span>
    }
<span class="fc" id="L789">    return new String(buf);</span>
  }

  /**
   * Get the array of bytes representation of the hexadecimal String
   *
   * @param hex
   *
   * @return the array of bytes representation of the hexadecimal String
   */
  public static final byte[] getFromHex(final String hex) {
<span class="fc" id="L800">    final byte[] from = hex.getBytes(UTF8);</span>
<span class="fc" id="L801">    final byte[] hash = new byte[from.length / 2];</span>
<span class="fc bfc" id="L802" title="All 2 branches covered.">    for (int i = 0, x = 0; i &lt; hash.length; i++) {</span>
<span class="fc" id="L803">      byte code1 = from[x++];</span>
<span class="fc" id="L804">      byte code2 = from[x++];</span>
<span class="fc bfc" id="L805" title="All 2 branches covered.">      if (code1 &gt;= HEX_CHARS[10]) {</span>
<span class="fc" id="L806">        code1 -= HEX_CHARS[10] - 10;</span>
      } else {
<span class="fc" id="L808">        code1 -= HEX_CHARS[0];</span>
      }
<span class="fc bfc" id="L810" title="All 2 branches covered.">      if (code2 &gt;= HEX_CHARS[10]) {</span>
<span class="fc" id="L811">        code2 -= HEX_CHARS[10] - 10;</span>
      } else {
<span class="fc" id="L813">        code2 -= HEX_CHARS[0];</span>
      }
<span class="fc" id="L815">      hash[i] = (byte) ((code1 &lt;&lt; 4) + (code2 &amp; 0xFF));</span>
    }
<span class="fc" id="L817">    return hash;</span>
  }

<span class="fc" id="L820">  private static final byte[] salt =</span>
      { 'G', 'o', 'l', 'd', 'e', 'n', 'G', 'a', 't', 'e' };

  /**
   * Crypt a password
   *
   * @param pwd to crypt
   *
   * @return the crypted password
   *
   * @throws IOException
   */
  public static final String passwdCrypt(final String pwd) {
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">    if (isUseFastMd5()) {</span>
<span class="nc" id="L834">      return MD5.passwdCrypt(pwd);</span>
    }
    final MessageDigest digest;
    try {
<span class="fc" id="L838">      digest = MessageDigest.getInstance(DigestAlgo.MD5.algoName);</span>
<span class="nc" id="L839">    } catch (final NoSuchAlgorithmException e) {</span>
<span class="nc" id="L840">      return MD5.passwdCrypt(pwd);</span>
<span class="fc" id="L841">    }</span>
<span class="fc" id="L842">    final byte[] bpwd = pwd.getBytes(UTF8);</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">    for (int i = 0; i &lt; 16; i++) {</span>
<span class="fc" id="L844">      digest.update(bpwd, 0, bpwd.length);</span>
<span class="fc" id="L845">      digest.update(salt, 0, salt.length);</span>
    }
<span class="fc" id="L847">    return getHex(digest.digest());</span>
  }

  /**
   * Crypt a password
   *
   * @param pwd to crypt
   *
   * @return the crypted password
   *
   * @throws IOException
   */
  public static final byte[] passwdCrypt(final byte[] pwd) {
<span class="pc bpc" id="L860" title="1 of 2 branches missed.">    if (isUseFastMd5()) {</span>
<span class="nc" id="L861">      return MD5.passwdCrypt(pwd);</span>
    }
    final MessageDigest digest;
    try {
<span class="fc" id="L865">      digest = MessageDigest.getInstance(DigestAlgo.MD5.algoName);</span>
<span class="nc" id="L866">    } catch (final NoSuchAlgorithmException e) {</span>
<span class="nc" id="L867">      return MD5.passwdCrypt(pwd);</span>
<span class="fc" id="L868">    }</span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">    for (int i = 0; i &lt; 16; i++) {</span>
<span class="fc" id="L870">      digest.update(pwd, 0, pwd.length);</span>
<span class="fc" id="L871">      digest.update(salt, 0, salt.length);</span>
    }
<span class="fc" id="L873">    return digest.digest();</span>
  }

  /**
   * @param pwd
   * @param cryptPwd
   *
   * @return True if the pwd is comparable with the cryptPwd
   *
   * @throws IOException
   */
  public static final boolean equalPasswd(final String pwd,
                                          final String cryptPwd) {
    final String asHex;
<span class="fc" id="L887">    asHex = passwdCrypt(pwd);</span>
<span class="fc" id="L888">    return cryptPwd.equals(asHex);</span>
  }

  /**
   * @param pwd
   * @param cryptPwd
   *
   * @return True if the pwd is comparable with the cryptPwd
   */
  public static final boolean equalPasswd(final byte[] pwd,
                                          final byte[] cryptPwd) {
    final byte[] bytes;
<span class="fc" id="L900">    bytes = passwdCrypt(pwd);</span>
<span class="fc" id="L901">    return Arrays.equals(cryptPwd, bytes);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>