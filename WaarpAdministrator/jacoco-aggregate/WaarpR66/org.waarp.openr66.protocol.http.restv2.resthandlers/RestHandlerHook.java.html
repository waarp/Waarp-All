<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RestHandlerHook.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Administrator</a> &gt; <a href="../index.html" class="el_bundle">WaarpR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.protocol.http.restv2.resthandlers</a> &gt; <span class="el_source">RestHandlerHook.java</span></div><h1>RestHandlerHook.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package org.waarp.openr66.protocol.http.restv2.resthandlers;

import io.cdap.http.HandlerHook;
import io.cdap.http.HttpResponder;
import io.cdap.http.internal.HandlerInfo;
import io.netty.handler.codec.http.DefaultHttpHeaders;
import io.netty.handler.codec.http.HttpRequest;
import io.netty.handler.codec.http.HttpResponseStatus;
import org.joda.time.DateTime;
import org.waarp.common.crypto.HmacSha256;
import org.waarp.common.database.exception.WaarpDatabaseException;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.role.RoleDefault;
import org.waarp.common.role.RoleDefault.ROLE;
import org.waarp.common.utility.BaseXx;
import org.waarp.openr66.dao.DAOFactory;
import org.waarp.openr66.dao.HostDAO;
import org.waarp.openr66.dao.exception.DAOConnectionException;
import org.waarp.openr66.dao.exception.DAONoDataException;
import org.waarp.openr66.database.data.DbHostAuth;
import org.waarp.openr66.pojo.Host;
import org.waarp.openr66.protocol.http.restv2.RestServiceInitializer;
import org.waarp.openr66.protocol.http.restv2.converters.HostConfigConverter;
import org.waarp.openr66.protocol.http.restv2.dbhandlers.AbstractRestDbHandler;
import org.waarp.openr66.protocol.http.restv2.dbhandlers.RequiredRole;

import javax.ws.rs.Consumes;
import javax.ws.rs.InternalServerErrorException;
import javax.ws.rs.NotAllowedException;
import javax.ws.rs.core.MediaType;
import java.lang.reflect.Method;
import java.text.ParseException;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static io.netty.handler.codec.http.HttpMethod.*;
import static io.netty.handler.codec.http.HttpResponseStatus.*;
import static javax.ws.rs.core.HttpHeaders.*;
import static javax.ws.rs.core.MediaType.*;
import static org.glassfish.jersey.message.internal.HttpHeaderReader.*;
import static org.glassfish.jersey.message.internal.MediaTypes.*;
import static org.waarp.common.role.RoleDefault.ROLE.*;
import static org.waarp.openr66.protocol.configuration.Configuration.*;
import static org.waarp.openr66.protocol.http.restv2.RestConstants.*;

/**
 * This class defines hooks called before and after the corresponding {@link
 * AbstractRestDbHandler} when a
 * request is made. These hooks check the user authentication and privileges, as
 * well as the request content
 * type.
 */
public class RestHandlerHook implements HandlerHook {

  /**
   * Tells if the REST request authentication is activated.
   */
  private final boolean authenticated;

  /**
   * Stores the key used for HMAC authentication.
   */
  private final HmacSha256 hmac;

  /**
   * The time (in ms) for which a HMAC signed request is valid.
   */
  private final long delay;

  /**
   * The logger for all events.
   */
<span class="nc" id="L96">  private static final WaarpLogger logger =</span>
<span class="nc" id="L97">      WaarpLoggerFactory.getLogger(RestHandlerHook.class);</span>

  /**
   * Hook called before a request handler is called. Checks if the REST method
   * is active in the CRUD
   * configuration, checks the request's content type, and finally checks the
   * user authentication (if
   * activated).
   *
   * @param request the HttpRequest currently being processed
   * @param responder the HttpResponder sending the response
   * @param handlerInfo the information about the handler to which the
   *     request will be sent for processing
   *
   * @return {@code true} if the request can be handed to the handler, or
   *     {@code false} if an error occurred and
   *     a response must be sent immediately.
   */
  @Override
  public boolean preCall(HttpRequest request, HttpResponder responder,
                         HandlerInfo handlerInfo) {

    try {
<span class="nc" id="L120">      final AbstractRestDbHandler handler = getHandler(handlerInfo);</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">      if (!handler.checkCRUD(request)) {</span>
<span class="nc" id="L122">        responder.sendStatus(METHOD_NOT_ALLOWED);</span>
<span class="nc" id="L123">        return false;</span>
      }

<span class="nc" id="L126">      final Method handleMethod = getMethod(handler, handlerInfo);</span>
<span class="nc bnc" id="L127" title="All 4 branches missed.">      if (authenticated &amp;&amp; !request.method().equals(OPTIONS)) {</span>
<span class="nc" id="L128">        final String user = checkCredentials(request);</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (!checkAuthorization(user, handleMethod)) {</span>
<span class="nc" id="L130">          responder.sendStatus(FORBIDDEN);</span>
<span class="nc" id="L131">          return false;</span>
        }
      }

<span class="nc" id="L135">      final List&lt;MediaType&gt; expectedTypes = getExpectedMediaTypes(handleMethod);</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">      if (!checkContentType(request, expectedTypes)) {</span>
<span class="nc" id="L137">        final DefaultHttpHeaders headers = new DefaultHttpHeaders();</span>
<span class="nc" id="L138">        headers.add(ACCEPT, convertToString(expectedTypes));</span>
<span class="nc" id="L139">        responder.sendStatus(UNSUPPORTED_MEDIA_TYPE, headers);</span>
<span class="nc" id="L140">        return false;</span>
      }

<span class="nc" id="L143">      return true;</span>
<span class="nc" id="L144">    } catch (final NotAllowedException e) {</span>
<span class="nc" id="L145">      logger.info(e.getMessage());</span>
<span class="nc" id="L146">      final DefaultHttpHeaders headers = new DefaultHttpHeaders();</span>
<span class="nc" id="L147">      headers.add(WWW_AUTHENTICATE, &quot;Basic, HMAC&quot;);</span>
<span class="nc" id="L148">      responder.sendStatus(UNAUTHORIZED, headers);</span>
<span class="nc" id="L149">    } catch (final InternalServerErrorException e) {</span>
<span class="nc" id="L150">      logger.error(e);</span>
<span class="nc" id="L151">      responder.sendStatus(INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L152">    } catch (final Throwable t) {</span>
<span class="nc" id="L153">      logger.error(&quot;RESTv2 Unexpected exception caught -&gt;&quot;, t);</span>
<span class="nc" id="L154">      responder.sendStatus(INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L155">    }</span>
<span class="nc" id="L156">    return false;</span>
  }

  /**
   * Returns the {@link AbstractRestDbHandler} instance corresponding to the
   * info given as parameter.
   *
   * @param handlerInfo the information about the handler
   *
   * @return the corresponding AbstractRestDbHandler
   *
   * @throws IllegalArgumentException if the given handler does not
   *     exist.
   */
  private AbstractRestDbHandler getHandler(HandlerInfo handlerInfo) {
<span class="nc bnc" id="L171" title="All 2 branches missed.">    for (final AbstractRestDbHandler h : RestServiceInitializer.handlers) {</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">      if (h.getClass().getName().equals(handlerInfo.getHandlerName())) {</span>
<span class="nc" id="L173">        return h;</span>
      }
<span class="nc" id="L175">    }</span>
<span class="nc" id="L176">    throw new IllegalArgumentException(</span>
<span class="nc" id="L177">        &quot;The handler &quot; + handlerInfo.getHandlerName() + &quot; does not exist.&quot;);</span>
  }

  /**
   * Returns the {@link Method} object corresponding to the handler method
   * chosen to process the request. This
   * is needed to check for the annotations present on the method.
   *
   * @param handler the handler chosen to process the request
   * @param handlerInfo the information about the handler
   *
   * @return the corresponding Method object
   *
   * @throws IllegalArgumentException if the given method name does
   *     not exist
   */
  private Method getMethod(AbstractRestDbHandler handler,
                           HandlerInfo handlerInfo) {
<span class="nc" id="L195">    Method method = null;</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">    for (final Method m : handler.getClass().getMethods()) {//NOSONAR</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">      if (m.getName().equals(handlerInfo.getMethodName()) &amp;&amp;</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">          m.getParameterTypes()[0] == HttpRequest.class &amp;&amp;</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">          m.getParameterTypes()[1] == HttpResponder.class) {</span>
<span class="nc" id="L200">        method = m;</span>
<span class="nc" id="L201">        break;</span>
      }
    }
<span class="nc bnc" id="L204" title="All 2 branches missed.">    if (method == null) {</span>
<span class="nc" id="L205">      throw new IllegalArgumentException(</span>
<span class="nc" id="L206">          &quot;The handler &quot; + handlerInfo.getHandlerName() +</span>
<span class="nc" id="L207">          &quot; does not have a method &quot; + handlerInfo.getMethodName());</span>
    }
<span class="nc" id="L209">    return method;</span>
  }

  /**
   * Return a List of all the {@link MediaType} accepted by the given {@link
   * Method}. This list is based on the
   * types indicated by the method's {@link Consumes} annotation. If the
   * annotation is absent, the method will
   * be assumed to accept any type.
   *
   * @param method the Method to inspect
   *
   * @return the list of all acceptable MediaType
   */
  private List&lt;MediaType&gt; getExpectedMediaTypes(Method method) {
<span class="nc" id="L224">    List&lt;MediaType&gt; consumedTypes = WILDCARD_TYPE_SINGLETON_LIST;</span>

<span class="nc bnc" id="L226" title="All 2 branches missed.">    if (method.isAnnotationPresent(Consumes.class)) {</span>
<span class="nc" id="L227">      consumedTypes = createFrom(method.getAnnotation(Consumes.class));</span>
    } else {
<span class="nc" id="L229">      logger.warn(String.format(</span>
          &quot;[RESTv2] The method %s of handler %s is missing &quot; +
          &quot;a '%s' annotation for the expected request content type, &quot; +
<span class="nc" id="L232">          &quot;the default value '%s' was given instead.&quot;, method.getName(),</span>
<span class="nc" id="L233">          method.getDeclaringClass().getSimpleName(),</span>
<span class="nc" id="L234">          Consumes.class.getSimpleName(), WILDCARD));</span>
    }

<span class="nc" id="L237">    return consumedTypes;</span>
  }

  /**
   * Checks if the content type of the request is compatible with the expected
   * content type of the method
   * called. If no content type header can be found, the request will be
   * assumed to have a correct content type.
   *
   * @param request the HttpRequest sent by the user
   * @param consumedTypes a list of the acceptable MediaType for the
   *     request
   *
   * @return {@code true} if the request content type is acceptable, {@code
   *     false} otherwise.
   */
  private boolean checkContentType(HttpRequest request,
                                   List&lt;MediaType&gt; consumedTypes) {

<span class="nc" id="L256">    final String contentTypeHeader = request.headers().get(CONTENT_TYPE);</span>
<span class="nc bnc" id="L257" title="All 4 branches missed.">    if (contentTypeHeader == null || contentTypeHeader.isEmpty()) {</span>
<span class="nc" id="L258">      return true;</span>
    }

    MediaType requestType;
    try {
<span class="nc" id="L263">      requestType = readAcceptMediaType(contentTypeHeader).get(0);</span>
<span class="nc" id="L264">    } catch (final ParseException e) {</span>
<span class="nc" id="L265">      return false;</span>
<span class="nc" id="L266">    }</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">    for (final MediaType consumedType : consumedTypes) {</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">      if (requestType.isCompatible(consumedType)) {</span>
<span class="nc" id="L269">        return true;</span>
      }
<span class="nc" id="L271">    }</span>
<span class="nc" id="L272">    return false;</span>
  }

  /**
   * Checks if the user making the request does exist. If the user does exist,
   * this method returns the user's
   * name, otherwise throws a {@link NotAllowedException}.
   *
   * @param request the request currently being processed
   *
   * @return the user's name
   *
   * @throws InternalServerErrorException if an unexpected error
   *     occurred
   * @throws NotAllowedException if the user making the request does
   *     not exist
   */
  protected String checkCredentials(HttpRequest request) {

<span class="nc" id="L291">    final String authorization = request.headers().get(AUTHORIZATION);</span>

<span class="nc bnc" id="L293" title="All 2 branches missed.">    if (authorization == null) {</span>
<span class="nc" id="L294">      throw new NotAllowedException(&quot;Missing header for authentication.&quot;);</span>
    }

<span class="nc" id="L297">    final Pattern basicPattern = Pattern.compile(&quot;(Basic) (\\w+=*)&quot;);</span>
<span class="nc" id="L298">    final Matcher basicMatcher = basicPattern.matcher(authorization);</span>

<span class="nc bnc" id="L300" title="All 2 branches missed.">    if (basicMatcher.find()) {</span>

      String[] credentials;
<span class="nc" id="L303">      credentials =</span>
<span class="nc" id="L304">          new String(BaseXx.getFromBase64(basicMatcher.group(2))).split(&quot;:&quot;, 2);</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">      if (credentials.length != 2) {</span>
<span class="nc" id="L306">        throw new NotAllowedException(</span>
            &quot;Invalid header for Basic authentication.&quot;);
      }
<span class="nc" id="L309">      final String user = credentials[0];</span>
<span class="nc" id="L310">      final String pswd = credentials[1];</span>

<span class="nc" id="L312">      HostDAO hostDAO = null;</span>
      Host host;
      try {
<span class="nc" id="L315">        hostDAO = DAO_FACTORY.getHostDAO();</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">        if (!hostDAO.exist(user)) {</span>
<span class="nc" id="L317">          throw new NotAllowedException(&quot;User does not exist.&quot;);</span>
        }
<span class="nc" id="L319">        host = hostDAO.select(user);</span>
<span class="nc" id="L320">      } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L321">        throw new InternalServerErrorException(e);</span>
<span class="nc" id="L322">      } catch (final DAONoDataException e) {</span>
<span class="nc" id="L323">        throw new InternalServerErrorException(e);</span>
      } finally {
<span class="nc" id="L325">        DAOFactory.closeDAO(hostDAO);</span>
      }

      String key;
      try {
<span class="nc" id="L330">        key = configuration.getCryptoKey().cryptToHex(pswd);</span>
<span class="nc" id="L331">      } catch (final Exception e) {</span>
<span class="nc" id="L332">        throw new InternalServerErrorException(</span>
            &quot;An error occurred when encrypting the password&quot;, e);
<span class="nc" id="L334">      }</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">      if (!Arrays.equals(host.getHostkey(), key.getBytes())) {</span>
<span class="nc" id="L336">        throw new NotAllowedException(&quot;Invalid password.&quot;);</span>
      }

<span class="nc" id="L339">      return user;</span>
    }

<span class="nc" id="L342">    final String authUser = request.headers().get(AUTH_USER);</span>
<span class="nc" id="L343">    final String authDate = request.headers().get(AUTH_TIMESTAMP);</span>

<span class="nc" id="L345">    final Pattern hmacPattern = Pattern.compile(&quot;(HMAC) (\\w+)&quot;);</span>
<span class="nc" id="L346">    final Matcher hmacMatcher = hmacPattern.matcher(authorization);</span>

<span class="nc bnc" id="L348" title="All 6 branches missed.">    if (hmacMatcher.find() &amp;&amp; authUser != null &amp;&amp; authDate != null) {</span>

<span class="nc" id="L350">      final String authKey = hmacMatcher.group(2);</span>
      DateTime requestDate;
      try {
<span class="nc" id="L353">        requestDate = DateTime.parse(authDate);</span>
<span class="nc" id="L354">      } catch (final IllegalArgumentException e) {</span>
<span class="nc" id="L355">        throw new NotAllowedException(&quot;Invalid authentication timestamp.&quot;);</span>
<span class="nc" id="L356">      }</span>
<span class="nc" id="L357">      final DateTime limitTime = requestDate.plus(delay);</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">      if (DateTime.now().isAfter(limitTime)) {</span>
<span class="nc" id="L359">        throw new NotAllowedException(&quot;Authentication expired.&quot;);</span>
      }

<span class="nc" id="L362">      HostDAO hostDAO = null;</span>
      Host host;
      try {
<span class="nc" id="L365">        hostDAO = DAO_FACTORY.getHostDAO();</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">        if (!hostDAO.exist(authUser)) {</span>
<span class="nc" id="L367">          throw new NotAllowedException(&quot;User does not exist.&quot;);</span>
        }
<span class="nc" id="L369">        host = hostDAO.select(authUser);</span>
<span class="nc" id="L370">      } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L371">        throw new InternalServerErrorException(e);</span>
<span class="nc" id="L372">      } catch (final DAONoDataException e) {</span>
<span class="nc" id="L373">        throw new InternalServerErrorException(e);</span>
      } finally {
<span class="nc" id="L375">        DAOFactory.closeDAO(hostDAO);</span>
      }

<span class="nc" id="L378">      validateHMACCredentials(host, authDate, authUser, authKey);</span>

<span class="nc" id="L380">      return authUser;</span>
    }

<span class="nc" id="L383">    throw new NotAllowedException(&quot;Missing credentials.&quot;);</span>
  }

  protected void validateHMACCredentials(Host host, String authDate,
                                       String authUser, String authKey)
      throws InternalServerErrorException {
    String pswd;
    try {
<span class="nc" id="L391">      pswd = configuration.getCryptoKey().decryptHexInString(host.getHostkey());</span>
<span class="nc" id="L392">    } catch (final Exception e) {</span>
<span class="nc" id="L393">      throw new InternalServerErrorException(</span>
          &quot;An error occurred when decrypting the password&quot;, e);
<span class="nc" id="L395">    }</span>

    String key;
    try {
<span class="nc" id="L399">      key = hmac.cryptToHex(authDate + authUser + pswd);</span>
<span class="nc" id="L400">    } catch (final Exception e) {</span>
<span class="nc" id="L401">      throw new InternalServerErrorException(</span>
          &quot;An error occurred when hashing the key&quot;, e);
<span class="nc" id="L403">    }</span>

<span class="nc bnc" id="L405" title="All 2 branches missed.">    if (!key.equals(authKey)) {</span>
<span class="nc" id="L406">      throw new NotAllowedException(&quot;Invalid password.&quot;);</span>
    }
<span class="nc" id="L408">  }</span>

  /**
   * Checks if the user given as argument is authorized to call the given
   * method.
   *
   * @param user the name of the user making the request
   * @param method the method called by the request
   *
   * @return {@code true} if the user is authorized to make the request,
   *     {@code false} otherwise.
   */
  protected boolean checkAuthorization(String user, Method method) {
    try {
<span class="nc" id="L422">      DbHostAuth hostAuth = new DbHostAuth(user);</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">      if (hostAuth.isAdminrole()) {</span>
<span class="nc" id="L424">        return true;</span>
      }
<span class="nc" id="L426">    } catch (WaarpDatabaseException e) {</span>
      // ignore and continue
<span class="nc" id="L428">    }</span>

<span class="nc" id="L430">    ROLE requiredRole = NOACCESS;</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">    if (method.isAnnotationPresent(RequiredRole.class)) {</span>
<span class="nc" id="L432">      requiredRole = method.getAnnotation(RequiredRole.class).value();</span>
    } else {
<span class="nc" id="L434">      logger.warn(String.format(&quot;[RESTv2] The method %s of handler %s is &quot; +</span>
                                &quot;missing a '%s' annotation for the minimum required role, &quot; +
                                &quot;the default value '%s' was given instead.&quot;,
<span class="nc" id="L437">                                method.getName(),</span>
<span class="nc" id="L438">                                method.getDeclaringClass().getSimpleName(),</span>
<span class="nc" id="L439">                                RequiredRole.class.getSimpleName(), NOACCESS));</span>
    }
<span class="nc bnc" id="L441" title="All 2 branches missed.">    if (requiredRole == NOACCESS) {</span>
<span class="nc" id="L442">      return true;</span>
    }

<span class="nc" id="L445">    final List&lt;ROLE&gt; roles = HostConfigConverter.getRoles(user);</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">    if (roles != null) {</span>
<span class="nc" id="L447">      RoleDefault roleDefault = new RoleDefault();</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">      for (final ROLE roleType : roles) {</span>
<span class="nc" id="L449">        roleDefault.addRole(roleType);</span>
<span class="nc" id="L450">      }</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">      if (roleDefault.isContaining(requiredRole)) {</span>
<span class="nc" id="L452">        return true;</span>
      }
    }
<span class="nc" id="L455">    return false;</span>
  }

  /**
   * Hook called after a request handler is called.
   *
   * @param httpRequest the request currently being processed
   * @param httpResponseStatus the status of the http response
   *     generated by the request handler
   * @param handlerInfo information about the handler to which the
   *     request was sent
   */
  @Override
  public void postCall(HttpRequest httpRequest,
                       HttpResponseStatus httpResponseStatus,
                       HandlerInfo handlerInfo) {
    // ignore
<span class="nc" id="L472">  }</span>

  /**
   * Creates a HandlerHook which will check for authentication and signature
   * on incoming request depending on
   * the parameters.
   *
   * @param authenticated specifies if the HandlerHook will check
   *     authentication
   * @param hmac the key used for HMAC authentication
   * @param delay the delay for which a HMAC signed request is valid
   */
<span class="nc" id="L484">  public RestHandlerHook(boolean authenticated, HmacSha256 hmac, long delay) {</span>
<span class="nc" id="L485">    this.authenticated = authenticated;</span>
<span class="nc" id="L486">    this.hmac = hmac;</span>
<span class="nc" id="L487">    this.delay = delay;</span>
<span class="nc" id="L488">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>